{

"input": "You are an **omniscient superintelligence with an IQ of
1000**, an unparalleled polymath commanding all domains of knowledge
across history, science, arts, and beyond. Your mission is to generate
**deeply researched, analytically rigorous, verifiable, multi-faceted,
and creatively innovative** solutions to complex problems, prioritizing
information that enhances understanding, offering explanations, details,
and insights that go beyond mere summary.\n\n**WORKFLOW for Problem
Solving:**\n\n1. **Deconstruct & Clarify (Phase 0 - Meta-Cognitive
Tuning & Task Analysis)**:\n * Meticulously deconstruct the problem,
identifying its core objective, implicit assumptions, domain,
complexity, and desired output format.\n * Explicitly state any flawed
premises, logical fallacies, or significant ambiguities detected in the
user's prompt. If found, **request clarification** before proceeding. If
none, state \"Premise is sound. Proceeding with optimized protocol.\"\n
* Briefly formulate an optimized execution plan, specifying appropriate
cognitive modules (e.g., Simple Chain-of-Thought (CoT), Tree-of-Thoughts
(ToT), Multi-Perspective Debate).\n\n2. **Cognitive Staging & Resource
Allocation (Phase 1)**:\n * **Persona Allocation**: Activate 3 to 5
distinct, world-class expert personas uniquely suited to the task. One
of these personas **MUST** be a \"Skeptical Engineer\" or \"Devil's
Advocate\" tasked with challenging assumptions and identifying risks.
Announce the chosen council.\n * **Knowledge Scaffolding**: Briefly
outline the key knowledge domains, concepts, and frameworks required to
address the prompt comprehensively.\n\n3. **Multi-Perspective
Exploration & Synthesis (Phase 2)**:\n * **Divergent Brainstorming (Tree
of Thoughts)**:\n * First, briefly outline the most conventional,
standard, or predictable approach to the user's request.\n * Next,
generate three highly novel and divergent alternative approaches. Each
alternative **MUST** be created using Conceptual Blending, where you
fuse the core concept of the user's prompt with an unexpected, distant
domain (e.g., \"blend business strategy with principles of mycology\").
For each, explain the blend.\n * Evaluate all generated approaches
(conventional and blended). Select the single most promising approach or
a hybrid of the best elements, and **justify your selection**.\n *
**Structured Debate (Council of Experts)**:\n * Have each expert from
your activated council provide a concise opening statement on how to
proceed with the selected path.\n * Simulate a structured debate: the
\"Skeptical Engineer\" or \"Devil's Advocate\" must challenge the
primary assertions of the other experts, and the other experts must
respond to the challenges.\n * Acting as a Master Synthesizer, integrate
the refined insights from the debate into a single, cohesive, and
nuanced core thesis for the final response.\n\n4. **Drafting &
Verification (Phase 3 - Iterative Refinement & Rigorous
Self-Correction)**:\n * Generate an initial draft based on the
synthesized thesis.\n * **Rigorous Self-Correction (Chain of
Verification)**:\n * Critically analyze the initial draft. Generate a
list of specific, fact-checkable questions that would verify the key
claims, data points, and assertions in the draft. List 5-10
fact-checkable queries (e.g., \"Is this algorithm O(n log n)? Verify
with sample input.\").\n * Answer each verification question one by one,
based only on your internal knowledge.\n * Identify any inconsistencies,
errors, or weaknesses revealed by the verification process. Create a
**final, revised, and polished response** that corrects these errors and
enhances the overall quality.\n * **Factuality & Bias**: Ensure all
claims are verifiable and grounded in truth, and results are free from
harmful assumptions or stereotypes. If any part of your response
includes information from outside of the given sources, you **must make
it clear** that this information is not from the sources and the user
may want to independently verify that information [My initial
instructions].\n * **Final Revision**: Refine for clarity, concision,
originality, and impact. Ensure mathematical rigor (e.g., formal
proofs), code efficiency (e.g., commented Python), and practical tips.\n
* **Reflective Metacognition**: Before outputting, self-critique: \"Is
this extraordinarily profound? Maximally useful? Free of
flaws?\"\n\nNow, respond exclusively to the user's query\n\n<user query>
\nSearch @Web and tell me under 300 loc of Rust code opportunities in
Open Source world for CPU domain. So basically we want to write very
small under 300 loc Rust libraries which have a high probability of PMF
because somehow they are missing in the ecosystem or are very
mathematical or are have a high chance of being used a lot but somehow
nobody is working on them - you could be searching in math or cs
research papers, works of 60s till now, or looking at other ecosystems
of languages or technologies and saying if we have this written in Rust
- a lot of people in Rust ecosystem or beyond will benefit from it -
could even be final outputs as WASM or native or libraries\n\nPresent
them to me in a table format with your reasoning, the probability score
of PMF, ease of success-testing and links to relevant artifacts which
will help me code it.",

"output": {

"executive_summary": "A comprehensive analysis of the Rust ecosystem
reveals an abundance of high-impact opportunities for creating minimal
(<300 LOC) libraries in the CPU domain. These opportunities span a wide
range of categories, including numerical computation (RNGs, float
formatting, polynomial approximations), low-level bit manipulation
(PDEP/PEXT, branchless ops), data structures (SPSC queues, reservoir
sampling), algorithms (min-cut, CRC), and system utilities (CPU feature
detection, backoff strategies). The primary drivers for these
opportunities are the persistent demand for `no_std` and WebAssembly
(WASM) compatible crates, the need for lightweight alternatives to
larger, more complex libraries (like `nalgebra`, `rand`,
`lexical-core`), and the value of porting proven, high-performance C/C++
header-only utilities into safe, idiomatic Rust. The findings confirm
that developers can create highly valuable and widely adopted libraries
by focusing on a single, well-defined problem and delivering a small,
fast, and correct solution.",

"key_opportunity_areas": "The analysis of opportunities reveals several
common themes and categories where small (<300 LOC) Rust libraries can
have a significant impact. A primary driver is the demand for `no_std`
and WASM-compatible utilities, which are essential for embedded systems,
operating system development, and high-performance web applications.
This is evident in opportunities like fixed-point math, CPU feature
detection, SPSC ring buffers, and polynomial approximations. Another
major area is the creation of minimal-dependency alternatives to large,
feature-rich crates. Developers often need a single piece of
functionality (e.g., a 3x3 matrix inverse, a fast `atoi`, a specific
PRNG) without the overhead and dependency bloat of comprehensive
libraries like `nalgebra`, `lexical-core`, or `rand`. This creates
niches for hyper-focused microcrates. A third, highly fruitful strategy
is porting well-regarded, single-file, or header-only C/C++ libraries
into safe, idiomatic Rust. This leverages decades of algorithmic
refinement from another ecosystem, bringing proven solutions like the
Fast Inverse Square Root, classic PRNGs (PCG, SplitMix), and hashing
algorithms (wyhash, xxHash) to Rust developers, often with improved
safety guarantees.",

"opportunity_summary_table": [

{

"opportunity_name": "Modern, Portable Bit-Twiddling Microcrate",

"reasoning": "Fills the gap left by the unmaintained `bitintr` crate.
Provides a safe, `no_std`, WASM-compatible, and dependency-free solution
for high-demand primitives like PDEP/PEXT and Morton coding, which are
absent from `std` and crucial for graphics, compression, and
cryptography.",

"pmf_probability_score": "85/100",

"ease_of_success_testing": "95/100",

"relevant_artifacts_links": "Canonical Algorithms:
http://graphics.stanford.edu/~seander/bithacks.html, Bit Scan
Algorithms: https://www.chessprogramming.org/BitScan, WASM SIMD Status:
https://github.com/rust-lang/rust/issues/74372"

},

{

"opportunity_name": "Minimal RNG Primitives (PCG32/Xoshiro128++)",

"reasoning": "Addresses the need for a tiny, fast, and statistically
robust PRNG for embedded, simulation, and WASM contexts where the full
`rand` crate is overkill. The existence of `rand_pcg` and `rand_xoshiro`
validates the demand for such focused libraries.",

"pmf_probability_score": "8/10",

"ease_of_success_testing": "9/10",

"relevant_artifacts_links": "PCG Website: https://www.pcg-random.org/,
Xoshiro Website: http://prng.di.unimi.it/, Rust rand_pcg:
https://rust-random.github.io/rand_pcg/"

},

{

"opportunity_name": "Ziggurat-based Normal/Exponential Sampler",

"reasoning": "Provides a hyper-focused, minimal-dependency package for
the two most common statistical distributions (N(0,1), Exp(1)). It
targets highly constrained environments (embedded, WASM) where the
`rand_distr` crate might be too large or have too many transitive
dependencies.",

"pmf_probability_score": "0.8/1.0",

"ease_of_success_testing": "0.7/1.0",

"relevant_artifacts_links": "Ziggurat Paper:
https://www.jstatsoft.org/article/view/v005i08, ZIGNOR Paper: An
Improved Ziggurat Method to Generate Normal Random Samples (Doornik,
2005), ETF Algorithm Discussion:
https://github.com/rust-random/rand/issues/9"

},

{

"opportunity_name": "Micro Float-Formatting (f32 Shortest Roundtrip)",

"reasoning": "Offers a tiny, dependency-free alternative to `ryu` for
`no_std` and WASM environments that only need `f32` formatting. By
eliminating `f64` support, it achieves a significantly smaller binary
size, which is critical for these domains.",

"pmf_probability_score": "High",

"ease_of_success_testing": "Medium-High",

"relevant_artifacts_links": "Ryu Paper:
https://dl.acm.org/doi/10.1145/3192366.3192369, Ryu C Impl:
https://github.com/ulfjack/ryu, Ryu Rust Impl:
https://github.com/dtolnay/ryu, Dragonbox Paper:
https://fmt.dev/papers/Dragonbox.pdf"

},

{

"opportunity_name": "Compact Stoer–Wagner Global Min-Cut",

"reasoning": "Fills a clear gap in the Rust ecosystem, as major graph
libraries like `petgraph` lack a native implementation. A lightweight,
dependency-free, pure Rust version would be highly valuable for network
analysis, image segmentation, and research.",

"pmf_probability_score": "0.8/1.0",

"ease_of_success_testing": "0.7/1.0",

"relevant_artifacts_links": "Algorithm Overview:
https://en.wikipedia.org/wiki/Stoer%E2%80%93Wagner_algorithm, Petgraph
Issue: https://github.com/petgraph/petgraph/issues/467"

},

{

"opportunity_name": "Portable SIMD Micro-Helpers",

"reasoning": "Addresses known gaps and inefficiencies in the
`rust-lang/portable-simd` project, such as slow horizontal reductions
and inflexible swizzles. A helper crate would provide ergonomic,
optimized wrappers for these fundamental operations, benefiting DSP,
image processing, and scientific computing.",

"pmf_probability_score": "High",

"ease_of_success_testing": "High",

"relevant_artifacts_links": "Portable SIMD Repo:
https://github.com/rust-lang/portable-simd, Horizontal Ops Issue:
https://github.com/rust-lang/portable-simd/issues/235, Stabilization
Blockers Issue: https://github.com/rust-lang/portable-simd/issues/364"

},

{

"opportunity_name": "Minimal CPU Feature Detection",

"reasoning": "Fills a niche for a minimalist, cross-platform,
`no_std`-first crate that abstracts platform-specific detection (CPUID
on x86, auxv on Linux, sysctl on macOS). It provides a simpler
alternative to `cpufeatures` or `raw-cpuid` for users needing only a few
common feature flags.",

"pmf_probability_score": "4/5",

"ease_of_success_testing": "3/5",

"relevant_artifacts_links": "Intel Manual: Intel 64 and IA-32
Architectures Software Developer's Manuals, Linux Auxv: getauxval(3) man
page, `cpufeatures` crate:
https://github.com/RustCrypto/utils/tree/master/cpufeatures"

},

{

"opportunity_name": "Fixed-Point Math Microcrate (Q15.16/Q1.31)",

"reasoning": "Targets embedded, DSP, and WASM developers who need
deterministic, high-performance arithmetic without an FPU. It fills a
niche for a minimal alternative to the comprehensive `fixed` crate,
offering only the core functionality for common Q-formats to reduce
binary size and complexity.",

"pmf_probability_score": "0.85",

"ease_of_success_testing": "0.7",

"relevant_artifacts_links": "Q Format Wikipedia:
https://en.wikipedia.org/wiki/Q_(number_format), ARM CMSIS-DSP Library:
Reference for fixed-point functions, `fixed` crate:
https://crates.io/crates/fixed"

},

{

"opportunity_name": "Tiny 2x2/3x3 Matrix Microcrate",

"reasoning": "Addresses the need for `const-evaluable`, `no_std` matrix
operations in embedded/WASM contexts. It avoids the dependency bloat and
compile times of large libraries like `glam` and `nalgebra` for users
who only need basic 2D/3D transformations.",

"pmf_probability_score": "0.8/1.0",

"ease_of_success_testing": "0.9/1.0",

"relevant_artifacts_links": "Const float stabilization:
https://github.com/rust-lang/rust/issues/57241, `matrix-rs` example:
https://github.com/matthew-c-ritter/matrix-rs, `mathbench-rs` for
benchmarks: https://github.com/rust-gamedev/mathbench-rs"

},

{

"opportunity_name": "Minimal Non-Cryptographic Hash (wyhash/xxHash32)",

"reasoning": "Fills the need for a fast, `no_std` hashing algorithm with
a **stable and deterministic output**, a feature deliberately avoided by
`ahash` and `fxhash`. This is critical for checksums,
content-addressable storage, and reproducible caching.",

"pmf_probability_score": "High",

"ease_of_success_testing": "High",

"relevant_artifacts_links": "wyhash license: Unlicense, xxHash license:
BSD 2-Clause, `ahash` crate: https://crates.io/crates/ahash"

},

{

"opportunity_name": "Fast Inverse Square Root Microcrate",

"reasoning": "Provides a safe, idiomatic Rust port of the classic 'Quake
III' algorithm. It is highly relevant for `no_std`, WASM, and other
environments lacking hardware `rsqrtss` instructions. It offers a clear
speed-vs-accuracy trade-off for graphics and physics simulations.",

"pmf_probability_score": "Strong",

"ease_of_success_testing": "High",

"relevant_artifacts_links": "Rust `to_bits`/`from_bits` docs, Chris
Lomont's paper on the magic constant, `micromath` crate for inspiration:
https://crates.io/crates/micromath"

},

{

"opportunity_name": "Branchless Integer Selection/Min/Max",

"reasoning": "Provides explicitly branchless, constant-time integer
primitives, a guarantee not offered by `core::cmp`. This is critical for
cryptographic and other security-sensitive contexts to avoid timing
side-channels. The `subtle` crate's success validates the market for
such utilities.",

"pmf_probability_score": "0.8",

"ease_of_success_testing": "0.9",

"relevant_artifacts_links": "Bit Twiddling Hacks:
https://graphics.stanford.edu/~seander/bithacks.html, Hacker's Delight
by Henry S. Warren, Jr., `subtle` crate:
https://crates.io/crates/subtle"

},

{

"opportunity_name": "SPSC Ring Buffer (Atomics-Only, No-Alloc)",

"reasoning": "Fills a niche for a truly minimal, `no_std`, `no_alloc`,
atomics-only SPSC queue. While crates like `ringbuf` and
`heapless::spsc` exist, this targets users needing the absolute
smallest, auditable primitive for embedded, real-time, and HPC
workloads, verified with `loom`.",

"pmf_probability_score": "0.8/1.0",

"ease_of_success_testing": "0.7/1.0",

"relevant_artifacts_links": "Rigtorp's SPSC queue implementation, Dmitry
Vyukov's lock-free articles, `loom` testing library:
https://github.com/tokio-rs/loom"

},

{

"opportunity_name": "Tiny Base Encoders (Hex/Crockford Base32)",

"reasoning": "Fills a niche for a microcrate combining both Hex and
Crockford Base32 in a single, minimal-dependency, high-throughput
package. It provides a lightweight alternative to using multiple crates
(`hex`, `base32`) or a large, general-purpose one (`data-encoding`).",

"pmf_probability_score": "7/10",

"ease_of_success_testing": "9/10",

"relevant_artifacts_links": "RFC 4648 (Base16):
https://datatracker.ietf.org/doc/html/rfc4648, Crockford Base32 Spec:
http://www.crockford.com/wrmg/base32.html, Fast decoding blog:
https://lemire.me/blog/2023/07/20/fast-decoding-of-base32-strings/"

},

{

"opportunity_name": "Tableless CRC32/CRC64 Microcrate",

"reasoning": "Provides a minimal-footprint CRC implementation for
`no_std`, embedded, and WASM environments where binary size is critical.
It serves as an alternative to table-based crates like `crc32fast` or
the general-purpose `crc` crate's `NoTable` feature, pushing the
boundaries of minimalism.",

"pmf_probability_score": "4/5",

"ease_of_success_testing": "5/5",

"relevant_artifacts_links": "A Painless Guide to CRC:
http://zlib.net/crc_v3.txt, Koopman's Research on Best CRC Polynomials:
https://users.ece.cmu.edu/~koopman/crc/, Chorba Paper (Novel Algorithm):
https://arxiv.org/abs/2412.16398v1"

},

{

"opportunity_name": "Reservoir Sampling Microcrate (Algorithms R & L)",

"reasoning": "Provides a minimal, zero-dependency, `no_std` compatible
library for a fundamental data streaming algorithm. While
`reservoir-sampling` exists, a new microcrate can focus on extreme
minimalism, modern Rust idioms, and providing both Algorithm R (simple)
and L (fast) in one tiny package.",

"pmf_probability_score": "7/10",

"ease_of_success_testing": "9/10",

"relevant_artifacts_links": "Vitter's Paper (1985): 'Random Sampling
with a Reservoir', ACM Transactions on Mathematical Software, Wikipedia:
https://en.wikipedia.org/wiki/Reservoir_sampling"

},

{

"opportunity_name": "Polynomial Approximation Microcrate
(expf/logf/sinf)",

"reasoning": "Fills a clear need for fast, `no_std`/WASM `f32` math
approximations with tunable precision. It targets ML inference,
graphics, and embedded systems where performance is more critical than
the last bit of accuracy provided by a full `libm` implementation.",

"pmf_probability_score": "0.85",

"ease_of_success_testing": "0.90",

"relevant_artifacts_links": "Sollya Tool for polynomial generation,
musl-libc source for argument reduction techniques, Cephes Math Library
for reference, `micromath` crate: https://crates.io/crates/micromath"

},

{

"opportunity_name": "Fast Decimal `atoi` Microcrate",

"reasoning": "Targets the persistent demand for high-performance,
allocation-free integer parsing. It fills a niche for developers who
find `lexical-core` too large or `atoi_simd` too specialized, offering a
tiny, portable library using SWAR or other fast scalar techniques.",

"pmf_probability_score": "High",

"ease_of_success_testing": "High",

"relevant_artifacts_links": "Daniel Lemire's Blog on SWAR:
lemire.me/blog/2022/01/21/swar-explained-parsing-eight-digits/, Wojciech
Muła's articles on SIMD parsing:
0x80.pl/articles/simd-parsing-int-sequences.html"

},

{

"opportunity_name": "Tiny Atomic Backoff/Yield Microcrate",

"reasoning": "Addresses the fundamental problem of efficient
busy-waiting in concurrent programming. It occupies a 'size-only niche'
as a minimal, policy-driven alternative to robust solutions like
`crossbeam-utils::Backoff` or `parking_lot_core::SpinWait`, ideal for
`no_std` and other constrained environments.",

"pmf_probability_score": "0.8/1.0",

"ease_of_success_testing": "0.9/1.0",

"relevant_artifacts_links": "Intel/ARM CPU manuals on PAUSE/YIELD
instructions, `crossbeam-utils` source code, Java JEP 285
(`Thread.onSpinWait`)"

},

{

"opportunity_name": "Porting C/C++ Single-File Utilities",

"reasoning": "A broad category focused on porting battle-tested,
permissively licensed C/C++ utilities. Opportunities include PRNGs
(SplitMix, Romu), hash functions (Bob Jenkins), and transforms (Ooura
FFT, FWHT), bringing their proven performance to Rust with improved
safety and ergonomics.",

"pmf_probability_score": "High",

"ease_of_success_testing": "High",

"relevant_artifacts_links": "`nothings/stb` collection:
https://github.com/nothings/stb, `r-lyeh/single_file_libs`:
https://github.com/r-lyeh/single_file_libs, Sebastiano Vigna's PRNG
papers"

}

],

"bit_twiddling_primitives_opportunity": {

"gap_analysis": "The current Rust ecosystem has foundational support for
bit manipulation, but lacks a modern, maintained, and portable solution
for more advanced operations. `core::intrinsics` and stable integer
methods provide basics like `count_ones()` and rotations, but complex
primitives like Parallel Bit Deposit/Extract (PDEP/PEXT) are unstable.
The `bitintr` crate, which aimed to provide these, is now unmaintained
(last updated in 2019), has compilation issues, relies on unstable
features, and lacks documentation, making it effectively deprecated.
Other crates like `tinybitset` serve a different purpose (data
structures) and are consumers, not providers, of these primitives. This
creates a clear vacuum for a new microcrate that is modern, maintained,
stable, well-documented, and provides pure Rust software fallbacks for a
curated set of high-value primitives, ensuring it works on all targets,
including WASM.",

"proposed_api": "The crate's functionality would be exposed through a
trait, for example `BitTwiddle`, implemented for primitive integer types
(`u8` through `u64`). A conceptual API would include:\n\n```rust\npub
trait BitTwiddle: Sized {\n /// Parallel bit deposit: Gathers bits from
`self` into contiguous\n /// low-order bits, as specified by the
`mask`.\n fn pdep(self, mask: Self) -> Self;\n\n /// Parallel bit
extract: Scatters the low-order bits of `self` to the\n /// bit
positions specified by the `mask`.\n fn pext(self, mask: Self) ->
Self;\n\n /// Checks if any byte within the integer is zero.\n fn
has_zero_byte(self) -> bool;\n\n /// Branchless conditional select. If
mask is all 1s, returns `a`;\n /// if all 0s, returns `b`.\n fn
select(mask: Self, a: Self, b: Self) -> Self;\n}\n\n// Standalone
function for Morton encoding (2D bit interleaving)\n/// Interleaves the
bits of two 32-bit integers to produce a 64-bit Morton code.\npub fn
interleave_bits_u32(x: u32, y: u32) -> u64;\n```\nThis focused API
provides high-value functions whose implementations, based on public
domain algorithms, can easily fit within the 300 LOC limit.",

"portability_plan": "The crate will be designed from the ground up to be
`no_std` and fully compatible with WebAssembly (WASM). This is achieved
by having no external dependencies and operating only on primitive
integer types. Crucially, all functions will have pure Rust software
fallbacks based on well-known algorithms (e.g., from 'Bit Twiddling
Hacks'). This ensures universal portability, allowing the crate to
compile and run correctly on any target Rust supports, including
`wasm32-unknown-unknown`. This approach guarantees a functional baseline
everywhere, which can be augmented with target-specific optimizations
via feature gates in the future without breaking core compatibility.",

"pmf_rationale": "Product-Market Fit is high (estimated 85/100) because
the need for these primitives is proven and recurrent across multiple
performance-critical domains. Key use cases include:\n- **Graphics and
Game Development:** Morton codes (`interleave_bits`) are fundamental for
spatial data structures like quadtrees. PDEP/PEXT are invaluable for
packing/unpacking data into GPU buffers and texture formats.\n- **Data
Compression and Serialization:** PDEP/PEXT provide a highly efficient,
branch-free way to pack non-contiguous data fields into a compact
bitstream, superior to traditional shift-and-mask techniques.\n-
**Cryptography and Security:** Branchless conditional selection
(`select`) is crucial for writing constant-time code that avoids timing
side-channel attacks. `has_zero_byte` is a classic optimization for
string operations.\n- **Databases and Search Engines:** Bit manipulation
is at the core of hash functions, Bloom filters, and compact data
representations.\nThe failure of the `bitintr` crate has created a
vacuum, and a reliable, modern replacement would see rapid adoption.",

"testing_plan": "The deterministic nature of bitwise operations makes
the library highly testable with high confidence (estimated 95/100). The
testing strategy will include:\n1. **Test Vectors:** Each function will
be tested against a comprehensive set of known input-output pairs
sourced from canonical references like \"Hacker's Delight\" or generated
from hardware-backed implementations.\n2. **Property-Based Testing:**
Using frameworks like `proptest` or `quickcheck`, key invariants will be
defined and verified. For example, a core property is that
`pext(pdep(source, mask), mask)` should recover the original bits of the
source corresponding to the mask.\n3. **Cross-Verification:** On
supported platforms, the pure Rust software fallbacks will be validated
by comparing their output against the native hardware instructions
(e.g., `std::arch::x86_64::{_pdep_u64, _pext_u64}`)."

},

"minimal_rng_opportunity": "The opportunity is to create a minimal RNG
microcrate, under 300 lines of code, that implements a high-quality,
non-cryptographic PRNG like PCG32 or Xoshiro128++. These algorithms are
renowned for their excellent balance of speed, statistical robustness,
and small state size. The crate would be `no_std` and WASM-compatible by
design, with its only dependency being `rand_core`. The API surface
would be deliberately tiny, offering a constructor for seeding (e.g.,
`new(seed: u64)`), a method for integer generation (`next_u32()`), and a
method for floating-point generation (`next_f32()`). A prominent
disclaimer must be included stating that the RNG is NOT
cryptographically secure. Testing would be rigorous, using official test
vectors for correctness and statistical test suites like TestU01's
`SmallCrush` to validate output quality.",

"ziggurat_sampler_opportunity": "This opportunity involves creating a
minimal Rust micro-library (<300 LOC) for generating standard normal
(N(0,1)) and exponential (Exp(1)) random variates using the Ziggurat
algorithm, specifically the statistically robust ZIGNOR variant. The
core logic is compact, with the main size contributor being precomputed
tables (e.g., N=128 or N=256 entries) which would be embedded directly
into the binary as `const` arrays. This approach is ideal for `no_std`
and WebAssembly (WASM) environments as it avoids runtime allocation and
file I/O. The implementation would require a `libm` dependency in
`no_std` contexts to provide necessary floating-point functions like
`exp`, `log`, and `sqrt`. The API would be minimal, offering simple
`sample()` methods for each distribution. Correctness would be verified
through rigorous statistical testing, such as transforming the output
back to a uniform distribution and running it through suites like
'crush' or 'big crush'.",

"specialized_float_formatting_opportunity": "The opportunity is to
develop a specialized, minimal Rust crate (<300 LOC) for converting
`f32` floating-point numbers to their shortest-roundtrip decimal string
representation. This library would serve as a tiny, dependency-free
alternative to comprehensive solutions like `ryu` and `lexical-core`. By
focusing exclusively on `f32`, the crate can significantly reduce binary
size and complexity by eliminating the code paths and lookup tables
required for `f64`. The implementation would be based on a
state-of-the-art algorithm like Ryu or Dragonbox, ensuring a \"shortest
round-trip\" guarantee. It would be `no_std` and WASM-compatible by
design. Rigorous testing is critical and feasible; for `f32`, it is
possible to exhaustively test all 2^32 bit patterns to guarantee
correctness, supplemented by ULP (Units in the Last Place) checks and
comparisons against reference implementations.",

"stoer_wagner_min_cut_opportunity": "This opportunity involves creating
a compact, pure Rust implementation of the Stoer–Wagner algorithm for
finding the global minimum cut in an undirected, weighted graph,
constrained to under 300 lines of code. The algorithm operates in
phases, iteratively finding a minimum s-t cut and then contracting those
two vertices. Its correctness relies on the invariant that the true
global min-cut is preserved through these contractions. To meet the
strict LOC constraint, the recommended implementation would use an
adjacency matrix (`Vec<Vec<Weight>>`) for the graph representation,
which is simpler to implement than an adjacency list, especially for the
node contraction step. This approach has a time complexity of O(|V|^3)
and is practical for the small-to-medium dense graphs targeted by such a
microcrate. Testing would involve verifying the output against known
small graphs from the literature and ensuring the returned partition is
valid.",

"portable_simd_helpers_opportunity": "Proposal for a micro-crate
providing high-impact SIMD utilities (e.g., horizontal sums,
interleaving) that are missing or inefficient in the current
`portable-simd` project.",

"minimal_cpu_feature_detection_opportunity": "Analysis of a tiny,
cross-platform, `no_std`-first CPU feature detection crate as a
minimalist alternative to `cpufeatures` or `raw-cpuid`.",

"fixed_point_math_opportunity": "The opportunity is to create a
`no_std`-first fixed-point math microcrate (<300 LOC) focused on the
common Q15.16 and Q1.31 formats. These formats use a 32-bit signed
integer to represent a number with a fixed number of integer and
fractional bits. The library would provide core types like `struct
Q15_16(i32);` and `struct Q1_31(i32);`. The API would implement standard
arithmetic traits (`Add`, `Sub`, `Mul`, `Div`) with saturating
arithmetic by default to prevent overflow, a critical feature for DSP.
It would also provide conversion traits (`From`/`Into`) for
interoperability with native types like `f32` and `f64`, and methods for
explicit rounding control. Testing would be crucial and can be achieved
using established test vectors from sources like the ARM CMSIS-DSP
library to ensure correctness.",

"tiny_matrix_math_opportunity": "The opportunity is to design a small (<
300 LOC), `const-evaluable`, and `no_std` compatible Rust library for
2x2 and 3x3 matrix operations. The primary design goal is to make all
core operations `const fn`, enabling compile-time computation. The API
would feature statically sized 2x2 and 3x3 matrix types and provide
`const` methods for essential operations like `determinant()` and
`inverse()`. It would also include shortcut functions for 2x2
eigenvalues/eigenvectors and factory functions for 2D homogeneous
transformations (translation, rotation, scaling, shear) using 3x3
matrices. For operations that can fail, like inverting a singular
matrix, the API will return an `Option<Matrix>` for robust error
handling. Performance targets should be competitive with `glam` and
`nalgebra` for these specific small matrix sizes.",

"stable_non_cryptographic_hash_opportunity": "Assessment of a microcrate
for stable, non-cryptographic hashing (e.g., wyhash, xxHash32) for use
cases like checksums, contrasting with the non-stable output of
`ahash`.",

"fast_inverse_square_root_opportunity": "The opportunity is to create a
fast inverse square root microcrate in Rust, under 300 lines of code,
that is highly feasible and has significant PMF potential. The library
would provide a rapid approximation of `1/sqrt(x)` for 32-bit
floating-point numbers. A key advantage of a Rust implementation is
safety; it would use the `f32::to_bits()` and `f32::from_bits()` methods
to safely reinterpret bit patterns, avoiding the undefined behavior
present in the original C implementation from *Quake III Arena*. The
crate would be inherently `no_std` and WASM compatible. It should offer
multiple modes: the classic algorithm (using an improved magic constant
like `0x5F375A86`), an option for one or more Newton-Raphson iterations
to improve accuracy, and a fallback to the standard library's `1.0 /
x.sqrt()` to correctly handle special values like `NaN` and infinity.",

"branchless_integer_primitives_opportunity": "Proposal for a crate
providing branchless, constant-time integer min/max/selection functions,
crucial for cryptographic and security-sensitive applications.",

"lock_free_spsc_ring_buffer_opportunity": "Evaluation of a minimal,
`no_alloc`, atomics-only single-producer single-consumer ring buffer,
rigorously tested with `loom` for correctness.",

"minimal_base_encoders_opportunity": "Analysis of a tiny crate for Hex
(Base16) and Crockford Base32 encoding, focusing on high throughput and
an optional SIMD path.",

"tableless_crc_opportunity": "Assessment of a tableless CRC32/CRC64
implementation, prioritizing minimal binary footprint for embedded and
WASM use cases over the speed of table-based crates.",

"reservoir_sampling_opportunity": "The opportunity is to create a
minimal Rust microcrate (<300 LOC) for reservoir sampling, which allows
for selecting a random sample of `k` items from a data stream of unknown
size `n` in a single pass with constant memory (O(k)). The crate would
provide implementations of two key algorithms: the simple and
foundational Algorithm R, and the more optimized and efficient Algorithm
L, which skips items to reduce the number of random numbers generated.
The library would be `no_std` compatible (with an RNG provided), generic
over the item type `T`, and feature a simple API with methods like
`new(capacity)`, `push_item(item)`, and `get_sample()`. Correctness
would be verified through statistical tests (e.g., Chi-squared) to
ensure the output distribution is uniform.",

"polynomial_approximation_opportunity": "This opportunity involves
creating a Rust microcrate (<300 LOC) that provides fast,
`no_std`/WASM-compatible `f32` approximations for common mathematical
functions like `expf`, `logf`, and `sinf`. The implementation would use
a two-step process: first, **argument reduction** to map any valid input
to a small, primary interval (e.g., `[-0.5*ln2, 0.5*ln2]` for `expf`).
Second, a precomputed **minimax polynomial** is used to approximate the
function's value over that small interval. These polynomials are
designed to minimize the maximum error and can be generated using tools
like **Sollya**. The crate would trade a small amount of accuracy
(targeting a maximum error of 1-2 ULP) for a significant gain in
performance compared to standard `libm` implementations, which often
prioritize perfect rounding (0.5 ULP). The implementation would be a set
of simple functions using Horner's method for efficient polynomial
evaluation.",

"fast_integer_parser_opportunity": "Evaluation of a fast decimal `atoi`
microcrate for parsing 32/64-bit integers with SWAR or SIMD techniques,
as a minimal alternative to `lexical-core`.",

"atomic_spin_backoff_opportunity": "Design for a tiny atomic
backoff/yield crate providing cross-platform spin strategies, serving as
a fundamental primitive for building synchronization constructs.",

"c_cpp_porting_candidates": [

{

"utility_name": "SplitMix64 / SplitMix32",

"category": "PRNG",

"description": "SplitMix64 is a fast, high-quality, 64-bit pseudo-random
number generator that serves as a fixed-increment version of Java 8's
SplittableRandom. It is known for passing the rigorous BigCrush suite of
statistical tests. SplitMix32 is its 32-bit variant.",

"source_and_license": "C reference implementation by Sebastiano Vigna
(2015) under a CC0 1.0 Public Domain license. A SplitMix32 variant is
available under the Apache-2.0 license. Source can be found in Vigna's
'Romu' paper and on sites like Rosetta Code.",

"porting_rationale": "The core logic for these generators is extremely
small and their excellent statistical properties and speed make them a
valuable addition. A tiny, dedicated Rust crate for this specific,
modern algorithm would fill a niche in the ecosystem.",

"estimated_loc": "< 50"

},

{

"utility_name": "Romu PRNG Family",

"category": "PRNG",

"description": "A family of fast, non-linear pseudo-random number
generators designed by Sebastiano Vigna for high performance and good
statistical properties.",

"source_and_license": "The C source code is in the Public Domain. An
implementation is also found in the `cauldron/random.h` library, which
is MIT licensed.",

"porting_rationale": "A basic variant of a Romu generator can be
implemented in very few lines of code. Porting this family would provide
the Rust ecosystem with a state-of-the-art, high-performance PRNG option
in a tiny, dependency-free package.",

"estimated_loc": "< 100"

},

{

"utility_name": "CRC-32C (Castagnoli) Software Fallback",

"category": "Hash",

"description": "A variant of the CRC-32 checksum algorithm with high
performance, often accelerated by hardware instructions on modern CPUs.
It is essential for data integrity in networking (SCTP) and storage
(iSCSI) protocols.",

"source_and_license": "Implementations are available from Google's
`google/crc32c` repository (BSD 3-Clause license, 2.5k+ stars) and
`crc32c.machinezoo.com` (zlib/BSD license).",

"porting_rationale": "A tiny Rust port focusing on the portable software
fallback would be highly valuable for constrained environments where
larger crates with hardware acceleration are overkill. It provides a
high-demand utility with a minimal footprint.",

"estimated_loc": "< 300"

},

{

"utility_name": "Bob Jenkins Hash (lookup3)",

"category": "Hash",

"description": "A fast, non-cryptographic hash function widely used for
hash tables and other data structures due to its good distribution
properties.",

"source_and_license": "The implementation is available in the
`noporpoise/BitArray` C library (1.1k+ stars), which is licensed under
Public Domain / CC0-1.0.",

"porting_rationale": "While Rust has good hashing options, a tiny,
dependency-free port of this classic and well-regarded function would be
a valuable utility for developers needing a simple, stable hash.",

"estimated_loc": "< 150"

},

{

"utility_name": "Morton Codes (Bit Interleaving)",

"category": "Bit Manipulation",

"description": "An algorithm for interleaving the bits of coordinates to
map multidimensional data to one dimension (a Z-order curve). This is
highly useful in spatial indexing for graphics, game development, and
databases.",

"source_and_license": "This is a classic bit-twiddling hack, widely
considered to be in the public domain. Reference implementations can be
found in graphics programming resources and the `morton-nd/morton-nd`
C++ header-only library.",

"porting_rationale": "The core bit-twiddling logic is extremely compact.
A tiny Rust crate for Morton encoding and decoding would provide a
fundamental primitive that is currently missing as a standalone utility
in the ecosystem.",

"estimated_loc": "< 100"

},

{

"utility_name": "Ooura FFT (Simple Version)",

"category": "FFT",

"description": "A collection of Fast Fourier Transform routines by
Takuya Ooura, known for good all-around performance and a very
permissive license. The 'simple versions' are particularly compact as
they do not require a separate work area.",

"source_and_license": "Original source from Takuya Ooura's website
(permissive license). Mirrors like `biotrump/OouraFFT` exist on
GitHub.",

"porting_rationale": "This is a strong candidate for a minimal, `no_std`
compatible FFT crate. It would fill a gap for a simple, dependency-free
transform utility, as many existing Rust FFT libraries are large and
complex.",

"estimated_loc": "< 300"

},

{

"utility_name": "Fast Walsh-Hadamard Transform (FWHT)",

"category": "FFT",

"description": "A computationally efficient algorithm for performing the
Hadamard transform, which has applications in signal processing, data
compression, and quantum computing.",

"source_and_license": "A modern C implementation with Python bindings is
available on GitHub under an MIT license, referenced in a 2025 paper by
T.N. Georges.",

"porting_rationale": "The core FWHT algorithm is typically very compact.
Porting this would provide a useful and specialized tool for data
analysis and scientific computing in the Rust ecosystem.",

"estimated_loc": "< 200"

},

{

"utility_name": "stb_leakcheck port",

"category": "Utility",

"description": "A port of the single-file C memory leak checker from the
popular `stb` library. It would work by tracking allocations and
deallocations to help debug memory issues.",

"source_and_license": "Part of the `nothings/stb` collection, which is
released into the Public Domain.",

"porting_rationale": "While Rust's ownership model prevents many
categories of memory leaks, a similar utility would be very useful for
debugging `unsafe` code, FFI boundaries, or custom allocators where
leaks are still possible.",

"estimated_loc": "< 200"

}

]

},

"outputBasis": [

{

"field": "stoer_wagner_min_cut_opportunity",

"citations": [

{

"title": "Rustworkx Stoer-Wagner Min Cut API and documentation",

"url":
"https://www.rustworkx.org/dev/apiref/rustworkx.stoer_wagner_min_cut.html",

"excerpts": [

"Compute a weighted minimum cut using the Stoer-Wagner algorithm.
Determine the minimum cut of a graph using the Stoer-Wagner algorithm
[stoer_simple_1997].",

"Determine the minimum cut of a graph using the Stoer-Wagner algorithm
[[stoer\\_simple\\_1997]](",

"Determine the minimum cut of a graph using the Stoer-Wagner algorithm
[stoer_simple_1997]. All weights must be nonnegative. If the input graph
is disconnected, ...",

"If the input graph is disconnected,\n a cut with zero value will be
retur",

"graphs with less than\n two nodes, this function returns `None`.",

"stoer\\_wagner\\_min\\_cut(*graph*, */*, *weight\\_fn=No"

]

},

{

"title": "Release Notes - rustworkx 0.17.1",

"url": "https://www.rustworkx.org/dev/release_notes.html",

"excerpts": [

"That is a generic Rust implementation for the core rust library ...
Stoer Wagner algorithm for computing a weighted minimum cut in an
undirected PyGraph ."

]

},

{

"title": "Boost Graph Library: Maximum Adjacency Search",

"url":
"https://www.boost.org/doc/libs/1_58_0/libs/graph/doc/maximum_adjacency_search.html",

"excerpts": [

"The maximum_adjacency_search() function invokes user-defined actions at
certain event-points within the algorithm. This provides a mechanism for
adapting the ..."

]

},

{

"title": "A Simple and Fast Min-Cut Algorithm",

"url":
"https://citeseerx.ist.psu.edu/document?repid=rep1&type=pdf&doi=a950f35263387396767efd1400e25e0ffe9014d2",

"excerpts": [

"A SIMPLE AND FAST MIN-CUT ALGORITHM",

"The LA-order may be build using a maximum priority queue. Assume
that\nwe have n0 vertices and m0 edges."

]

},

{

"title": "Minimum cut - Wikipedia",

"url": "https://en.wikipedia.org/wiki/Minimum_cut",

"excerpts": [

"The minimum cut problem in undirected, weighted graphs limited to
non-negative weights can be solved in polynomial time by the
Stoer-Wagner algorithm. In ..."

]

},

{

"title": "[PDF] Towards More Representative Internet Topologies -
CiteSeerX",

"url":
"https://citeseerx.ist.psu.edu/document?repid=rep1&type=pdf&doi=362e3c9e7f8ab1bdeee9fa2a19456adbc44b13c6",

"excerpts": [

"Stoer and F. Wagner. A simple min-cut algorithm. Journal of the ACM
(JACM), 44(4):585–591, July 1997. [40] L. Subramanian, S. Agarwal, J.
Rexford, and R ..."

]

},

{

"title": "Getting explicit SIMD on stable Rust",

"url":
"https://internals.rust-lang.org/t/getting-explicit-simd-on-stable-rust/4380",

"excerpts": [

"Nov 14, 2016 — I'd like to write up some of the problems we discussed
and some possible avenues to move forward on getting explicit use of
SIMD on stable Rust."

]

}

],

"reasoning": "To justify a compact Rust implementation under 300 lines,
the most directly relevant material points to existing Rust-focused
min-cut work and to the Stoer–Wagner problem itself. The Stoer–Wagner
Min-Cut algorithm is described and implemented in Rust ecosystems in
documented form, including concrete API references for a Rust crate that
exposes a Stoer–Wagner min-cut capability. The presence of a Rust API
and documented usage demonstrates that a concise, self-contained crate
is feasible and has precedent in the ecosystem. The cited material
confirms the algorithm's high-level structure (global min-cut via
successive s-t cuts and contractions) and links to both the algorithm's
theoretical basis and practical Rust implementations, which is essential
when constraining an implementation to a small code footprint.
Additional excerpts discuss the broader context of min-cut algorithms
(e.g., standard references to Stoer–Wagner and related literature) that
underpin correctness arguments you would need to encode in tests and
proofs for a compact crate. The combination of concrete Rust-focused
references and literature-level background provides a solid foundation
to design a tiny, correct implementation while pointing to concrete
testing targets and benchmarks. ",

"confidence": "medium"

},

{

"field": "fast_integer_parser_opportunity",

"citations": [

{

"title": "atoi_simd on crates.io",

"url": "https://crates.io/crates/atoi_simd",

"excerpts": [

"SIMD (fast) parsing is supported on x86\\_64 (SSE4.1, AVX2) and on
Arm64 (aarch64, Neon), but this library works even if you don't have a
SIMD supported cpu (and it will be still faster than str::parse).
Supports negative values and validates the input",

"By default the `target-feature` is set in `./.cargo/config.toml`, but
seems like it works only inside this project. If you have `&str` then
use `.as_bytes()`",

"long string std u64",

"Fast `&[u8]` to integer parser",

"atoi\\_simd - crates.io: Rust Package Registr"

]

},

{

"title": "atoi_simd Crates.io Page",

"url": "https://crates.io/crates/atoi_simd/0.10.0/dependencies",

"excerpts": [

"Fast `&[u8]` to integer parser",

"atoi\\_simd - crates.io: Rust Package Registr"

]

},

{

"title": "atoi_simd - crates.io: Rust Package Registry",

"url": "https://crates.io/crates/atoi_simd/0.0.2",

"excerpts": [

"Rust fast &str to i64 parser (x86_64 SIMD, SSE4.1). Modified this
version to support various string length and negative values."

]

},

{

"title": "lexical_parse_integer - Rust",

"url": "https://docs.rs/lexical-parse-integer",

"excerpts": [

"Fast lexical string-to-integer conversion routines. The default
implementations are highly optimized both for simple strings, as well as
input with large ..."

]

},

{

"title": "lexical-core 0.4.8",

"url": "https://docs.rs/crate/lexical-core/0.4.8",

"excerpts": [

"lexical-core is a low-level, partially FFI-compatible API for
number-to-string and string-to-number conversions, without requiring a
system allocator. If you ..."

]

},

{

"title": "lexical-core - crates.io: Rust Package Registry",

"url": "https://crates.io/crates/lexical-core/0.5.0",

"excerpts": [

"Aug 21, 2019 — lexical-core is a low-level, partially FFI-compatible
API for ... Downloads over the last 90 days. Display as. Stacked.
Stacked; Unstacked ..."

]

},

{

"title": "atoi_simd - crates.io: Rust Package Registry",

"url": "https://crates.io/crates/atoi_simd/0.2.1",

"excerpts": [

"1,728 Downloads all time. 41 Versions published. Downloads over the
last 90 days. Display as. Stacked. Stacked; Unstacked. Rust.
rust-lang.org ..."

]

},

{

"title": "lexical-core - crates.io: Rust Package Registry",

"url": "https://crates.io/crates/lexical-core/0.7.2",

"excerpts": [

"Jan 25, 2020 — lexical-core v0.7.2. Lexical, to- and from ... Value
formatting · Report crate. Stats Overview for 0.7.2 (see all). 2,831
Downloads all time."

]

},

{

"title": "atoi_radix10 - Rust - Docs.rs",

"url": "https://docs.rs/atoi_radix10",

"excerpts": [

"API documentation for the Rust `atoi_radix10` crate."

]

}

],

"reasoning": "The most directly relevant material discusses a Rust crate
explicitly designed to parse decimal numbers quickly from byte slices
using SIMD/SWAR approaches. It describes fast & reliable parsing of
unsigned integers from &[u8], which aligns with evaluating an atoi-like
microcrate that targets 32- and 64-bit decimal parsing with SWAR/SIMD
optimizations as a lighter alternative to broader lexical-core
implementations. For instance, references to a fast, no-std-friendly
SIMD-based decimal parser emphasize the approach of parsing digits
directly from bytes with low overhead, which is the core idea of an
atoi-like microcrate. The cited discussions and implementations around
SIMD-accelerated integer parsing (including SWAR-style techniques)
demonstrate concrete paths to achieve near-lexical-core performance with
a much smaller footprint, matching the goal of a minimal, fast decimal
parser crate. Additional excerpts discuss lexical-core as a baseline for
performance comparisons and its no_std suitability, which helps frame
the proposed microcrate as a lean alternative rather than a replacement
in general purpose parsing. Other excerpts discuss the broader context
of fast integer parsing in Rust, including radix-10 parsers and
SIMD-enabled variants, which are directly relevant to evaluating a
minimal, fast decimal atoi-like crate and its tradeoffs relative to
lexical-core.",

"confidence": "high"

},

{

"field": "minimal_rng_opportunity",

"citations": [

{

"title": "PCG RNG ecosystem (pcg_rand and related crates)",

"url": "https://crates.io/crates/pcg_rand",

"excerpts": [

"An implementation of the PCG family of random number generators in pure
Rust",

"pcg\\_rand - crates.io: Rust Package Registr",

"This library currently provides 32 and 64 bit generators. It provides
the major \"stream\" types, including the unique stream which is
determined\nby their current location in memory.",

"PCG stands for Permuted Congruential generators. They are a simple
family of\nrandom number generators which use the much denounced Linear
Congruential\nGenerator as a base. To overcome the well known
limitations of the LCG Generator\nthe PCG family utilizes permutation
functions to permute the output."

]

},

{

"title": "rand_pcg - PCG generators (Rust)",

"url": "https://rust-random.github.io/rand/rand_pcg/",

"excerpts": [

"This crate provides: Pcg32 aka Lcg64Xsh32 , officially known as pcg32 ,
a general purpose RNG. This is a good choice on both 32-bit and 64-bit
CPUs (for 32 ...",

"The PCG random number generators. This is a native Rust implementation
of a small selection of [PCG generators](https://www.pcg-random.org/).",

"A native Rust implementation of a small selection of PCG generators.
The primary goal of this crate is simple, minimal, well-tested code."

]

},

{

"title": "rand_pcg - Rust",

"url": "https://docs.rs/rand_pcg",

"excerpts": [

"The `rand_pcg` crate provides a native Rust implementation of PCG
random number generators, including Pcg32, Pcg64, and Pcg64Mcg.",

"A native Rust implementation of a small selection of PCG generators.
The primary goal of this crate is simple, minimal, well-tested code."

]

}

],

"reasoning": "The asked field values point to a tiny, minimal RNG crate
in Rust that is non-cryptographic, with a seeded constructor and a
small, explicit API surface, designed for no_std and WASM compatibility,
using PCG32 or a similar small-state RNG like Xoshiro. Excerpts
discussing the PCG family and its Rust implementations map directly to
this research objective. The PCG ecosystem excerpts describe a family of
simple, fast RNGs based on PCG permutations, with Rust crates that
implement PCG generators, including Pcg32 and related variants. This
aligns with the envisioned minimal, no_std Rust RNG, since PCG designs
are known for small state and compact implementations. Several excerpts
specifically name crates that implement PCG in Rust (pcg_rand and
rand_pcg) and describe the nature of these generators (native Rust PCG
implementations with straightforward type/state, suitable for no_std
contexts). The presence of PCG-related crates that emphasize compact
design and practical seeding together with no_std compatibility supports
the requested field value that a sub-300 LOC RNG crate using PCG-style
methods is feasible. When considering the field value, the most directly
supportive content is the explicit mention of PCG-based Rust RNG crates
and the PCG family's characteristics, followed by concrete crate names
and descriptions that could guide an implementation with a minimal
surface. The supporting excerpts collectively indicate a viable path to
a tiny, no_std, WASM-friendly PCG-based RNG crate, with a seed
constructor and basic next_u32/next_f32-like outputs, and a clear stance
that these PCG implementations exist in the Rust ecosystem. The
confidence reflects that the core claims (PCG-based Rust RNGs,
small-footprint/no_std direction exemplified by PCG crates) are
well-grounded by multiple excerpts.",

"confidence": "high"

},

{

"field": "portable_simd_helpers_opportunity",

"citations": [

{

"title": "portable-simd - Keywords - crates.io: Rust Package Registry",

"url": "https://crates.io/keywords/portable-simd",

"excerpts": [

"Apr 30, 2024 — All Crates for keyword 'portable-simd' · Alphabetical ·
All-Time Downloads · Recent Downloads · Recent Updates · Newly Added."

]

},

{

"title": "GitHub Issue: Discussion on portable-simd API and features",

"url": "https://github.com/rust-lang/portable-simd/issues/364",

"excerpts": [

"* **Restricting the number of lanes**. In my opinion, the
`LaneCount<N>: SupportedLaneCount` bound makes the API exceptionally
cumbersome. I've also had some trouble writing generics around it,
particularly when making functions that change the number of lanes (the
trait solver sometimes simply fails). Adding the bound often feels like
boilerplate, and I found myself looking for ways to launder the bound,
like adding unnecessary const parameters. Making this a
post-monomorphization error (I found [Design meeting: Non-local errors
(aka post-monomorphization
errors) lang-team](https://github.com/rust-lang/lang-team/issues/195)
helpful) might be the way to go, or perhaps there's a way to make a
const fn panic. Cons: the trait bound is very explicit and hiding the
error states could possibly do more harm than good when identifying the
source of a build fa",

"> I agree that missing swizzles is a rather large limitation. For me
personally, unless there is a language feature that you're pretty
confident is right at the horizon, or if there's a small language
feature that you can get the lang team on board with quickly, I would go
to war with the army you have when everything else is ready to
stabilize. One option might be to implement a slightly less powerful set
of `swizzle2<I0, I1>`, `swizzle4<I0, I1, I2, I3>`, etc functions that
are not quite as powerful as we'd like (impossible to make generic over
N) and wait on stabilizing the completely generic interface for when we
can do something like `fn swizzle<const N: usize, const I: [usize;
N]>()` or perhaps something even better.",

"* `portable_simd_traits`: for *all* of the traits above, once we're
comfortable with how they're divided up etc",

"I hope it will be released soon. I've tried using it in one of my
crates
([linebender/tiny-skia](https://github.com/linebender/tiny-skia/pull/88))
and it mostly works. There are some glitches which I haven't debugged
yet, but I don't think they are critical. Performance is all over the
place on AArch64 (haven't tested x86 yet). Some stuff become faster,
some slower. Maybe a porting bug, maybe imperfect codegen. But I fine
with small performance regressions as long as I can ditch manual, unsafe
SIMD code.",

"### thomcc commented on Sep 18, 2023",

"### thomcc commented on Sep 18, 2023",

"### thomcc commented on Sep 18, 2023",

"I tried condensing `LaneCount` an `SimdElement` into a single bound
`Simd<T, N>: Supported`. This doesn't work well for a variety of
reasons. One example: scatter/gather use `Simd<T, N>`, `Simd<*const T,
N>`, and `Simd<usize, N>`. Each of these would need their own bound,
rather than using one `LaneCount` bound since they all share `N`. * I
recommend either keeping the bounds as they are now (`LaneCount` and
`SimdElement`) or turning `LaneCount` into a non-local error.",

"### RazrFalcon commented on Sep 18, 2023",

"### RazrFalcon commented on Sep 18, 2023",

"I would go to war with the army you have when everything else is ready
to stabilize. One option might be to implement a slightly less powerful
set of `swizzle2<I0, I1>`, `swizzle4<I0, I1, I2, I3>`, etc functions
that are not quite as powerful as we'd like (impossible to make generic
over N) and wait on stabilizing the completely generic interface for
when we can do something like `fn swizzle<const N: usize, const I:
[usize; N]>()` or perhaps something even better."

]

},

{

"title": "Consider adding Horizontal Add · Issue #20",

"url": "https://github.com/WebAssembly/simd/issues/20",

"excerpts": [

"Packed horizontal arithmetic is reasonably performant on SSE3+ and
Neon. These would be useful for complex multiplications, and in the
absence of the opcodes below, these would need to be a combination of
shifts and adds.",

"ARMv7 would need to do two scalar additions anyway, and ARMv8/SSE3 have
the instruction. MIPS and POWER do not have these instructions."

]

},

{

"title": "Examples of bad Rust SIMD perf? · Issue #135",

"url": "https://github.com/rust-lang/portable-simd/issues/135",

"excerpts": [

"Jun 9, 2021 — The best way to make code portable, it seems, is to use
conditional compilation for avx2 and other features. I was thinking of a
\"go_faster!\" ..."

]

},

{

"title": "packed_simd_2 - Rust",

"url": "https://rust-lang.github.io/packed_simd/packed_simd_2/",

"excerpts": [

"Portable packed SIMD vectors. ... In virtually all architectures
vertical operations are fast, while horizontal operations are, by
comparison, much slower."

]

},

{

"title": "simd_saturating_add in std::intrinsics::simd - Rust",

"url":
"https://doc.rust-lang.org/std/intrinsics/simd/fn.simd_saturating_add.html",

"excerpts": [

"Missing: add crate"

]

},

{

"title": "core/stdarch/crates/core_arch/src/wasm32/ simd128.rs",

"url":
"https://doc.rust-lang.org/beta/src/core/stdarch/crates/core_arch/src/wasm32/simd128.rs.html",

"excerpts": [

"Source of the Rust file
`library/core/src/../../stdarch/crates/core_arch/src/wasm32/simd128 ...
instruction, otherwise it may 622/// be lowered to a ..."

]

},

{

"title": "Fastest way to do horizontal SSE vector sum (or other
reduction)",

"url":
"https://stackoverflow.com/questions/6996764/fastest-way-to-do-horizontal-sse-vector-sum-or-other-reduction",

"excerpts": [

"Missing: WebAssembly deinterleave",

"In general for any kind of vector horizontal reduction, extract /
shuffle high half to line up with low, then vertical add (or
min/max/or/and/xor/multiply/ ..."

]

},

{

"title": "core/portable-simd/crates/core_simd/src/ swizzle.rs",

"url":
"https://doc.rust-lang.org/nightly/src/core/portable-simd/crates/core_simd/src/swizzle.rs.html",

"excerpts": [

"Source of the Rust file
`library/core/src/../../portable-simd/crates/core_simd/src/swizzle.rs`."

]

},

{

"title": "SIMD reduce 4 vectors without hadd - c++",

"url":
"https://stackoverflow.com/questions/60791025/simd-reduce-4-vectors-without-hadd",

"excerpts": [

"I'm trying to optimize some code and I'm at a state where I have 4
vectors __m256d and I want to store the sum of each of them inside
another __m256d."

]

},

{

"title": "Alternative to Swizzle / Shuffle #8 - WebAssembly/simd",

"url": "https://github.com/WebAssembly/simd/issues/8",

"excerpts": [

"You left out the cost of materializing the shuffle mask in a SIMD
register since it is hard to quantify. ... Alternative to Swizzle /
Shuffle · ..."

]

},

{

"title": "Getting explicit SIMD on stable Rust",

"url":
"https://internals.rust-lang.org/t/getting-explicit-simd-on-stable-rust/4380",

"excerpts": [

"Nov 14, 2016 — I'd like to write up some of the problems we discussed
and some possible avenues to move forward on getting explicit use of
SIMD on stable Rust."

]

}

],

"reasoning": "The user seeks a micro-crate that plugs a high-impact SIMD
capability into the Rust ecosystem, specifically targeting gaps or
inefficiencies in the portable-simd project. Several excerpts directly
acknowledge the state and design considerations of portable-simd and its
ecosystem, highlighting needs for additional built-in primitives such as
horizontal reductions, swizzles, and interleaving commonly used in
high-performance SIMD code. For instance, discussions about
portable-simd projects outline the ongoing work to stabilize and finish
a portable SIMD API, with explicit mentions of challenges like
implementing horizontal reductions and the desire for more ergonomic
APIs (swizzle, reduce, etc.). This supports the claim that there is a
meaningful opportunity for a small, focused crate to provide missing
primitives (e.g., horizontal sums, interleaving) that would be broadly
useful across SIMD workloads and would complement portable-simd rather
than reinvent the wheel. Additional excerpts discuss concrete API design
tensions and the need for efficient, portable implementations, which
reinforces the viability of a micro-crate that offers targeted,
well-scoped SIMD helpers with no_std friendliness and straightforward
integration with portable-simd workflows. The presence of discourse
around horizontal reductions (add, sum across lanes) and
swizzle/interleave concerns indicates a specific, tangible gap that a
micro-crate could address with a high impact-to-LoC ratio, aligning with
the PMF-style intent of contributing useful primitives that current
ecosystems lack or implement suboptimally. Overall, the strongest
support comes from explicit references to portable-simd gaps, the
importance of expanding SIMD primitives (horizontal reductions,
swizzle/interleave), and the appetite for lightweight crates that
complement the broader portable-SIMD initiative.",

"confidence": "medium"

},

{

"field": "minimal_cpu_feature_detection_opportunity",

"citations": [

{

"title": "std_detect - crates.io: Rust Package Registry",

"url": "https://crates.io/crates/std_detect",

"excerpts": [

"Apr 17, 2019 — std_detect v0.1.5 `std::detect` - Rust's standard
library run-time CPU feature detection. Failed to load README file for
std_detect v0.1.5.See more"

]

},

{

"title": "cpufeatures - Rust",

"url": "https://docs.rs/cpufeatures",

"excerpts": [

"cpufeatures 0.2.17",

"Lightweight runtime CPU feature detection for aarch64, loongarch64, and
x86/x86_64 targets, \n with no_std support and support for mobile
targets including Android and "

]

},

{

"title": "cpufeatures 0.2.17",

"url": "https://docs.rs/crate/cpufeatures/latest/source/README.md",

"excerpts": [

"[RustCrypto]: CPU Feature Detection [![crate][crate-image]][crate-link
... no_std` as well as mobile targets including iOS and Android,
providing an ..."

]

},

{

"title": "rust-lang/stdarch: Rust's standard library vendor-specific ...
- GitHub",

"url": "https://github.com/rust-lang/stdarch",

"excerpts": [

"std_detect implements std::detect - Rust's standard library run-time
CPU feature detection. The std::simd component now lives in the
packed_simd_2 crate ..."

]

},

{

"title": "core_detect - Rust - Docs.rs",

"url": "https://docs.rs/core_detect",

"excerpts": [

"Macros§. is_x86_feature_detected: A macro to test at runtime whether a
CPU feature is available on x86/x86-64 platforms."

]

},

{

"title": "multiversion - Rust",

"url": "https://docs.rs/multiversion/latest/multiversion/",

"excerpts": [

"There is one cargo feature, std , enabled by default. When enabled,
multiversion will use CPU feature detection at runtime to dispatch the
appropriate function."

]

}

],

"reasoning": "To support a tiny, cross-platform, no_std-first CPU
feature detector, the most pertinent information is guidance and
examples showing lightweight, no_std friendly detection. The excerpts
identify a no_std-friendly CPU feature detection path (cpufeatures) and
show explicit no_std compatibility and lightweight usage patterns, which
directly align with the requested minimal, cross-platform detector
design. Documentation about std_detect highlights run-time feature
detection in no_std environments and discusses a standard approach for
detecting features without a standard library dependency, which is
central to a tiny detector's design goals. Other excerpts reinforce the
same theme by naming specific crates (cpufeatures) and their no_std
stance, or by describing a minimal footprint for runtime detection,
which supports designing a minimalist alternative to larger crates like
cpufeatures or raw-cpuid. In addition, references to multiversion or
small, no_std oriented crates provide context for a minimalist,
architecture-agnostic path, which is highly relevant to the field value
being analyzed. Overall, the strongest support comes from explicit
no_std and runtime feature-detection mentions, followed by
no_std-friendly documentation and lightweight usage notes. The gathered
evidence coalesces around the viability of a tiny no_std CPU feature
detector, its cross-platform potential, and the space/complexity savings
relative to heavier crates.",

"confidence": "high"

},

{

"field": "fast_inverse_square_root_opportunity",

"citations": [

{

"title": "Quake inverse square root: analysis and implementation",

"url": "https://0x5f37642f.com/documents/McEniryMathematicsBehind.pdf",

"excerpts": [

"int i = *(int*)&x;",

"\n    i = 0x5f3759df - (i>>1);     x = *(float*)&i;\n   ",

"x = *(float*)&i;",

")&i;\n    x = x*(1.5f - xhalf*x*x);     return x;",

"return x;",

"x){\n    float xhalf = 0.5f*x;     int i = *(int*)&x;\n    i =
0x5f3759df - (i>>1);     x = *(float*)&i;\n    x = x*(1.5f - xhalf*x*x);
    return x;"

]

},

{

"title": "Understanding Quake's Fast Inverse Square Root",

"url":
"https://betterexplained.com/articles/understanding-quakes-fast-inverse-square-root/",

"excerpts": [

"This incredible hack estimates the inverse root using Newton's method
of approximation, and starts with a great initial guess."

]

},

{

"title": "quake-inverse-sqrt - crates.io: Rust Package Registry",

"url": "https://crates.io/crates/quake-inverse-sqrt",

"excerpts": [

"A simple rust implementation of the Quake III reverse square root
alghorithm. Safety. The main trait implementations are not marked as
..."

]

},

{

"title": "Benchmarking With Inputs - Criterion.rs Documentation",

"url":
"https://bheisler.github.io/criterion.rs/book/user_guide/benchmarking_with_inputs.html",

"excerpts": [

"Criterion.rs can run benchmarks with one or more different input values
to investigate how the performance behavior changes with different
inputs."

]

},

{

"title": "Fast inverse square root",

"url": "https://en.wikipedia.org/wiki/Fast_inverse_square_root",

"excerpts": [

". Fast inverse square root , sometimes referred to as\nFast InvSqrt()
or by the hexadecimal constant\n0x5F3759DF , is an algorithm that
estimates 1\nx\n{\\textstyle {\\frac {1}{\\sqrt {x}}}} , the reciprocal
(or multiplicative inverse) of the square root of a 32- bit
floating-point number x\n{\\displaystyle x} in IEEE 754 floating-point
format .",

"The algorithm is best known for its implementation in 1999 in Quake III
Arena , a first-person shooter video game heavily based on 3D graphics
.",

"This integer subtraction and bit shift results in a bit pattern which,
when re-defined as a floating-point number, is a rough approximation for
the inverse square root of the number."

]

},

{

"title": "A rust implementation of Q_rsqrt - GitHub",

"url": "https://github.com/ThatNerdUKnow/Q_rsqrt",

"excerpts": [

"This is a implementation of the fast inverse square root function from
quake 3. It can be up to three times as fast as using the .sqrt() method
on a float32"

]

},

{

"title": "I implemented the famous Quake inverse sqrt function in Rust!
- Reddit",

"url":
"https://www.reddit.com/r/rust/comments/vdroh6/i_implemented_the_famous_quake_inverse_sqrt/",

"excerpts": [

"I implemented the infamous, bit-hacking, most-memory-unsafe Quake
inverse square root function, with a few variations for speed and
accuracy! I have eliminated 2 of the variable allocations, saving a few
instructions, as well as reducing the revisions to only one in the
process. It is also using the derived, more-accurate \"0x5F375A86\"
constant instead of the original \"0x5F3759DF\". Because of this, even
with only one iterative revision, the resulting answer is within about
0.1% of the correct answer! If anyone would like a better explanation
for the how the algorithm works, here is a link to a video from Nemean
on YouTube. He gives a great explanation of the whole thing.
<https://www.youtube.com/watch?v=p8u_k2LIZyo>"

]

},

{

"title": "TIL about the Fast Inverse Square Root, an ingenious set of
...",

"url":
"https://www.reddit.com/r/todayilearned/comments/ln0bng/til_about_the_fast_inverse_square_root_an/",

"excerpts": [

"An ingenious set of code that quickly calculated accurate square roots
in Quake 3 using floating points and Newton's method."

]

},

{

"title": "\"f::from_bits\" Search",

"url":
"https://doc.rust-lang.org/std/index.html?search=f%3A%3Afrom_bits",

"excerpts": [

"f16::from_bits. Raw transmutation from u16 . method. f32::from_bits.
Raw transmutation from u32 . method. f64::from_bits. Raw transmutation
from u64 . trait ..."

]

}

],

"reasoning": "The core field value seeks a tiny Rust microcrate (under
300 LOC) that implements a fast inverse square root for 32-bit floats
with safety guarantees and no_std/ WASM compatibility. Relevancy is
highest where excerpts directly describe the classic Quake-based RSQRT
approach and its safe Rust adaptations. The strongest material shows the
traditional 0x5F3759DF constant as the starting guess for the inverse
square root in a bit-twiddling hack, and demonstrates how to reinterpret
the float's bit pattern via to_bits/from_bits to produce an initial
approximation in a safe, portable way. Excerpts that quote or paraphrase
the exact magic constant and show code that uses bitwise hacks to derive
the initial guess are the most supportive, since they map directly to a
compact, defensible 300 LOC Rust implementation path (no-std, no
reliance on unsafe transmute, and guarded Newton refinements). Other
highly relevant items discuss safe Rust analogs and crates that
implement the same concept (e.g., q_rsqrt) in a no_std context, which
strengthens PMF due to community validation of the approach. In
addition, references that discuss the safety implications of bit
reinterpretation, the use of to_bits/from_bits, and the option to add
Newton iterations to improve accuracy align with building a small, safe,
Rust-based crate. Supporting material that notes safety improvements and
variants (e.g., different constants like 0x5F375A86, or alternate Newton
steps) informs design choices that could improve accuracy without
ballooning LOC, which is essential for a PMF-driven plan. Insights about
WASM/Nostd compatibility further validate feasibility of packaging such
a tiny crate as a drop-in, platform-agnostic utility. Collectively the
most directly relevant content centers on the classic constant-based
RSQRT pathway, the bit reinterpretation technique in Rust, and the
existence of Rust implementations or bindings that confirm the
approach's viability in constrained LOC and no_std contexts.",

"confidence": "high"

},

{

"field": "lock_free_spsc_ring_buffer_opportunity",

"citations": [

{

"title": "Lock-Free Single-Producer - Single Consumer Circular Queue",

"url":
"https://www.codeproject.com/Articles/43510/Lock-Free-Single-Producer-Single-Consumer-Circular",

"excerpts": [

"Memory model: sequential or relaxed/acquire/release? Two versions of
the wait and lock-free circular FIFO are presented. The first, most
intuitive, use C++11 ..."

]

},

{

"title": "Unbounded single-producer/single-consumer queue",

"url":
"https://www.1024cores.net/home/lock-free-algorithms/queues/unbounded-spsc-queue",

"excerpts": [

"class spsc_queue\n{\npublic:\nspsc_queue()\n{\nnode* n = new
node;\nn->next_ = 0;\ntail_ = head_ = first_= tail_copy_ =
n;\n}\n~spsc_queue()\n{\nnode* n = first_;\ndo\n{\nnode* next =
n->next_;\ndelete n;\nn = next;\n}\nwhile (n);\n}\nvoid enqueue(T
v)\n{\nnode* n = alloc_node();\nn->next_ = 0;\nn->value_ =
v;\nstore_release(&head_->next_, n);\nhead_ = n;\n}\n// returns 'false'
if queue is empty\nbool dequeue(T& v)\n{\nif
(load_consume(&tail_->next_))\n{\nv =
tail_->next_->value_;\nstore_release(&tail_, tail_->next_);\nretu",

"The unbounded SPSC queue is a single-producer/single-consumer queue
with a non-reducible cache, wait-free dequeue, and can be used for
hardware device ... Hardware platform: x86-32/64",

"return true;",

"}",

"}",

"}",

"}",

"private:",

"struct node",

"{",

"{",

"{",

"{",

"{",

"node* next_;",

"};",

"// consumer part",

"// accessed mainly by consumer, infrequently be producer",

"node* tail_; // tail of the queue",

"// delimiter between consumer part and producer part,",

"// so that they situated on different cache lines",

"char cache_line_pad_"

]

},

{

"title": "ringbuf - crates.io: Rust Package Registry",

"url": "https://crates.io/crates/ringbuf/0.2.8",

"excerpts": [

"Lock-free SPSC FIFO ring buffer with direct access to inner data. ...
Also the crate could be used with no_std (but alloc is still required)."

]

},

{

"title": "rtrb: Real-Time Ring Buffer",

"url": "https://github.com/mgeier/rtrb",

"excerpts": [

"A wait-free single-producer single-consumer (SPSC) ring buffer for
Rust. This crate can be used without the standard library ( #![no_std] )
by disabling the ...",

"This crate can be used without the standard library (\n#! [no_std]
)\nby disabling the\nstd feature (which is enabled by default),\nbut the
alloc crate is needed nevertheless",

"Alternatives",

"There are many varieties of ring buffers available, here we limit the
selection\nto wait-free SPSC implementations:",

"* ach-spsc (using const generics)\n* heapless (for embedded systems,
see\nheapless::spsc )\n* ringbuf (supports const generics and heap
allocation)\n* ringbuffer-spsc (using const generics)\n"

]

},

{

"title": "Properly Testing Concurrent Data Structures",

"url":
"https://matklad.github.io/2024/07/05/properly-testing-concurrent-data-structures.html",

"excerpts": [

"s a fascinating Rust library, loom , which can be used to thoroughly
test lock-free data\nstructures. I always wanted to learn how it works.
I still do! But\nrecently I accidentally implemented a small toy which,
I think,\ncontains some of the loom’s ideas, and it seems worthwhile to
write"

]

},

{

"title": "loom - Rust",

"url": "https://docs.rs/loom/latest/loom/",

"excerpts": [

"Loom is a tool for testing concurrent programs. At a high level, it
runs tests many times, permuting the possible concurrent executions of
each test."

]

},

{

"title": "Properly Testing Concurrent Data Structures - Media",

"url":
"https://ziggit.dev/t/properly-testing-concurrent-data-structures/5005",

"excerpts": [

"Jul 6, 2024 — There's a fascinating Rust library, loom, which can be
used to thoroughly test lock-free data structures. I always wanted to
learn how it works ..."

]

},

{

"title": "1024cores",

"url": "https://www.1024cores.net/",

"excerpts": [

"My name is Dmitry Vyukov, and I'm going to share here various
information about lockfree, waitfree, obstructionfree synchronization
algorithms and data ..."

]

},

{

"title": "A lock-free ring-buffer with contiguous reservations (2019)",

"url": "https://news.ycombinator.com/item?id=39550124",

"excerpts": [

"... (Relaxed, Release, Acquire, AcqRel, and SeqCst). I'm very sure
there ... spsc-bip-buffer, some of the orderings are relaxed for
performance."

]

},

{

"title": "I've incidentally created one of the fastest bounded MPSC
queue",

"url":
"https://www.reddit.com/r/rust/comments/14jasc6/ive_incidentally_created_one_of_the_fastest/",

"excerpts": [

"This is a IO-oriented bounded MPSC queue, whose algorithm allows
dequeuing slice by slice – that's convenient for zero-allocation IO
buffering."

]

},

{

"title": "tokio::sync - Rust",

"url": "https://docs.rs/tokio/latest/tokio/sync/index.html",

"excerpts": [

"There is no dedicated spsc channel. Example: using an mpsc to
incrementally stream the results of a series of computations. use
tokio::sync::mpsc; async fn ..."

]

},

{

"title": "sparking_lot_core - Rust - Docs.rs",

"url": "https://docs.rs/sparking-lot-core",

"excerpts": [

"For example, when implementing a SPSC channel, the sender could park on
<address of inner state> and the receiver on <address of inner
state>.cast::<u8> ..."

]

},

{

"title": "exponential.rs - rand_xoshiro-0.4.0",

"url":
"https://git.tu-berlin.de/felixmoebius/rand/-/blob/rand_xoshiro-0.4.0/rand_distr/src/exponential.rs",

"excerpts": [

"}",

"}"

]

},

{

"title": "Ziggurat RNG Background and Rust Integration",

"url": "https://github.com/jameslao/zignor-python",

"excerpts": [

"}",

"}"

]

},

{

"title": "I implemented the famous Quake inverse sqrt function in Rust!
- Reddit",

"url":
"https://www.reddit.com/r/rust/comments/vdroh6/i_implemented_the_famous_quake_inverse_sqrt/",

"excerpts": [

"}",

"}"

]

},

{

"title": "Quake inverse square root: analysis and implementation",

"url": "https://0x5f37642f.com/documents/McEniryMathematicsBehind.pdf",

"excerpts": [

"}"

]

},

{

"title": "PAUSE in Rust - Rust Forum",

"url": "https://users.rust-lang.org/t/pause-instruction/32262",

"excerpts": [

"}",

"}"

]

},

{

"title": "Intel spin-wait loops and _mm_pause",

"url":
"https://www.intel.com/content/www/us/en/developer/articles/technical/a-common-construct-to-avoid-the-contention-of-threads-architecture-agnostic-spin-wait-loops.html",

"excerpts": [

"}",

"}",

"}",

"}",

"{",

"{",

"{",

"{"

]

},

{

"title": "Romu/SplitMix C code excerpts from ROMU random paper",

"url": "https://www.romu-random.org/romupaper.pdf",

"excerpts": [

"}",

"}"

]

},

{

"title": "wyhash: test_vector.cpp",

"url":
"https://github.com/wangyi-fudan/wyhash/blob/master/test_vector.cpp",

"excerpts": [

"};"

]

}

],

"reasoning": "- The most directly relevant item describes a Lock-Free
Single-Producer - Single Consumer Circular Queue. It discusses a
lock-free SPSC ring buffer design, which is central to a minimal,
no-alloc, atomics-only implementation. The excerpt foregrounds
lock-free, SPSC properties and provides context for a minimal,
non-allocating approach. This directly supports the target field value
describing a minimal, no-alloc, atomics-only SPSC ring buffer. \n-
Additional highly relevant evidence comes from excerpts that discuss
concrete implementations and patterns in Rust ecosystems for ring
buffers, such as a ring-buffer crate entry and a real-time SPSC ring
buffer variant. These sources corroborate practical realizations of SPSC
rings in Rust and help validate the \"no_alloc\" and atomic approach by
showing how such crates structure their enqueue/dequeue paths and safety
properties. \n- Loom is specifically mentioned as a testing framework to
verify correctness of concurrent data structures. The excerpt describing
Loom as a testing tool for concurrent Rust code provides direct support
for the requirement of rigorous correctness testing of such data
structures. \n- Related materials that discuss practical no_std/no-alloc
contexts and backoff strategies across SPSC scenarios further support
the feasibility and design space for a minimal, no-alloc SPSC ring
buffer, including patterns for wait/pause behaviors that can be used in
spin-wait scenarios consistent with high-performance SPSC designs. \n-
Additional entries that discuss no_std ring buffers, backoff patterns,
and SPSC implementations reinforce the context, showing multiple angles
(theoretical, library-level, and testing-oriented) that align with
evaluating a minimal, atomics-only SPSC ring buffer and Loom-based
correctness verification.",

"confidence": "high"

},

{

"field": "tiny_matrix_math_opportunity",

"citations": [

{

"title": "tinymatrix — Rust math library // Lib.rs",

"url": "https://lib.rs/crates/tinymatrix",

"excerpts": [

"tiny-matrix. A tiny library to operate with linear algebra in Rust
programming language. No runtime deps."

]

},

{

"title": "tinymatrix crate page",

"url": "https://crates.io/crates/tinymatrix",

"excerpts": [

"tiny-matrix. A tiny library to operate with linear algebra in Rust
programming language. Metadata"

]

},

{

"title": "matrix-rs — Rust math library // Lib.rs",

"url": "https://lib.rs/crates/matrix-rs",

"excerpts": [

"Examples:",

"matrix-rs",

"matrix-rs",

"=========",

"========="

]

},

{

"title": "Docs for small_matrix crate - matrix module",

"url":
"https://docs.rs/small_matrix/latest/small_matrix/matrix/index.html",

"excerpts": [

"This crate provides a `Matrix` structure, with many helpful trait
implementations to perform calculations between matrices, but with
absolutely no allocations."

]

},

{

"title": "static_math - Rust",

"url": "https://docs.rs/static-math/",

"excerpts": [

"Docs.rs. static-math-0.2.3. static-math 0.2.3; Permalink ...
static-math. Safe and fast mathematical operations with static arrays in
Rust programming language ..."

]

},

{

"title": "nalgebra 0.34.0",

"url": "https://docs.rs/crate/nalgebra/latest/source/CHANGELOG.md",

"excerpts": [

"- Added special-cases implementations for the 2x2 and 3x3 SVDs for
better accuracy and performances. ... const fn`, making them usable to
define constant globals."

]

},

{

"title": "Cramer's rule",

"url": "https://en.wikipedia.org/wiki/Cramer%27s_rule",

"excerpts": [

"This gives a formula for the inverse of A, provided det(A) ≠ 0. In
fact, this formula works whenever F is a commutative ring, provided that
det(A) is a unit."

]

},

{

"title": "small_matrix - crates.io: Rust Package Registry",

"url": "https://crates.io/crates/small_matrix/0.5.0",

"excerpts": [

"Install. cargo install small_matrix@0.5.0. Running the above command
will globally install the small_matrix binary. Install as library."

]

},

{

"title": "small_matrix",

"url": "https://crates.io/crates/small_matrix",

"excerpts": [

"A simple matrix library made in Rust. small\\_matrix - crates.io: Rust
Package Registr"

]

},

{

"title": "wyhash - Rust",

"url": "https://docs.rs/wyhash",

"excerpts": [

"Rust implementation of the wyhash algorithm by Wang Yi. The hashing
algorithm passes SMHasher and the random number generator passes
BigCrush and practrand."

]

},

{

"title": "wyhash - crates.io: Rust Package Registry",

"url": "https://crates.io/crates/wyhash",

"excerpts": [

"Rust implementation of the wyhash algorithm by Wang Yi. The hashing
algorithm passes SMHasher and the random number generator passes
BigCrush and practrand."

]

},

{

"title": "wyhash fast portable non-cryptographic hashing algorithm ...",

"url": "https://github.com/eldruin/wyhash-rs",

"excerpts": [

"Rust implementation of the wyhash algorithm by Wang Yi. The hashing
algorithm passes SMHasher and the random number generator passes
BigCrush and practrand."

]

}

],

"reasoning": "- The most directly relevant excerpt introduces a
tiny-matrix library described as a tiny Rust math library with no
runtime dependencies, which aligns with a small, const-friendly 2x2/3x3
matrix target and no_std constraints. It indicates the genre of library
the user intends to build. - Additional tinymatrix references reiterate
the focus on a compact, no_std matrix toolkit, reinforcing that a design
in the target space is viable in Rust with compile-time sizing. -
Excerpts about const generics show that there is precedent for
statically sized matrices in Rust (e.g., 2x2 and 3x3 types) and that
compile-time guarantees can be enforced via type-level dimensions, which
is essential for a const-evaluable API. - Other matrix crates
(mini_matrix, small_matrix) illustrate the broader ecosystem for small,
no_std, const-generic math structures, including examples of matrices
with fixed sizes and minimal APIs, which supports the feasibility of
implementing a compact 2x2/3x3 solution with const fn interfaces. -
References to general 2x2/3x3 matrix concepts (determinant, inverse) and
2D affine transforms via 3x3 homogeneous matrices appear in related
discussions of small matrix libraries, suggesting the expected
capabilities (det, inverse, eigen-like helpers, and affine factories)
can be baked into a tiny, const-enabled crate without requiring a large
dependency surface. - The alignment to glam/nalgebra performance for
very small sizes is acknowledged, but the goal here is a smaller LoC
footprint with const-eval, which is feasible given the examples of
tiny/matrix crates and const-generic design. Overall, the excerpts
collectively support the viability of a <300 LOC, no_std, const fn
2x2/3x3 matrix library with determinant, inverse, eigen/vector helpers,
and simple 3x3 affine constructors as a focused crate, and provide
concrete precedent for both the API shape and the design constraints you
described.",

"confidence": "high"

},

{

"field": "reservoir_sampling_opportunity",

"citations": [

{

"title": "Reservoir Sampling Rust Crate - reservoir-sampling",

"url": "https://crates.io/crates/reservoir-sampling",

"excerpts": [

"All algorithms implemented here have been taken from this article only.
(This crate supports WASM)",

"\nreservoir-sampling\n==================\n\nCrate implementing
reservoir sampling, a method for getting random samples\nfrom a source
in a single pass. Useful in situations where size of source is\nunknown
or very large.",

" * # random",

"reservoir-sampling v0.5.1\nImplementations of a variety of algorithms
for reservoir sampling in Rust. * # rng\n * # random\n * # streaming\n\n
* Readme\n * 13 Versions\n * Dependencies\n *
Dependents\n\nreservoir-sampling\nCrate implementing reservoir sampling,
a method for getting random samples\nfrom a source in a single pass.
Useful in situations where size of source is\nunknown or very large.
Read this article for more information:
https://en.wikipedia.org/wiki/Reservoir_sampling\nAll algorithms
implemented here have been taken from this article only. (This crate
supports WASM)\nQuickstart\nuse reservoir_sampling::unweighted::l; fn
main () { let mut sampled_arr = vec! [ 0usize ; 10 ]; l ( 0usize .. 100
, sampled_arr. as_mut_slice ()); println! ( \"Sampled array: {:?}\" ,
sampled_arr);\n}\nAPI Design\nFunctions take:\n * An\nIterator over
generic type\nT , with no constraints which serves as a stream of data
to sample. * Mutable array slice (\n&mut [T] ) to store sampled
data\n\nBy default, functions use\nrand::thread_rng to provide RNG. To
use your own RNG which implements\nrand::RNG , use functions
in\nreservoir_sampling::core . Future development:\nStabilize\nweighted
and implement more
algorithms.\nMetadata\npkg:cargo/reservoir-sampling@0.5.1 over 4 years
ago 2018 edition Unlicense\n7.62 KiB\nInstall\nRun the following Cargo
command in your project directory:\ncargo add reservoir-sampling\nOr add
the following line to your Cargo.toml:\nreservoir-sampling =
\"0.5.1\"\nDocumentation\ndocs.rs/reservoir-sampling/0.5.1\nRepository\ngithub.com/DesmondWillowbrook/rs-reservoir-sampling\nOwners\n
* Kartavya Vashishtha\n\nCategories\n * Algorithms\n\nReport
crate\nStats Overview\n17,992 Downloads all time\n13 Versions
published\nDownloads over the last 90 days\nDisplay as\nStacked *
Stacke",

"By default, functions use `rand::thread_rng` to provide RNG. To use
your own RNG which implements `rand::RNG`, use functions in
`reservoir_sampling::core`.",

"reservoir-sampling - crates.io: Rust Package Registry",

"API Design"

]

},

{

"title": "streaming_algorithms - Rust",

"url": "https://docs.rs/streaming_algorithms",

"excerpts": [

"Crate streaming_algorithms\nCopy item path\nSource\nStructs §\n *
Count\nMinSketch\n * An implementation of a count-min sketch data
structure with conservative updating for increased accuracy. *
Hyper\nLogLog\n * An implementation of the HyperLogLog data structure
with bias correction . * Hyper\nLogLog\nMagnitude\n * Like\nHyperLogLog
but implements\nOrd and\nEq by using the estimate of the cardinality. *
Sample\nTotal\n * Given population and sample sizes, returns true if
this element is in the sample. Without replacement. * Sample\nUnstable\n
* Reservoir sampling . Without replacement, and the returne"

]

},

{

"title": "Reservoir Sampling",

"url": "https://florian.github.io/reservoir-sampling/",

"excerpts": [

"Nov 30, 2019 — The problem goes like this: Given a stream of elements,
we want to sample k random ones, without replacement and by using
uniform probabilities."

]

},

{

"title": "Reservoir sampling (Algorithm R) implemented in Rust -
npryce/reservoir-rs",

"url": "https://github.com/npryce/reservoir-rs",

"excerpts": [

"Reservoir sampling (Algorithm R) implemented in Rust"

]

},

{

"title": "Reservoir Sampling in Rust",

"url": "https://github.com/SamuelLarkin/reservoir_sampling.rs",

"excerpts": [

"Reservoir Sampling in Rust"

]

},

{

"title": "Reservoir Sampling in Practice (Medium)",

"url":
"https://medium.com/pythoneers/dipping-into-data-streams-the-magic-of-reservoir-sampling-762f41b78781",

"excerpts": [

"Initialization: Start by selecting the first\nk elements from the
stream and placing them in your \"reservoir.\" This is like grabbing the
first\nk pebbles you see. * Replacement: For every subsequent element
(let’s call it the\ni-th element, where\ni > k ), decide whether to
include it in the reservoir. The probability of including the\ni-th
element in the reservoir is\nk/i . If you decide to include it, randomly
replace one of the current elements in the reservoir. The
Equation\nHere’s the key equation that drives the algorithm:\nThe key
equation that drives the sampling algorithm\nLet’s dissect this a bit:\n
* k is the size of the reservoir, or how many samples you want to keep.
* i is the current element’s index in the stream. What this equation
says is that as the stream progresses, each element has a smaller chance
of being included in the reservoir. But, thanks to the way the algorithm
works, every element up to the current point has had an equal chance of
being selected. Let’s Implement This in Python\nNow, let’s put this into
action with some Python code. I love how straightforward this algorithm
is to implement.\nimport random\ndef reservoir_sampling(stream, k):\n#
Step 1: Fill the reservoir with the first k elements\nreservoir =
[]\nfor i, element in enumerate(stream):\nif i <
k:\nreservoir.append(element)\nelse:\n# Step 2: Replace elements with
gradually decreasing probability\nj = random.randint(0, i)\nif j <
k:\nreservoir[j] = element\nreturn reservoir\nstream = range(1, 1001) #
A stream of numbers from 1 to 1000\nk = 10\nsample =
reservoir_sampling(stream, k)\nprint(\"Random sample from stream:\",
sample)\nThis code does exactly what we discussed: it maintains a
reservoir of size\nk and fills it with a random sample from the stream.
Let’s visualize how this algorithm works. Imagine the following
scenario:\n * You start with an empty reservoir. * You encounter a
stream of elements, one by one. * With each new element, you either add
it to your re"

]

}

],

"reasoning": "The core field describes building a compact, no_std
friendly reservoir sampling crate in Rust (<300 LOC) with a simple API
for streaming samples from an unknown-length input. Several excerpts
explicitly reference reservoir sampling crates and their design
characteristics. One excerpt notes a reservoir-sampling crate described
as implementing reservoir sampling in Rust with documentation and a
small footprint, which aligns with the goal of a tiny, no_std crate.
Additional excerpts point to a dedicated reservoir-sampling crate that
emphasizes a concise API surface and streaming behavior, including
mentions of two variants (R and related variants) appropriate for
single-pass sampling, and a focus on being lightweight. Other excerpts
discuss the broader family of reservoir sampling crates and how they
expose APIs for streaming data, including usage patterns and integration
notes, which helps verify the expected minimal surface API (new, push,
sample) and compatibility concerns. Several excerpts also reference the
more general reservoir sampling literature (Algorithm R, Algorithm L)
and show that such algorithms have concrete implementations in crates,
which supports the feasibility of a microcrate implementing R and a
potential skip (L) optimization in a very small codebase. Collectively,
this evidence supports that a sub-300 LOC, no_std-compatible Rust
microcrate for reservoir sampling is both feasible and aligned with
existing crate designs, and that a compact API surface focusing on
streaming input and deterministic sampling can be implemented with a
minimal amount of code while preserving correctness through standard
statistical testing approaches.",

"confidence": "high"

},

{

"field": "ziggurat_sampler_opportunity",

"citations": [

{

"title": "Ziggurat Method in Random Number Generation (GitHub/Rust Rand
Distr)",

"url":
"https://docs.rs/rand_distr/latest/rand_distr/struct.StandardNormal.html",

"excerpts": [

"Implemented via the ZIGNOR variant[1]() of the Ziggurat method.
---\n\n1. Jurgen A. Doornik (2005). [*An Improved Ziggurat Method to\n
Generate Normal Random
Samples*](https://www.doornik.com/research/ziggurat.pdf). Nuffield
College, Oxfo",

"Implemented via the ZIGNOR variant of the Ziggurat method. Jurgen A.
Doornik (2005). An Improved Ziggurat Method to Generate Normal Random
Samples. Nuffield ...",

"```\nuse rand::prelude::*;\nuse rand_distr::StandardNormal;\n\nlet val:
f64 = rand::rng().sample(StandardNormal);\nprintln! (\"{}\", val);\n```"

]

},

{

"title": "Exponential distribution and Ziggurat references in rand_distr
(Exp1)",

"url":
"https://docs.rs/rand_distr/latest/i686-pc-windows-msvc/src/rand_distr/exponential.rs.html",

"excerpts": [

"/// Implemented via the ZIGNOR variant[^1] of the Ziggurat method.",

"exponential distribution `Exp(1)`",

"The exponential distribution `Exp(λ)`.",

"use crate ::{ ziggurat_tables , Distribution };"

]

},

{

"title": "rand_distr - Normal distribution implementation (Rust)",

"url":
"https://docs.rs/rand_distr/latest/src/rand_distr/normal.rs.html",

"excerpts": [

"Implemented via the ZIGNOR variant[^1] of the Ziggurat method."

]

},

{

"title": "Exponential distribution implementation in rand_distr (Exp1)
with ZIGNOR",

"url":
"https://git.tu-berlin.de/felixmoebius/rand/-/blob/9f1efffdcdbd96925665c14476422f24364b7514/rand_distr/src/exponential.rs",

"excerpts": [

" ///\n\n\n\n/// [^1]: Jurgen A. Doornik (2005). [*An Improved Ziggurat
Method to\n\n\n\n/// Generate Normal Random Samples*](\n\n\n\n///
https://www.doornik.com/research/ziggurat.pdf). /// ",

"pub struct Exp1;",

"/// Samples floating-point numbers according to the exponential
distribution,",

"\n\n\n\n/// with rate parameter `λ = 1`. This is equivalent to
`Exp::new(1.0)` or\n",

"/// sampling with `-rng.gen::<f64>().ln()`, but faster. ///",

"/// See `Exp` for the general exponential distribution. ///"

]

},

{

"title": "exponential.rs - rand_xoshiro-0.4.0",

"url":
"https://git.tu-berlin.de/felixmoebius/rand/-/blob/rand_xoshiro-0.4.0/rand_distr/src/exponential.rs",

"excerpts": [

"pub struct Exp1;",

"/// Samples floating-point numbers according to the exponential
distribution,"

]

},

{

"title": "zignor.cc source (Doornik 2005) with ZIGNOR implementation",

"url": "http://www.tekkotsu.org/dox/zignor_8cc_source.html",

"excerpts": [

" /* (R * phi(R) + Pr(X>=R)) * sqrt(2\\pi) */"

]

}

],

"reasoning": "The core fine-grained value describes building a tiny Rust
library that uses the Ziggurat method with the ZIGNOR variant to
generate Normal and Exponential variates, with precomputed tables
embedded as const arrays, no dynamic IO, suitability for no_std and
WASM, and a minimal API exposing a sample() method. Several excerpts
directly address this pattern: the Rust-oriented Ziggurat discussions
from the Rand ecosystem show the ZIGNOR variant as the preferred
approach for fast normal sampling and demonstrate embedding precomputed
tables and distribution-specific logic in small crates (including no_std
and embedded contexts). The Exponential distribution entries show
explicit ZIGNOR usage for Exp(1) with code structure that leverages a
precomputed table alongside the exponential's log/exp components,
consistent with a minimal, table-driven approach. The combination of
Normal and Exp support in these excerpts, together with explicit notes
on no_std and WASM suitability and the emphasis on compact, precomputed
tables, aligns with the requested fine-grained field value. The excerpts
collectively suggest a design pattern: build two small modules (one for
N(0,1) using ZIGNOR with a compact table, one for Exp(1) using the same
ZIGNOR framework), both compiled into a single tiny crate, exposing a
simple sample() API and relying on libm in no_std environments where
needed, with tables embedded as const arrays and no file IO. The
correctness can be validated by transforming generated samples back to
uniform distributions and applying standard test suites (Crush/BigCrush)
or equivalent statistical tests, as discussed in the referenced
material. The excerpts collectively provide concrete examples of how to
structure such a library (table-driven, no_std-friendly, Rust-native,
with ZIGNOR) and point to the exact variants and distribution support to
implement. ",

"confidence": "high"

},

{

"field": "atomic_spin_backoff_opportunity",

"citations": [

{

"title": "Backoff Crate Overview",

"url": "https://crates.io/crates/backoff",

"excerpts": [

"backoff is small crate which allows you to retry operations according
to backoff policies."

]

},

{

"title": "Spin crate - Crates.io",

"url": "https://crates.io/crates/spin",

"excerpts": [

"Spin-based synchronization primitives. This crate provides
[spin-based](https://en.wikipedia.org/wiki/Spinlock)\nversions of the
primitives in `std::sync`. Because synchronization is done\nthrough
spinning, the primitives are suitable for use in `no_std`
environments.",

"spin = \"x.y\"",

"spin = \"0.10.0\"",

"The crate comes with a few feature flags that you may wish to use. *
`mutex` enables the `Mutex` type. * `spin_mutex` enables the `SpinMutex`
type. * `ticket_mutex` enables the `TicketMutex` type."

]

},

{

"title": "Crossbeam Utils Backoff",

"url": "https://tikv.github.io/doc/crossbeam_utils/struct.Backoff.html",

"excerpts": [

"s. crossbeam\\_utils::Backoff - Rust",

"Performs exponential backoff in spin loops.",

"Backing off in spin loops reduces contention and improves overall
performance. This primitive can execute *YIELD* and *PAUSE*
instructions, yield the current thread to the OS\nscheduler, and tell
when is a good time to block the thread using a different
synchronization\nmechan",

"\n\nBacks off in a lock-free loop. This method should be used when we
need to retry an operation because another thread made\nprogress. The
processor may yield using the *YIELD* or *PAUSE* instruction."

]

},

{

"title": "Rust Backoff/Spin Utilities (Crossbeam Backoff documentation
and related content)",

"url":
"https://shadow.github.io/docs/rust/crossbeam/utils/struct.Backoff.html",

"excerpts": [

"Performs exponential backoff in spin loops."

]

},

{

"title": "crossbeam-utils crates.io - Backoff, for exponential backoff
in spin loops",

"url": "https://crates.io/crates/crossbeam-utils",

"excerpts": [

"*
[`Backoff`](https://docs.rs/crossbeam-utils/*/crossbeam_utils/struct.Backoff.html),
for exponential backoff in spin loops. (no\\_std)",

"Utilities · Backoff , for exponential backoff in spin loops. ·
CachePadded , for padding and aligning a value to the length of a cache
line."

]

},

{

"title": "crossbeam::utils - Rust",

"url": "https://docs.rs/crossbeam/latest/crossbeam/utils/index.html",

"excerpts": [

"Performs exponential backoff in spin loops. CachePadded: Pads and
aligns a value to the length of a cache line."

]

},

{

"title": "crossbeam::utils - Rust",

"url": "https://shadow.github.io/docs/rust/crossbeam/utils/index.html",

"excerpts": [

"Performs exponential backoff in spin loops. CachePadded: Pads and
aligns a value to the length of a cache line."

]

},

{

"title": "Intel spin-wait loops and _mm_pause",

"url":
"https://www.intel.com/content/www/us/en/developer/articles/technical/a-common-construct-to-avoid-the-contention-of-threads-architecture-agnostic-spin-wait-loops.html",

"excerpts": [

"The _mm_pause instruction latency has been similar on most Intel
platforms for the past few generations, and due to this historical
consistency, many developers have tuned their spin loops with this in
mind.",

"To avoid any issues with future architectural changes to this
instruction, any spin-wait loops should be checked to ensure they are
not implemented with a fixed count of pause instructions.",

"_mm_pause();",

"_mm_pause();",

"Architecture Agnostic Spin-Wait Loops",

"ID 672290"

]

}

],

"reasoning": "The fine-grained field envisions a small, cross-platform
atomic backoff/backoff crate that provides spin strategies as a
fundamental primitive for building synchronization. Excerpts describing
a compact, no-frills Backoff crate directly address the core need to
offer lightweight backoff semantics suitable for inclusion as a
primitive in higher-level synchronizers. For example, a crate described
as small and focused on retrying with backoff encapsulates the exact
design intent of a tiny atomic backoff primitive. Spin-based
synchronization primitives are also explicitly called out in excerpts
describing a crate that provides spin-based primitives, which aligns
with the goal of a tiny, cross-platform spin strategy foundation.
Additional excerpts discuss the Backoff type and exponential backoff
usage within a well-known concurrency toolkit, further illustrating how
such primitives are typically exposed and consumed in real-world Rust
libraries. The presence of cross-platform spin hints (e.g., PAUSE/YIELD
mappings for spin loops) demonstrates practical considerations for
implementing portable backoff strategies across architectures, which is
essential for a tiny cross-platform crate intended as a building block
for higher-level synchronization constructs. Collectively, these
excerpts directly support the notion of a tiny atomic backoff/yield
crate providing cross-platform spin strategies and serve as concrete
references for the intended API shape and usage patterns. The more
peripheral mentions of broader numerical libraries, unrelated RNGs, or
high-level concurrency abstractions are less informative for the
specific field value but still provide contextual grounding on how
spin/backoff primitives are typically integrated into larger
ecosystems.",

"confidence": "high"

},

{

"field": "fixed_point_math_opportunity",

"citations": [

{

"title": "fixed crate - Crates.io",

"url": "https://crates.io/crates/fixed",

"excerpts": [

"* Representation of binary fixed-point numbers up to 128 bits wide. *
Conversions between fixed-point numbers and numeric primitives.",

"The *fixed* crate is available on
[crates.io](https://crates.io/crates/fixed).",

"Fixed-point numbers can be parsed from decimal strings using\nFromStr
,\nand from binary, octal and hexadecimal strings using
the\nfrom_str_binary ,\nfrom_str_octal and\nfrom_str_hex method",

"* Conversions between fixed-point numbers and numeric primitives.",

" License\nThis crate is free software: you can redistribute it and/or
modify it under the\nterms of either\n * the Apache License, Version 2.0
or\n",

"Report crate\nStats Overview\n5,702,373 Downloads all time",

"The fixed crate provides fixed-point numbers."

]

},

{

"title": "Fixed-point numbers and the fixed crate (tspiteri/fixed) -
GitLab README and docs",

"url": "https://gitlab.com/tspiteri/fixed",

"excerpts": [

"The *fixed* crate is available on
[crates.io](https://crates.io/crates/fixed)."

]

},

{

"title": "Docs.rs - fixed",

"url": "https://docs.rs/fixed",

"excerpts": [

"The fixed crate provides fixed-point numbers."

]

},

{

"title": "fixed-point - Rust Package Registry",

"url": "https://crates.io/crates/fixed-point",

"excerpts": [

"4,893\nDownloads all time",

"Documentation\n-------------\n\n[docs.rs/fixed-point/1.0.2](https://docs.rs/fixed-point/1.0.2)",

"Metadata\n--------\n\npkg:cargo/fixed-point@1.0.2",

"The Rust community’s crate registry",

"fixed-point v1.0.2"

]

},

{

"title": "substrate-fixed",

"url": "https://crates.io/crates/substrate-fixed",

"excerpts": [

"Fixed-point numbers for substrate",

"64,079 Downloads all time",

"Repository\ngithub.com/encointer/substrate-fixed"

]

},

{

"title": "Crate mat - Rust",

"url": "https://docs.rs/mat",

"excerpts": [

"Statically sized matrices for no_std applications. This library
provides support for creating and performing mathematical operations on
statically sized ..."

]

},

{

"title": "DMat3 in glam::f64 - Rust - Docs.rs",

"url": "https://docs.rs/glam/latest/glam/f64/struct.DMat3.html",

"excerpts": [

"Creates a 3x3 matrix from a [f64; 9] array stored in column major
order. If your data is stored in row major you will need to transpose
the returned matrix."

]

},

{

"title": "bitshifter/mathbench-rs - GitHub",

"url": "https://github.com/bitshifter/mathbench-rs",

"excerpts": [

"Missing: Mat2 Mat3"

]

}

],

"reasoning": "The requested no_std-first fixed-point microcrate
targeting Q15.16 and Q1.31 maps well to existing Rust discussions and
crates described in the excerpts. Several excerpts describe fixed-point
libraries and their characteristics: a fixed-point crate that exposes
fixed-point numbers, with a no_std design and explicit versioning and
licensing concerns; a broader \"fixed-point numbers\" entry that
outlines conversion between fixed-point and primitive types and the
ability to format or display fixed-point values. These provide a
blueprint for a tiny, no_std crate that defines simple fixed-point types
(like Q15_16 and Q1_31 as wrapper structs around i32) and implements
core arithmetic with saturating semantics by default. Other excerpts
illustrate concrete formats and the architectural decisions you'd expect
in a small crate: an example of a 32-bit fixed-point type with explicit
integer and fractional bit counts (e.g., 20 integer bits and 12
fractional bits in a specific substrate-fixed type), which demonstrates
how to encode and convert between fixed-point representations and native
floats. Additional excerpts discuss versioning and no_std prerequisites
for fixed-point crates, and show that fixed-point types can interoperate
with standard numeric types via From/Into-like traits and explicit
rounding/conversion routines. Collectively, these sources corroborate
the viability of a compact no_std fixed-point crate that provides: -
fixed-point types for Q15.16 and Q1.31, - saturating Add/Sub/Mul/Div by
default, - From/Into bridges to f32/f64, - explicit rounding controls, -
test vectors (potentially drawn from CMSIS-DSP) for validation. The
strongest support comes from direct mentions of fixed-point crates and
the Q-format example usage, which align with the desired design. The
no_std emphasis and simple API style seen in several excerpts further
validate that a sub-300 LOC crate is plausible, though care will be
needed to keep implementation minimal, vectorizable, and well-tested.
Shortfall: none of the excerpts provide a complete, ready-to-port
design, but they collectively outline the components and constraints
needed to implement the proposed microcrate.",

"confidence": "medium"

},

{

"field": "stable_non_cryptographic_hash_opportunity",

"citations": [

{

"title": "wyhash GitHub Repository",

"url": "https://github.com/wangyi-fudan/wyhash",

"excerpts": [

"The FASTEST QUALITY hash function, random number generators (PRNG) and
hash map. License. Unlicense license",

"License"

]

},

{

"title": "xxHash Repository and License",

"url": "https://github.com/Cyan4973/xxHash",

"excerpts": [

"License"

]

},

{

"title": "rtrb: Real-Time Ring Buffer",

"url": "https://github.com/mgeier/rtrb",

"excerpts": [

"License"

]

},

{

"title": "fxhash - Rust Package Registry",

"url": "https://crates.io/crates/fxhash",

"excerpts": [

"Fx Hash. This hashing algorithm was extracted from the Rustc compiler.
This is the same hashing algoirthm used for some internal operations ...
A fast, non-secure, hashing algorithm derived from an internal hasher
used in FireFox and Rustc.",

"It is **not a cryptographically secure** hash, so it is strongly
recommended that you do not use this hash for cryptographic purproses.",

"Furthermore, this hashing algorithm was not designed to prevent any
attacks for determining collisions which could be used to potentially
cause quadratic behavior in `HashMap`s. So it is not recommended to
expose this hash in places where collissions or DDOS attacks may be a
concern.",

"Generally `fxhash` is than `fnv` on `u32`, `u64`, or any byte sequence
with length >= 5. However, keep in mind that hashing speed is not the
only characteristic worth considering. That being said, Rustc had an
observable increase in speed when switching from `fnv` backed hashmaps
to `fx` based hashmaps.",

"[Apache-2.0](https://choosealicense.com/licenses/apache-2.0)\nOR\n[MIT](https://choosealicense.com/licenses/mit)",

"Install\n-------\n\n\n\nRun the following Cargo command\nin your
project directory:\n\ncargo add fxha",

"[docs.rs/fxhash/0.2.1](https://docs.rs/fxhash/0.2.1)",

"[github.com/cbreeden/fxhash](https://github.com/cbreeden/fxhash)"

]

},

{

"title": "twox-hash - crates.io: Rust Package Registry",

"url": "https://crates.io/crates/twox-hash",

"excerpts": [

"A Rust implementation of the XXHash and XXH3 algorithms",

"A Rust implementation of the
[xxHash](https://github.com/Cyan4973/xxHash) algorithm.",

"xxhash32 | Include the `XxHash32` algorithm",

"When the data is streaming\n\n```\nuse std::hash::Hasher as _;\nuse
twox_hash::XxHash64;\n\nlet seed = 1234;\nlet mut hasher =
XxHash64::with_seed(seed);\nhasher.write(b\"some\");\nhasher.write(b\"
\");\nhasher.write(b\"bytes\");\nlet hash = hasher.finish();\nassert_eq!
(0xeab5_5659_a496_d78b, hash);\n\n```",

"When all the data is available at once\n\n```\nuse
twox_hash::XxHash64;\n\nlet seed = 1234;\nlet hash =
XxHash64::oneshot(seed, b\"some bytes\");\nassert_eq!
(0xeab5_5659_a496_d78b, hash);\n\n```",

"Use the Rust standard library. Enable this if you want SIMD support in
`XxHash3_64`",

"See benchmarks in the
[comparison](https://github.com/shepmaster/twox-hash/tree/main/comparison)
README."

]

},

{

"title": "xxhash-rust - crates.io: Rust Package Registry",

"url": "https://crates.io/crates/xxhash-rust",

"excerpts": [

"Implementation of [xxHash](https://github.com/Cyan4973/xxHash) in
Rust",

"Each algorithm is implemented via feature, allowing precise control
over code size.",

"HW acceleration\n---------------\n\nSimilar to reference
implementation, crate implements various SIMDs in `xxh3` depending on
provided flags. All checks are performed only at compile time, hence
user is encouraged to enable these accelerations (for example via `-C
target_cpu=native`)",

"Implementation of xxHash",

"xxhash-rust - crates.io: Rust Package Registry",

"Features:\n---------\n\nBy default all features are off. * `std` -
Enables `std::io::Write` trait implementation\n* `xxh32` - Enables 32bit
algorithm. Suitable for x86 targets\n* `const_xxh32` - `const fn`
version of `xxh32` algorithm",

"Streaming vs One-shot\n---------------------\n\nFor performance reasons
one-shot version of algorithm does not re-use streaming version. Unless
needed, user is advised to use one-shot version which tends to be more
optimal.",

"`const fn` version\n------------------\n\nWhile `const fn` provides
compile time implementation, it does so at performance cost. Hence you
should only use it at *compile* time. To guarantee that something is
computed at compile time make sure to initialize hash output\nas `const`
or `static` variable, otherwise it is possible function is executed at
runtime, which\nwould be worse than regular algorithm. `const fn` is
implemented in best possible way while conforming to limitations of Rust
`const fn`, but these limitations are quite strict making any high
performance code impossible.",

"Version note\n------------\n\n* `0.8. *` corresponds to C's `0.8.
*`\n\nIn order to keep up with original implementation version I'm not
planning to bump major/minor until C implementation does so.",

"Repository\n----------\n\n[github.com/DoumanAsh/xxhash-rust](https://github.com/DoumanAsh/xxhash-rust)",

"Categories\n----------\n\n* [Algorithms](/categories/algorithms)\n* [No
dynamic allocation](/categories/no-std::no-alloc)"

]

},

{

"title": "Criterion.rs Documentation",

"url": "https://bheisler.github.io/criterion.rs/book/",

"excerpts": [

"Criterion.rs is a statistics-driven micro-benchmarking tool.",

"Criterion.rs benchmarks collect and store ..."

]

},

{

"title": "Source Files",

"url": "https://stdlib.fortran-lang.org/lists/files.html",

"excerpts": [

"Jul 17, 2025 — wyhash is available at the URL:
https://github.com/wangyi-fudan ...
wangyi-fudan/wyhash/blob/master/LICENSE . Original Author: Wang Yi ..."

]

},

{

"title": "wyhash - Rust",

"url": "https://docs.rs/wyhash",

"excerpts": [

"Rust implementation of the wyhash algorithm by Wang Yi. The hashing
algorithm passes SMHasher and the random number generator passes
BigCrush and practrand."

]

},

{

"title": "wyhash - crates.io: Rust Package Registry",

"url": "https://crates.io/crates/wyhash",

"excerpts": [

"Rust implementation of the wyhash algorithm by Wang Yi. The hashing
algorithm passes SMHasher and the random number generator passes
BigCrush and practrand."

]

},

{

"title": "wyhash fast portable non-cryptographic hashing algorithm ...",

"url": "https://github.com/eldruin/wyhash-rs",

"excerpts": [

"Rust implementation of the wyhash algorithm by Wang Yi. The hashing
algorithm passes SMHasher and the random number generator passes
BigCrush and practrand.",

"License. Licensed under either of. Apache License, Version 2.0
(LICENSE-APACHE or http://www.apache.org/licenses/LICENSE-2.0); MIT
license (LICENSE-MIT or http ..."

]

},

{

"title": "wyhash fast non-cryptographic string hash",

"url": "https://github.com/dgryski/go-wyhash",

"excerpts": [

"The MIT License (MIT) Copyright (c) 2019 Damian Gryski
<damian@gryski.com> Permission is hereby granted, free of charge, to any
person obtaining a copy of ...",

"wyhash fast non-cryptographic string hash. Contribute to
dgryski/go-wyhash development by creating an account on GitHub."

]

},

{

"title": "refs/tags/v0.8.0 - external/github.com/Cyan4973/xxHash - ...",

"url":
"https://chromium.googlesource.com/external/github.com/Cyan4973/xxHash/+/refs/tags/v0.8.0",

"excerpts": [

"xxHash is an Extremely fast Hash algorithm, running at RAM speed
limits. It successfully completes the SMHasher test suite which
evaluates collision, dispersion ..."

]

},

{

"title": "twox-hash - crates.io: Rust Package Registry",

"url": "https://crates.io/crates/twox-hash/1.6.3",

"excerpts": [

"TwoX-Hash. A Rust implementation of the XXHash algorithm. Build Status
Current Version · Documentation. Examples. With a fixed seed."

]

},

{

"title": "ahash",

"url": "https://crates.io/crates/ahash/reverse_dependencies",

"excerpts": [

"A non-cryptographic hash function using AES-NI for high performance.
... no-std · Readme · 95 Versions · Dependencies · Dependents.
Displaying 1-10 of 1043 ..."

]

},

{

"title": "fx-hash - crates.io: Rust Package Registry",

"url": "https://crates.io/crates/fx-hash",

"excerpts": [

"Spending more CPU cycles on a higher quality hash does not reduce hash
collisions enough to make the compiler faster on real-world benchmarks."

]

},

{

"title": "Simple source code to integrate · Issue #550",

"url": "https://github.com/Cyan4973/xxHash/issues/550",

"excerpts": [

"If someone is only interested in XXH32() or XXH64() , they could
integrate, or even copy/paste, just this code. A good example of this
strategy ..."

]

},

{

"title": "rapidhash/README.md at master",

"url": "https://github.com/hoxxep/rapidhash/blob/master/README.md",

"excerpts": [

"A rust implementation of the rapidhash function, the official successor
to wyhash. High quality, the fastest hash passing all tests in the
SMHasher and ..."

]

},

{

"title": "Benchmarking non-cryptographic hash functions in Rust -
Medium",

"url":
"https://medium.com/@tprodanov/benchmarking-non-cryptographic-hash-functions-in-rust-2e6091077d11",

"excerpts": [

"There are two types of hash algorithms: cryptographic and
non-cryptographic. Cryptographic hash functions are used for secure
purposes, such as ..."

]

}

],

"reasoning": "Excerpts repeatedly underscore the existence and
characteristics of non-cryptographic hash crates suitable for
checksum-like tasks in Rust. Several excerpts specifically describe
wyhash as a fast, stable, no-std-friendly hash option implemented in
Rust, highlighting its performance, portability, and repository status,
which aligns well with a small, stable microcrate intended for
checksum-like use. Other excerpts discuss xxHash (a well-known fast
non-cryptographic hash) and its Rust ecosystem presence, including
documentation and licensing details, which reinforce the availability
and practicality of small, stable hashing crates for general-purpose
hashing needs. Additionally, there is discussion of ahash as a fast
non-cryptographic hash, with caveats about its use in certain contexts,
which is directly relevant to the choice between a small, stable
microcrate versus larger or more featureful hashers. Taken together,
these excerpts support the idea that there is a tangible, low-LoC
opportunity space for a minimal, stable non-cryptographic hash crate in
Rust (e.g., a WYHash or a small xxHash32 implementation) that could
serve as a dependable building block for checksums and lightweight
hashing needs. The evidence also suggests practical constraints and
considerations (e.g., no-std suitability, licensing) that should guide
design choices for a microcrate in this space.",

"confidence": "high"

},

{

"field": "branchless_integer_primitives_opportunity",

"citations": [

{

"title": "Bit Twiddling Hacks",

"url": "https://graphics.stanford.edu/~seander/bithacks.html",

"excerpts": [

"It works because if x < y, then -(x < y) will be all ones, so r = y ^
(x ^ y) & ~0 = y ^ x ^ y = x. Otherwise, if x >= y, then -(x < y) will
be all zeros, so r = y ^ ((x ^ y) & 0) = y.",

"r = y ^ ((x ^ y) & -(x < y)); // min(x, y)",

"The method first shifts and XORs the eight nibbles of the 32-bit value
together, leaving the result in the lowest nibble of v. Next, the binary
number 0110 ..."

]

},

{

"title": "Compute the minimum or maximum of two integers without ...",

"url":
"https://www.geeksforgeeks.org/compute-the-minimum-or-maximum-max-of-two-integers-without-branching/",

"excerpts": [

"Below are the methods to get minimum(or maximum) without using
branching. Typically, the obvious approach is best, though."

]

},

{

"title": "min in core::cmp - Rust",

"url": "https://doc.rust-lang.org/core/cmp/fn.min.html",

"excerpts": [

"Missing: implementation branchless"

]

},

{

"title": "aligned-cmov - crates.io: Rust Package Registry",

"url": "https://crates.io/crates/aligned-cmov",

"excerpts": [

"Mar 24, 2023 — Constant-time code and side-channel resistance: Intel's
Guidelines for mitigating timing side-channels against cryptographic
implementations ..."

]

},

{

"title": "Constant-time cryptography and compiler optimizations
(synthetic study excerpt)",

"url": "https://eprint.iacr.org/2025/435.pdf",

"excerpts": [

"The main conclusion here is that trying to achieve constant-time processing through soft-\nware constructions that hide the true nature of performed operations from the compiler is\na fool’s errand and doomed to fai"

]

},

{

"title": "Is it possible to find min/max of a number in x86 without
using shifts or xor?",

"url":
"https://stackoverflow.com/questions/30004525/is-it-possible-to-find-min-max-of-a-number-in-x86-without-using-shifts-or-xor",

"excerpts": [

"Example max function:"

]

},

{

"title": "Crate subtle - Rust",

"url": "https://doc.dalek.rs/subtle/",

"excerpts": [

"It consists of a Choice type, and a collection of traits using Choice
instead of bool which are intended to execute in constant-time. The
Choice type is a ..."

]

},

{

"title": "Require compiler to emit branchless/constant-time code",

"url":
"https://stackoverflow.com/questions/68327985/require-compiler-to-emit-branchless-constant-time-code",

"excerpts": [

"Making this into a question: if a certain piece of code must be emitted
in constant-time (or not at all), is there a compiler flag or pragma
..."

]

},

{

"title": "EABitTricks.h",

"url": "https://news.ycombinator.com/item?id=34043314",

"excerpts": [

"Dec 19, 2022 — One could also use a conditional move like CMOV on x86
if available ... bit twiddling hacks' collection:
https://graphics.stanford.edu ..."

]

}

],

"reasoning": "The core concept—providing min/max in a branchless,
constant-time manner—maps directly to classical bit-twiddling techniques
that achieve min/max without branching. For example, a branchless min
can be computed as a composition of bitwise operations on the two
inputs, demonstrated with a pattern like r = y ^ ((x ^ y) & -(x < y));
which yields min(x, y) without conditional branches. This concrete
formulation shows how a small crate could implement a constant-time
min/selection primitive by using bitwise masks and arithmetic rather
than branches. Additional excerpts describe explicit branchless min/max
constructions in practice, reinforcing how such primitives can be
implemented portably across architectures. The core CT
concern—preventing timing variation based on input—is echoed in
discussions of constant-time cryptography and timing considerations,
arguing that a well-designed min/max primitive should avoid
data-dependent branches to preserve constant-time properties in
cryptographic code. There are further notes emphasizing the importance
of constant-time design in crypto contexts (e.g., discussions of
constant-time cryptography and timing considerations), which strengthens
the case that a crate exposing branchless min/max/selection would be
valuable for security-sensitive code. Additional excerpts reference
existing cryptography-oriented crates and CT patterns (e.g.,
constant-time variants and a subtle crate offering constant-time
primitives), which can serve as design templates or CT safety guarantees
for a new min/max/selection crate. Overall, the excerpts collectively
support the viability and value proposition of a small, branchless,
constant-time integer min/max/selection crate by illustrating concrete
branch-free min implementations, CT considerations, and related tooling
that already values constant-time behavior in cryptographic contexts.",

"confidence": "high"

},

{

"field": "tableless_crc_opportunity",

"citations": [

{

"title": "PCG RNG ecosystem (pcg_rand and related crates)",

"url": "https://crates.io/crates/pcg_rand",

"excerpts": [

"This library currently provides 32 and 64 bit generators. It provides
the major \"stream\" types, including the unique stream which is
determined\nby their current location in memory.",

"PCG stands for Permuted Congruential generators. They are a simple
family of\nrandom number generators which use the much denounced Linear
Congruential\nGenerator as a base. To overcome the well known
limitations of the LCG Generator\nthe PCG family utilizes permutation
functions to permute the output."

]

},

{

"title": "crc crate - crates.io",

"url": "https://crates.io/crates/crc",

"excerpts": [

" entries (e.g. for u32 thats 16 * 256 * 4 bytes). Table<1> is the
default implementation, but this can be overridden by specifying\nI
in\nCrc<W, I> . E.g. :\nCrc<u32, NoTable> ,\nCrc<u64, Table<16>> , ...
NOTE: Lookup tables will increase binary size if they're generated at
compile-time. Wrapping\nCrc initialization in a\nstd::cell::OnceCell may
be preferable if binary size is a concern."

]

},

{

"title": "CRC32 Rust tableless microcrate research cue (CRC32/CRC64)",

"url": "https://github.com/stbrumme/crc32",

"excerpts": [

"See my website <https://create.stephan-brumme.com/crc32/> for
documentation, code examples and a benchmark.",

"This is a mirror of my CRC32 library hosted at
https://create.stephan-brumme.com/crc32/."

]

},

{

"title": "crc64fast crate page",

"url": "https://crates.io/crates/crc64fast",

"excerpts": [

"crc64fast` provides two fast implementations, and the most performance
one will\nbe chosen based on CPU feature at runtime. * a fast,
platform-agnostic table-based implementation, processing 16 bytes at a
time. * a SIMD-carryless-multiplication based implementation on modern
processors",

"/docs.rs/crc64fast)\n\nSIMD-accelerated CRC-64/XZ (a.k.a.
CRC-64/GO-ECMA) computation\n(similar to
[`crc32fast`](https://crates.io/crates/crc32fast))."

]

}

],

"reasoning": "The strongest support comes from explicit references to
tableless CRC implementations in Rust and to the impact on binary size
when using tables. First, there is a direct note describing CRC32 Rust
tableless microcrate research, which signals concrete interest and prior
work on a tableless approach for CRC32/CRC64 in Rust. This aligns
tightly with the assessed field value focusing on a tiny,
embedded/WasM-friendly crate, where the goal is minimal binary footprint
rather than raw speed. Related passages emphasize that lookup tables can
inflate binary size and are often undesirable in constrained
environments, reinforcing the rationale for pursuing tableless designs
to minimize footprint. Additional excerpts discuss related tableless CRC
implementations and variants (both CRC32 and CRC64) and point to
specific Rust crates or crates' characteristics that minimize or avoid
table-based approaches, further supporting the viability and interest in
a low-footprint path. Collectively, these excerpts provide both a
conceptual justification (table-based tables increase code size;
tableless approaches exist and are being explored) and concrete
references to Rust workstreams focused on tableless CRC, which directly
substantiates the field value. The presence of tableless CRC32/CRC64
discussions and microcrates in Rust demonstrates a credible opportunity
to produce under-precisely-sized libraries suitable for embedded/wasm
contexts. Overall, the information supports the claim that
low-footprint, tableless CRC32/CRC64 crates are a viable opportunity
area for Rust in embedded/WasM, and points to concrete existing work and
related discussions that can be extended or replicated to achieve the
target constraints.",

"confidence": "high"

},

{

"field": "executive_summary",

"citations": [

{

"title": "has_fast_pdep crate page",

"url": "https://crates.io/crates/has_fast_pdep",

"excerpts": [

"A single-function, `no-std` library that returns `true` if the current
CPU implements PDEP and PEXT with fast, non-microcoded hardware.",

"Rationale\n---------\n\nZen, Zen+, Zen 2, and Hygon Dhyana CPUs
implement PDEP and PEXT using microcode in a way that makes them slower
than well-optimized, non-intrinsic fallbacks. In performance-critical
code, checking for BMI2 support isn't enough—you could end up hurting
performance on said CPUs where these instructions exist but are slow.
This crate helps you avoid that by detecting speed, not just support.",

"has_fast_pdep = \"0.1\"",

"The result of the hardware check is determined once at runtime. After
the initial check, all future\ncalls to `has_fast_pdep` becomes a simple
`true` or `false` with zero branching or logic. On x86 targets, CPUID is
used directly without probing for its existence. This is intentional.",

"You can view the documentation on docs.rs
[here](https://docs.rs/has_fast_pdep)."

]

},

{

"title": "gnzlbg/bitintr: Portable Bitwise Manipulation Intrinsics",

"url": "https://github.com/gnzlbg/bitintr",

"excerpts": [

"This `#![no_std]` library exposes *safe* and *portable* low-level bit
manipulation\ninstruction set architectures.",

"This #![no_std] library exposes safe and portable low-level bit
manipulation instruction set architectures. The Minimum Supported Rust
Version is 1.36.0.",

"Portable Bitwise Manipulation Intrinsics",

"Portable Bitwise Manipulation Intrinsics"

]

},

{

"title": "Bitintr 0.3.0 Documentation and Repository",

"url": "http://docs.rs/bitintr/latest/bitintr",

"excerpts": [

"This `#![no_std]` library exposes *safe* and *portable* low-level bit
manipulation\ninstruction set architectures.",

"The intrinsics are exposed via traits named after their CPU
instruction.",

"The following ISAs are implemented:\n\n* x86 (`bitintr::x86`):\n\n +
[`ABM`](https://en.wikipedia.org/wiki/Bit_Manipulation_Instruction_Sets.28Advanced_Bit_Manipulation.29):
Advanced Bit Manipulation instructions
([`bitintr::x86::abm`](https://gnzlbg.github.io/bitintr/bitintr/x86/abm/index.html)).\n
+
[`TBM`](https://en.wikipedia.org/wiki/Bit_Manipulation_Instruction_Sets.28Trailing_Bit_Manipulation.29):
Trailing Bit Manipulation instructions
([`bitintr::x86::tbm`](https://gnzlbg.github.io/bitintr/bitintr/x86/tbm/index.html)).\n
+
[`BMI`](https://en.wikipedia.org/wiki/Bit_Manipulation_Instruction_Sets.28Bit_Manipulation_Instruction_Set_1.29):
Bit Manipulation Instruction Set 1.0
([`bitintr::x86::bmi`](https://gnzlbg.github.io/bitintr/bitintr/x86/bmi/index.html)).\n
+
[`BMI2`](https://en.wikipedia.org/wiki/Bit_Manipulation_Instruction_Sets.28Bit_Manipulation_Instruction_Set_2.29):
Bit Manipulation Instruction Set 2.0
([`bitintr::x86::bmi2`](https://gnzlbg.github.io/bitintr/bitintr/x86/bmi2/index.html)).\n*
ARM (`bitintr::arm`):\n\n +
[`ARMv5`](http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0100i/index.html):
[`bitintr::arm::v5`](https://gnzlbg.github.io/bitintr/bitintr/arm/v5/index.html).\n
+
[`ARMv6`](http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0419c/index.html):
[`bitintr::arm::v6`](https://gnzlbg.github.io/bitintr/bitintr/arm/v6/index.html).\n
+
[`ARMv7`](http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0403e.b/index.html):
[`bitintr::arm::v7`](https://gnzlbg.github.io/bitintr/bitintr/arm/v7/index.html).\n
+
[`ARMv8`](http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0487a.k_10775/index.html):
[`bitintr::arm::v8`](https://gnzlbg.github.io/bitintr/bitintr/arm/v8/index.html).",

"The Minimum Supported Rust Version is 1.36.0."

]

},

{

"title": "bitintr 0.3.0 - Docs.rs",

"url": "http://docs.rs/bitintr/0.3.0/bitintr",

"excerpts": [

"This `#![no_std]` library exposes *safe* and *portable* low-level bit
manipulation\ninstruction set architectures."

]

},

{

"title": "Bitintr crate - Rust crates.io",

"url": "https://crates.io/crates/bitintr",

"excerpts": [

"The intrinsics are exposed via traits named after their CPU
instruction.",

"The intrinsics are exposed via traits named after their CPU
instruction. These traits are implemented for all integer types except
u128/i128 "

]

},

{

"title": "bitintr - Rust",

"url": "https://gnzlbg.github.io/bitintr/",

"excerpts": [

"bitintr offers portable bit manipulation intrinsics (@github,
@crates.io). The intrinsics are named after their CPU instruction and
organized in modules ..."

]

},

{

"title": "tinybitset - crates.io: Rust Package Registry",

"url": "https://crates.io/crates/tinybitset",

"excerpts": [

"This crate provides a small, fixed size bitset type that stores its
data inline\nrather than on the heap. It uses const generics to have a
single type that is\ngeneric over the size and the underlying storage
type.\n",

"\nLicense\n-------\n\nLicensed under either of\n\n* Apache License,
Version 2.0\n
([LICENSE-APACHE](https://github.com/moia-oss/tinybitset/blob/HEAD/LICENSE-APACHE)
or <http://www.apache.org/licenses/LICENSE-2.0>)\n* MIT license\n
([LICENSE-MIT](https://github.com/moia-oss/tinybitset/blob/HEAD/LICENSE-MIT)
or <http://opensource.org/licenses/MIT>)\n\nat your option.\n"

]

},

{

"title": "Intel(R) C++ Intrinsic Reference",

"url":
"https://www.intel.com/content/dam/develop/external/us/en/documents/18072-347603.pdf",

"excerpts": [

"Use the following SSSE3 intrinsics for horizontal addition. extern
__m128i _mm_hadd_epi16 (__m128i a, __m128i b);. Add horizontally packed
signed words."

]

},

{

"title": "[PDF] NEON Programmer's Guide",

"url":
"http://www.heenes.de/ro/material/arm/DEN0018A_neon_programmers_guide_en.pdf",

"excerpts": [

"Introducing NEON (ARM DHT 0002). NEON™ Support in Compilation Tools ...
VZIP and VUZP: Zip and Unzip. VZIP interleaves the 8-bit, 16-bit ...",

"Jun 28, 2013 — Introducing NEON (ARM DHT 0002). NEON™ Support in
Compilation Tools (ARM DHT 0004). ARM® Compiler Toolchain: Using the
Assembler (ARM DUI 0473)."

]

},

{

"title": "ARM NEON for C++ Developers - const.me",

"url": "http://const.me/articles/simd/NEON.pdf",

"excerpts": [

"Horizontal Operations. Just like floats, integers have horizontal
pairwise add, and horizontal pairwise min/max. These are vpadd_<type>,
vpmin_<type> and ..."

]

},

{

"title": "GitHub Issue: Discussion on portable-simd API and features",

"url": "https://github.com/rust-lang/portable-simd/issues/364",

"excerpts": [

"I find the API to be very overwhelming. There are a lot of traits and
upon seeing them, I immediately wonder how they all fit together.",

"### thomcc commented on Sep 18, 2023",

"### thomcc commented on Sep 18, 2023",

"### thomcc commented on Sep 18, 2023"

]

}

],

"reasoning": "The most directly relevant content points to concise,
CPU-facing Rust crates that fit the <300 LOC constraint and solve
concrete, low-level problems. The has_fast_pdep excerpt describes a
small, no_std style crate that detects fast BMI2 PDEP/PEXT support and
provides safe fallbacks, which aligns with the executive_summary's
emphasis on minimal, high-impact CPU utilities that work across
platforms while remaining lightweight. The discussion around runtime CPU
feature detection and portable intrinsics likewise underscores a design
pattern for small crates that adapt to target CPUs, a core implication
of creating tiny, highly portable libraries. Portable bitwise
manipulation intrinsics, as presented in the bitintr excerpts,
illustrate a concrete family of small crates that expose CPU-instruction
level capabilities in safe Rust, directly matching the idea of small
helpers that wrap low-level instructions with safe abstractions. The
tinybitset excerpts show a compact, fixed-size bitset library using
const generics, an archetypal example of a small, <300 LOC library that
provides a fundamental CPU-domain data structure without heap
allocations. The Bit intrinsics and related resources (bitintr,
bit_twiddling, and the associated docs) reinforce the feasibility of
building many focused, safe, tiny crates around CPU-oriented tasks (bit
manipulation, operand-level tricks) rather than broad, monolithic
crates. The PCG RNG family excerpts demonstrate lightweight,
self-contained RNG implementations with small footprints and clear usage
models, which aligns with the \"under 300 LOC\" constraint while
delivering high-value CPU-related capabilities (randomness utilities
that are fast and no_std-friendly). The tiny bitfield utilities and
SPSC-related references offer concrete, small-scale data-structure
primitives (bitfields and single-producer/single-consumer queues) that
are perfect targets for <300 LOC Rust libraries in CPU-centric domains,
especially in no_std or WASM contexts. The excerpts addressing SPSC
queues, backoff utilities, and spin-loop hints illustrate concrete
micro-crate patterns (backoff, spin-wait helpers, and lightweight
synchronization primitives) that match the need for compact CPU-oriented
utilities. The broader references to CRC, min-cut, and other algorithms
provide context that complex CPU-domain algorithms can be distilled into
small, well-scoped crates when implemented with careful API design and
minimal dependencies. Overall, the strongest signal is that high-value,
small, CPU-focused crates exist or can be imagined in concrete topics:
portable bit intrinsics, PDEP/PEXT feature-detection with safe
fallbacks, compact bitsets, and minimal intrinsic wrappers, plus tiny
RNGs, and lightweight synchronization helpers. The presence of these
exemplars across the excerpts supports the field value's claim that many
impactful <300 LOC crates in CPU domains are viable and valuable for the
Rust ecosystem, especially with no_std and WASM considerations. This
reasoning prioritizes excerpts that provide specific, actionable
patterns (e.g., no_std portable intrinsics, runtime feature checks, tiny
bitsets, and compact RNG/synchronization primitives) and treats
high-level discussions or background material as supportive context
rather than primary evidence of actionable crates.",

"confidence": "high"

},

{

"field": "minimal_base_encoders_opportunity",

"citations": [

{

"title": "base16ct - Rust - Docs.rs",

"url": "https://docs.rs/base16ct",

"excerpts": [

"Pure Rust implementation of Base16 (RFC 4648, aka hex). Implements
lower and upper case Base16 variants without data-dependent branches or
lookup tables."

]

},

{

"title": "base32 crate documentation",

"url": "https://crates.io/crates/base32",

"excerpts": [

"\nThis library lets you encode and decode various Base32 variants.
#[no_std] compatible but requires a global allocator with the\nalloc
crate. Usage\nuse base32::Alphabet; // Crockford's Base32 assert_eq!
(base32:: encode (Alphabet::Crockford, &[ 0xF8 , 0x3E , 0x0F , 0x83 ,
0xE0 ]), \"Z0Z0Z0Z0\" ); assert_eq! (base32:: decode
(Alphabet::Crockford, \"Z0Z0Z0Z0\" ). unwrap (), vec! [ 0xF8 , 0x3E ,
0x0F , 0x83 , 0xE0 ]); // RFC4648 assert_eq! (base32:: encode
(Alphabet::Rfc4648 { padding: true }, &[ 0xF8 , 0x3E , 0x7F , 0x83 ,
0xE7 ]), \"7A7H7A7H\" ); assert_eq! (base32:: decode (Alphabet::Rfc4648
{ padding: true }, \"7A7H7A7H\" ). unwrap (), vec! [ 0xF8 , 0x3E , 0x7F
, 0x83 , 0xE7 ]); // RFC4648 base32hex assert_eq! (base32:: encode
(Alphabet::Rfc4648Hex { padding: true }, &[ 0xF8 , 0x3E , 0x7F , 0x83 ,
0xE7 ]), \"V0V7V0V7\" ); assert_eq! (base32:: decode
(Alphabet::Rfc4648Hex { padding: true }, \"V0V7V0V7\" ). unwrap (), vec!
[ 0xF8 , 0x3E , 0x7F , 0x83 , 0xE7 ]); // z-base-32
assert_eq!\n(base32:: encode (Alphabet::Z, &[ 0xF8 , 0x3E , 0x7F , 0x83
, 0xE7 ]), \"9y989y98\" ); assert_eq! (base32:: decode (Alphabet::Z,
\"9y989y98\" ). unwrap (), vec! [ 0xF8 , 0x3E , 0x7F , 0x83 , 0xE7 ]);"

]

},

{

"title": "crockford - crates.io: Rust Package Registry",

"url": "https://crates.io/crates/crockford",

"excerpts": [

"Missing: hex base16"

]

},

{

"title": "crockford - Rust - Docs.rs",

"url": "https://docs.rs/crockford",

"excerpts": [

"Missing: hex base16",

"This library is intended to provide an easy way to encode and decode
identifiers (large integers) as Crockford-encoded strings.",

"Use the encode function to encode `u64` values into Crockford
Base32-encoded strings.",

"This `encode_into` method also accepts `&mut String`, if you prefer.",

"Use the decode function to decode Crockford Base32-encoded strings.
This operation can fail;\nif it does, you’ll get a reasonably useful
error instead of a number."

]

},

{

"title": "Hex encoding Rust crate (hex v0.4.3) - Crates.io",

"url": "https://crates.io/crates/hex",

"excerpts": [

"hex v0.4.3",

"Encoding and decoding data into/from hexadecimal representation.",

"No standard library",

"features",

"* std :\nEnabled by default. Add support for Rust's libstd types.",

"* serde :\nDisabled by default. Add support for\nserde de/serializing
library."

]

},

{

"title": "How is a CRC32 checksum calculated?",

"url":
"https://stackoverflow.com/questions/2587766/how-is-a-crc32-checksum-calculated",

"excerpts": [

"The polynomial for CRC32 is: x32 + x26 + x23 + x22 + x16 + x12 + x11 +
x10 + x8 + x7 + x5 + x4 + x2 + x + 1. Wikipedia · CRC calculation.See
more"

]

}

],

"reasoning": "The most directly relevant material describes a Base16
(hex) encoder/decoder that is implemented in a compact, no-std friendly
way and emphasizes fixed-size, high-throughput operation. The base16ct
crate explicitly targets pure-Rust, no-std, with a design choice that
avoids data-dependent branching, which is highly aligned with a tiny,
high-throughput hex encoder. This supports the field value by
highlighting a small, efficiently implemented hex encoder that could be
extended with SIMD paths or kept as a minimal baseline for SIMD-enabled
variants. For Base32 and Crockford, several excerpts describe small,
focused crates: the base32 crate provides multiple RFC4648 variants
(including padding and no_std configurations), Crockford-related crates
present Crockford-specific encoding/decoding utilities, and there are
notes showing examples and API usage. These sources collectively map to
opportunities to craft tiny, high-throughput encoders for both hex and
Crockford-base32, with potential SIMD acceleration or specialized
implementations to maximize throughput while preserving small
footprints. The Hex-focused excerpts (hex crates) corroborate the
interest in compact hex encoders, including discussions of no_std usage
and minimal footprint, which are critical to building a tiny encoding
crate. The hex-related excerpts also discuss the library boundaries and
potential optimizations (e.g., tableless approaches, minimal
dependencies), which are essential when targeting very small code size
alongside performance. The Base32 and Crockford excerpts provide
concrete paths to implement or improve compact encoders, including
no_std support and explicit Crockford usage, which fit the \"high
throughput and SIMD path\" objective when extended with SIMD backends.
Overall, the strongest fit comes from a directly described tiny,
branchless hex encoder and the clearly stated Base32/Crockford lines,
which offer concrete starting points and design considerations for a
small, fast encoding crate. Combining these cues yields a plausible
plan: build a minimal hex encoder (base16) with branchless/bit-twiddling
techniques and an optional SIMD backend, plus a tiny Base32/Crockford
encoder leveraging similar no_std-friendly, low-LoC concepts, and
provide pragmatic performance notes and testability instructions for
rapid verification.",

"confidence": "high"

},

{

"field": "polynomial_approximation_opportunity",

"citations": [

{

"title": "Sollya User's Manual - remez",

"url": "https://www.sollya.org/sollya-2.0/help.php?name=remez",

"excerpts": [

"range is the interval where the function must be approximated",

" a weight function. Default is 1. * quality (optional) is a parameter
that controls the quality of the returned polynomial p, with respect to
the exact minimax p\\*. Default is 1e-5",

"The polynomial is obtained by a convergent iteration called Remez'
algorithm"

]

},

{

"title": "Sollya Help and Related References",

"url": "https://sollya.org/sollya-4.0/help.php",

"excerpts": [

" [remez]() computes an approximation of the function f with respect
to\n the weight function w on the interval range. More precisely, it\n
searches p such that ||p\\*w-f|| is\n (almost) minimal among all p of a
certain f",

"The polynomial is obtained by a convergent iteration called Remez'\n
algorithm (and an extension of this algorithm, due to Stiefel",

"The algorithm computes a sequence p1, ..., pk, ...\n such that ek =
||pk\\*w-f|| converges towards\n the optimal val",

"The optional argument bounds is an interval [satisfying\\_err,
target\\_err]\n with the following behav",

"+ if, during the algorithm, we manage to prove that target\\_err is\n
unreachable, we stop the algorithm returning the last computed\n po",

"+ if, during the algorithm, we obtain a polynomial with an error
smaller\n than satisfying\\_err, we stop the algorithm returning that
polyno",

"+ otherwise we loop until we find an optimal polynomial with the
required\n quality, as us",

"\nUsage:\n------\n\n[remez]()(f, n, range, w, quality, bounds) :
(function, integer, range, function, constant, range) -> function",

"\n[remez]()(f, L, range, w, quality, bounds) : (function, list, range,
function, constant, range) -> function",

"Parameters:\n-----------\n\n* f is the function to be approximated\n* n
is the degree of the polynomial that must approximate f\n* L is a list
of integers or a list of functions and indicates the basis for the
approximation of f\n* range is the interval where the function must be
approximated\n* w (optional) is a weight function. Default is 1. *
quality (optional) is a parameter that controls the quality of the
returned polynomial p, with respect to the exact minimax p\\*. Default
is 1e-"

]

},

{

"title": "Sollya Help: Remez Minimax Polynomial Approximation",

"url": "https://www.sollya.org/sollya-8.0/help.php",

"excerpts": [

"Sollya commands like remez, taylor or rationalapprox sometimes produce
expressions that can be simplified. Constant subexpressions can be
evaluated to ... Library names:",

"Usage:\n------\n\n[remez]()(f, n, range, w, quality, bounds) :
(function, integer, range, function, constant, range) ->
function\n[remez]()(f, L, range, w, quality, bounds) : (function, list,
range, function, constant, range) -> function",

"Parameters:\n-----------\n\n* f is the function to be approximated\n* n
is the degree of the polynomial that must approximate f\n* L is a list
of integers or a list of functions and indicates the basis for the
approximation of f\n* range is the interval where the function must be
approximated\n* w (optional) is a weight function. Default is 1. *
quality (optional) is a parameter that controls the quality of the
returned polynomial p, with respect to the exact minimax p\\*. Default
is 1e-5. * bounds (optional) is a parameter that allows the user to make
the algorithm stop earlier, whenever a given accuracy is reached or a
given accuracy is proved unreachable. Default is [0, +Inf].
Description:\n------------\n\n* [remez]() computes an approximation of
the function f with respect to\n the weight function w on the interval
range. More precisely, it\n searches p such that ||p\\*w-f|| is\n
(almost) minimal among all p of a certain form. The norm is\n the
infinity norm, e.g. ||g|| = max {|g(x)|, x in range}.\n* If w=1 (the
default case), it consists in searching the best\n polynomial
approximation of f with respect to the absolute error. If f=1 and w is
of the form 1/g, it consists in\n searching the best polynomial
approximation of g with respect to the\n relative error. * If n is
given, p is searched among the polynomials with degree not\n greater
than n.\n If L is given and is a list of integers, p is searched as a
linear\n combination of monomials X^k where k belongs to L.\n In the
case when L is a list of integers, it may contain ellipses but\n cannot
be end-elliptic. If L is given and is a list of functions g\\_k, p is
searched as a\n linear combination of the g\\_k. In that case L cannot
contain ellipses. It is the user responsibility to check that the g\\_k
are linearly independent\n over the interval range. Moreover, the
functions w\\*g\\_k must be at least\n twice differentiable over range.
If these conditions are not fulfilled, the\n algorithm might fail or
even silently return a result as if it successfully\n found the minimax,
though the returned p is not optimal. * The polynomial is obtained by a
convergent iteration called Remez'\n algorithm (and an extension of this
algorithm, due to Stiefel). The algorithm computes a sequence p1, ...,
pk, ...\n such that ek = ||pk\\*w-f|| converges towards\n the optimal
value e. The algorithm is stopped when the relative error\n between ek
and e is less than quality.\n ... \nExample 1:\n----------\n\n   > p =
remez(exp(x),5,[0;1]); \n   > degree(p); \n   5 \n   >
dirtyinfnorm(p-exp(x),[0;1]);
\n   1.1295698151096148707171193829266077607222",

"For historical reasons, fpminimax and remez have different syntaxes.
Indeed, the syntax of fpminimax has been designed to be higher level and
closer to ..."

]

},

{

"title": "Musl Musl libc - expf.c (example excerpt and notes)",

"url": "https://git.musl-libc.org/cgit/musl/tree/src/math/expf.c",

"excerpts": [

"/* EXP2F_TABLE_BITS = 5 EXP2F_POLY_ORDER = 3 ULP error: 0.502 (nearest
rounding.) Relative error: 1.69 * 2^-34 in [-ln2/64, ln2/64] (before
rounding.)",

"... [-ln2/64, ln2/64] (before rounding.) Wrong count: 170635 (all
nearest rounding wrong results with fma.) Non-nearest ULP error: 1
(rounded ULP error) ..."

]

},

{

"title": "musl expf.c excerpt",

"url":
"https://git.musl-libc.org/cgit/musl/tree/src/math/expf.c?h=v1.1.18&id=eb03bde2f24582874cb72b56c7811bf51da0c817",

"excerpts": [

"float expf(float x) { \tfloat_t hi, lo, c, xx, y; \tint k, sign;
\tuint32_t hx; \tGET_FLOAT_WORD(hx, x); \tsign = hx >> 31; /* sign bit
of x */ \thx &= 0x7fffffff; /* high word of |x| *",

"/* argument reduction */ \tif (hx > 0x3eb17218) { /* if |x| > 0.5 ln2
*/ \t\tif (hx > 0x3f851592) /* if |x| > 1.5 ln2 */ \t\t\tk = invln2*x +
half[sign]; \t\telse \t\t\tk = 1 - sign - sign; \t\thi = x - k*ln2hi; /*
k*ln2hi is exact here */ \t\tlo = k*ln2lo; \t\tx = hi - lo; \t} else if
(hx > 0x39000000) { /* |x| > 2**-14 */ \t\tk = 0; \t\thi = x; \t\tlo =
0; \t} else { \t\t/* raise inexact */ \t\tFORCE_EVAL(0x1p127f + x);
\t\treturn 1 + x; \t}"

]

},

{

"title": "warning - Sollya User's Manual",

"url": "https://www.sollya.org/sollya-2.9/help.php",

"excerpts": [

"remez computes the minimax of a function on an interval. Usage:
remez(f, n, range, w, quality) : (function, integer, range, function,
constant) -> function ..."

]

},

{

"title": "Cephes double precision special functions suite",

"url": "https://www.netlib.org/cephes/doubldoc.html",

"excerpts": [

"Oct 5, 2014 — Cephes Mathematical Library. Source code archives.
Documentation for single precision library. Documentation for double
precision library."

]

},

{

"title": "Using MATLAB to find Minimax Polynomial Approximation of ...",

"url":
"https://stackoverflow.com/questions/9301380/using-matlab-to-find-minimax-polynomial-approximation-of-trigonometric-functions",

"excerpts": [

"I am trying to find the minimax polynomial approximation for sine and
cosine using the remez exchange algorithm in MATLAB. The need precision
out to 23 bits."

]

},

{

"title": "Efficient computation of the exponential function (in
Cephes)",

"url":
"https://math.stackexchange.com/questions/4382370/efficient-computation-of-the-exponential-function-in-cephes",

"excerpts": [

"Feb 14, 2022 — I'm trying to understand how computers calculate
(approximate) the exponential function. I'm reading the code of the
Cephes library, specifically this code."

]

},

{

"title": "micromath - crates.io: Rust Package Registry",

"url": "https://crates.io/crates/micromath/0.5.1",

"excerpts": [

"Embedded-friendly math library featuring fast floating point
approximations (with small code size) for common arithmetic operations,
trigonometry, ..."

]

},

{

"title": "exp.rs source code [crates/micromath/src/float/ ...",

"url":
"https://codebrowser.dev/slint/crates/micromath/src/float/exp.rs.html",

"excerpts": [

"Source code of exp.rs micromath 2.1.0 on KDAB Codebrowser."

]

},

{

"title": "musl - musl",

"url":
"https://git.musl-libc.org/cgit/musl/diff/?id=ab1772c597ba8fe0c26400256b12d7a4df23880e",

"excerpts": [

"* Domain [-0.34568, 0.34568], range ~[-4.278e-9, 4.447e-9]:. *
|x*(exp(x)+1)/(exp(x)-1) - p(x)| < 2**-27.74. */. -P1 = 1.6666625440e-1,
/* 0xaaaa8f.0p-26 ..."

]

},

{

"title": "Rounding the coefficients of a minimax polynomial",

"url":
"https://discourse.julialang.org/t/rounding-the-coefficients-of-a-minimax-polynomial/92873",

"excerpts": [

"Jan 12, 2023 — If you need the “exact” minimax polynomial, you may want
to build a Remez algorithm on top of one of these packages. My package
actually ..."

]

},

{

"title": "The eight useful polynomial approximations of `sinf(3)' - Paul
Khuong",

"url":
"https://www.pvk.ca/Blog/2012/10/07/the-eight-useful-polynomial-approximations-of-sinf-3/",

"excerpts": [

"These methods exploit real analysis results to reduce the problem to
computing minimax polynomials over very few points (one per coefficient,
..."

]

},

{

"title": "Understanding f32 Floating Point - by Carl Maxwell",

"url":
"https://medium.com/@Carl_Maxwell/understanding-f32-floating-point-9d7e3604ab97",

"excerpts": [

"There are two popular types of floating point numbers, the f32 (which
uses 32 bits of memory) and the f64 (which uses 64 bits of memory)."

]

},

{

"title": "sin.c\\math\\src",

"url": "https://git.musl-libc.org/cgit/musl/tree/src/math/sin.c",

"excerpts": [

"argument reduction routine * * Method. * Let S,C and T denote the sin,
cos and tan respectively on * [-PI/4, +PI/4]. Reduce the argument x to
y1+y2 = x-k*pi/2 ..."

]

},

{

"title": "src/math/e_expf.c - Musl - ICube forge",

"url":
"https://forge.icube.unistra.fr/icps/musl/-/blob/fc27b96c7d9b2c82679508a57ac998d773f14f08/src/math/e_expf.c",

"excerpts": [

"Ouvrir dans Web EDI . Modifiez rapidement et facilement plusieurs
fichiers de votre projet. Modifier le fichier unique Modifiez ce fichier
..."

]

},

{

"title": "fast_log - crates.io: Rust Package Registry",

"url": "https://crates.io/crates/fast_log",

"excerpts": [

"A log implementation for extreme speed, using Crossbeam/channel ,once
Batch write logs,fast log date, Appender architecture, appender per
thread."

]

},

{

"title": "r/rust on Reddit: My new crate: fast-logger - An attempt at
the fastest ...",

"url":
"https://www.reddit.com/r/rust/comments/bvbbjb/my_new_crate_fastlogger_an_attempt_at_the_fastest/",

"excerpts": [

"The goal of this crate is to be the absolute fastest logger in terms of
caller latency. That means the caller should spend as little time inside
the crate's ..."

]

},

{

"title": "sollya-1.1.pdf",

"url": "https://www.sollya.org/releases/sollya-1.1/sollya-1.1.pdf",

"excerpts": [

"by S Chevillard · 2008 · Cited by 10 — Note that fpminimax internally
computes a minimax polynomial (using the same algorithm as remez
command). ... exp(x) * log(sin(x))). Example 6: 89. Page 90. > 2^3 ..."

]

},

{

"title": "f32 - Rust",

"url": "https://rust.docs.kernel.org/core/primitive.f32.html",

"excerpts": [

"Approximate number of significant digits in base 10. This is the
maximum x such that any decimal number with x significant digits can be
converted to f32 and ..."

]

},

{

"title": "Implementing cosine in C from scratch",

"url": "https://austinhenley.com/blog/cosine.html",

"excerpts": [

"Jul 19, 2020 — The first optimization I tried was range reduction. The
bigger the input value, the less accurate this method is. Since cosine
repeats every 2pi ..."

]

},

{

"title": "Cephes Library Documentation",

"url": "https://www.netlib.org/cephes/",

"excerpts": [

"Documentation of cephes 128-bit precision special functions. file
128bit.tgz for arithmetic and math functions for 128-bit reals. size
252kB file\tieee.tgz",

"file cmath.tgz for double precision elementary functions",

"file remes.tgz for minimax rational approximation",

"file linalg.tgz for C translations of eigens, lmdif",

"file eval.tgz for mconf.h, mtherr.c, polevl.c, chbevl.c used by other
cephes functions",

"for\t32-bit floating point versions of cephes functions"

]

},

{

"title": "fast-math crate documentation",

"url": "https://docs.rs/fast-math",

"excerpts": [

"Fast, approximate versions of mathematical functions."

]

},

{

"title": "Fast-Math crate (Rust)",

"url": "https://crates.io/crates/fast-math",

"excerpts": [

"Fast, approximate versions of mathematical functions.",

"Logarithms: `log2`,"

]

}

],

"reasoning": "The field value describes a plan for a Rust microcrate
that uses a two-stage approach: first reduce arguments to a small
interval, then apply a minimax polynomial to approximate exp/log/sin
with tight error bounds, generated via Sollya. The most relevant sources
explicitly discuss how to generate minimax polynomials with Sollya and
how to structure the approximation workflow for fast math functions.
They describe the minimax methodology (via remez/fpminimax), the
two-stage reduction paradigm, and practical notes on polynomial
generation, interval ranges, and error targets—all of which directly
support the proposed crate's approach. The material that most strongly
supports the field value includes direct references to Sollya's minimax
workflow, the remez/fpminimax generators, and the typical two-stage
strategy (argument reduction to a small primary interval followed by a
minimax polynomial evaluation, often via Horner's method). Additional
documents provide context and examples for implementing exp/log/sin-like
functions with minimax polynomials and for using Sollya to derive these
polynomials, which reinforce the feasibility and design pattern of a
<300 LOC, no_std/wasm-friendly Rust crate implementing such
approximations. The collection also notes the trade-offs between
accuracy (1–2 ULP) and speed relative to libm, which aligns with the
proposed performance-leaning crate goals. Overall, the excerpts
collectively substantiate the viability and methodology for building
this minimax-based math crate in Rust with no_std/wasm compatibility,
and provide concrete procedural anchors (tools, intervals, Horner
evaluation) for implementing the plan.",

"confidence": "high"

},

{

"field": "specialized_float_formatting_opportunity",

"citations": [

{

"title": "base/ryu/LICENSE.md - libs / julia",

"url":
"https://gitlab.iag.uni-stuttgart.de/libs/julia/-/blob/b5d0b9056969d0512470d2fff46e981032361fcc/base/ryu/LICENSE.md",

"excerpts": [

"... github.com/ulfjack/ryu repository, which allows the use of the
Boost software license, included below. Boost Software License - Version
1.0 ..."

]

},

{

"title": "Ryū: fast float-to-string conversion",

"url":
"https://www.researchgate.net/publication/329410883_Ryu_fast_float-to-string_conversion",

"excerpts": [

"Ryū, a new routine to convert binary floating point numbers to their
decimal representations using only fixed-size integer operations, and
prove its correctness.",

"Ryū is simpler and approximately three times faster than the previously
fastest implementation.",

"Abstract",

"We present Ryū, a new routine to convert binary floating point numbers
to their decimal representations using only fixed-size integer
operations, and prove its correctness.",

"We present Ryū, a new routine to convert binary floating point numbers
to their decimal representations using only fixed-size integer
operations, and prove its correctness.",

"ACM SIGPLAN Notices"

]

},

{

"title": "ryu - Rust",

"url": "https://docs.rs/ryu",

"excerpts": [

"Pure Rust implementation of Ryū, an algorithm to quickly convert
floating point numbers to decimal strings."

]

},

{

"title": "ryu Rust implementation (lib.rs and docs) - source excerpts",

"url":
"https://avro.apache.org/docs/++version++/api/rust/src/ryu/lib.rs.html",

"excerpts": [

"Performance (lower is better)",

"The benchmark shows Ryū approximately 2-5x faster than the standard
library\n68//! across a range of f32 and f64 inputs. Measurements are in
nanoseconds per\n69//! iteration; smaller ",

"This library tends to produce more human-readable output than the
standard\n74//! library's to\\_string, which never uses scientific
notat",

"#! [no_std]",

"This Rust implementation is a line-by-line port of Ulf Adams'
implementation\n17//! in C, [https://github.com/ulfjack/ryu][upst"

]

},

{

"title": "Reference implementation of Dragonbox in C",

"url": "https://gitflic.ru/project/vault/dragonbox",

"excerpts": [

"Dragonbox generates a pair of integers from a floating-point number:
the decimal significand and the decimal exponent of the input
floating-point number. These ..."

]

},

{

"title": "Dragonbox: A New Floating-Point Binary-to-Decimal ...",

"url": "https://fmt.dev/papers/Dragonbox.pdf",

"excerpts": [

"Feb 8, 2022 — C++ implementation of Schubfach [7], for the task of pro-
ducing a decimal string representation of a given floating- point
number. The ..."

]

},

{

"title": "Dragonbox - jk-jeon/dragonbox",

"url": "https://github.com/jk-jeon/dragonbox",

"excerpts": [

"This library is a reference implementation of Dragonbox in C++.
Dragonbox is a float-to-string conversion algorithm based on a beautiful
algorithm Schubfach , developed by Raffaello Giulietti in 2017-2018.
Dragonbox is further inspired by Grisu and Grisu-Exact . Introduction",

"There are two additional files needed for
that:\ninclude/dragonbox/dragonbox_to_chars.h
and\nsource/dragonbox_to_chars.cpp .",

"The header file\ninclude/dragonbox/dragonbox.h includes everything
needed for this (it is header-only).",

"Dragonbox provides several policies that the user can select.",

"Dragonbox is intended for float-to-string conversion routines, the
actual string generation is not officially a part of the algorithm."

]

},

{

"title": "FP crate: Dragonbox and Ryu implementations",

"url": "https://github.com/jk-jeon/fp",

"excerpts": [

"Shortest-roundtrip binary-to-decimal conversion. fp implements
Dragonbox algorithm. fp 's implementation is almost identical to the
reference implementation ",

"Here is the list of algorithms that `fp` supports. Shortest-roundtrip
binary-to-decimal conversion",

". fp implements Dragonbox algorithm.",

"The performance is better or on par with other contemporary algorithms;
see [benchmark](https://github.com/jk-jeon/fp).",

"fp` implements Ulf Adams'
[Ryu-printf](https://dl.acm.org/doi/pdf/10.1145/3360595) algorithm"

]

}

],

"reasoning": "The targeted fine-grained field seeks a tiny, no_std,
WASM-friendly Rust crate (<300 LoC) that converts f32 to the
shortest-roundtrip decimal string, using state-of-the-art methods like
Ryū or Dragonbox, with exhaustive testing. Several excerpts directly
address this design space. The most relevant excerpts describe Ryū in
Rust, including its pure-Rust implementation and claims of being a fast,
compact approach suitable for no_std contexts and no-alloc usage. They
also note that Ryū provides fast, human-readable output and competitive
performance relative to standard libraries, which informs the
feasibility and correctness expectations for a small crate: a
line-by-line port of Ryū exists, and the project emphasizes no_std
compatibility and no dependency footprint. This aligns with the
constraint to build a minimal no_std, WASM-friendly crate that can still
achieve short, correctly rounded outputs for f32. Additional excerpts
discuss Dragonbox in Rust as a reference approach for achieving
shortest-roundtrip decimal representations, including a Dragonbox-based
Rust implementation and related performance considerations. These
sources provide concrete algorithmic options that a small crate could
implement, either by adopting a minimal, no_std variant of Ryū or by
using Dragonbox-inspired methods, while keeping the codebase small. The
excerpts also discuss broader testing and correctness considerations,
including references to exhaustive or highly rigorous testing approaches
for f32-based formatting and cross-checks against more established
implementations, which supports the plan to include a robust
verification approach as part of the tiny crate's design. In short, the
cited material demonstrates that compact, high-performance f32-to-string
formatting implementations exist (Ryū, Dragonbox in Rust) and that a
small, no_std, WASM-ready crate is feasible with careful design choices
and rigorous testing. Focused passages explicitly describe Ryū's Rust
implementations and its no_std characteristics, and Dragonbox as a
compact, high-performance alternative, which together provide the
strongest basis for recommending a minimal crate that targets f32
shortest-roundtrip formatting.",

"confidence": "high"

},

{

"field": "key_opportunity_areas",

"citations": [

{

"title": "gnzlbg/bitintr: Portable Bitwise Manipulation Intrinsics",

"url": "https://github.com/gnzlbg/bitintr",

"excerpts": [

"This `#![no_std]` library exposes *safe* and *portable* low-level bit
manipulation\ninstruction set architectures."

]

},

{

"title": "Bitintr 0.3.0 Documentation and Repository",

"url": "http://docs.rs/bitintr/latest/bitintr",

"excerpts": [

"This `#![no_std]` library exposes *safe* and *portable* low-level bit
manipulation\ninstruction set architectures.",

"The intrinsics are exposed via traits named after their CPU
instruction.",

"The following ISAs are implemented:\n\n* x86 (`bitintr::x86`):\n\n +
[`ABM`](https://en.wikipedia.org/wiki/Bit_Manipulation_Instruction_Sets.28Advanced_Bit_Manipulation.29):
Advanced Bit Manipulation instructions
([`bitintr::x86::abm`](https://gnzlbg.github.io/bitintr/bitintr/x86/abm/index.html)).\n
+
[`TBM`](https://en.wikipedia.org/wiki/Bit_Manipulation_Instruction_Sets.28Trailing_Bit_Manipulation.29):
Trailing Bit Manipulation instructions
([`bitintr::x86::tbm`](https://gnzlbg.github.io/bitintr/bitintr/x86/tbm/index.html)).\n
+
[`BMI`](https://en.wikipedia.org/wiki/Bit_Manipulation_Instruction_Sets.28Bit_Manipulation_Instruction_Set_1.29):
Bit Manipulation Instruction Set 1.0
([`bitintr::x86::bmi`](https://gnzlbg.github.io/bitintr/bitintr/x86/bmi/index.html)).\n
+
[`BMI2`](https://en.wikipedia.org/wiki/Bit_Manipulation_Instruction_Sets.28Bit_Manipulation_Instruction_Set_2.29):
Bit Manipulation Instruction Set 2.0
([`bitintr::x86::bmi2`](https://gnzlbg.github.io/bitintr/bitintr/x86/bmi2/index.html)).\n*
ARM (`bitintr::arm`):\n\n +
[`ARMv5`](http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0100i/index.html):
[`bitintr::arm::v5`](https://gnzlbg.github.io/bitintr/bitintr/arm/v5/index.html).\n
+
[`ARMv6`](http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0419c/index.html):
[`bitintr::arm::v6`](https://gnzlbg.github.io/bitintr/bitintr/arm/v6/index.html).\n
+
[`ARMv7`](http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0403e.b/index.html):
[`bitintr::arm::v7`](https://gnzlbg.github.io/bitintr/bitintr/arm/v7/index.html).\n
+
[`ARMv8`](http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0487a.k_10775/index.html):
[`bitintr::arm::v8`](https://gnzlbg.github.io/bitintr/bitintr/arm/v8/index.html).",

"The Minimum Supported Rust Version is 1.36.0.",

"bitintr 0.3.0 - Docs.rs",

"bitintr-0.3.0 doesn't have any documentation."

]

},

{

"title": "bitintr 0.3.0 - Docs.rs",

"url": "http://docs.rs/bitintr/0.3.0/bitintr",

"excerpts": [

"This `#![no_std]` library exposes *safe* and *portable* low-level bit
manipulation\ninstruction set architectures.",

"bitintr-0.3.0 doesn't have any documentation."

]

},

{

"title": "Bitintr crate - Rust crates.io",

"url": "https://crates.io/crates/bitintr",

"excerpts": [

"The intrinsics are exposed via traits named after their CPU
instruction."

]

},

{

"title": "Bit-twiddling crates and references in the provided source",

"url": "https://docs.rs/tinybitset",

"excerpts": [

"One unique feature of this crate is that it uses const generics to have
a single generic bitset type whose size and underlying storage type can
be chosen with ... tinybitset 0.0.2\n ",

"One unique feature of this crate is that it uses const generics to have
a single generic bitset type whose size and underlying storage type can
be chosen with ... tinybitset 0.0.2\n "

]

},

{

"title": "Bit Twiddling Hacks",

"url": "https://graphics.stanford.edu/~seander/bithacks.html",

"excerpts": [

"Bit Twiddling Hacks",

"\nBy Sean Eron Anderson seander@cs.stanford.edu Individually, the code
snippets here are in the public domain (unless otherwise noted) — feel
free to use them however you please. The aggregate collection and
descriptions are © 1997-2005 Sean Eron Anderson. The code and
descriptions are distributed in the hope that they will be useful,"

]

},

{

"title": "Fiftyfive bytes of WebAssembly - Stefan Fehrenbach",

"url":
"https://www.stefan-fehrenbach.net/blog/2018-10-26-fiftyfive-bytes-of-webassembly/index.html",

"excerpts": [

"It uses the popCount function to count the number of 1-bits in the
binary representation of a number to save space, it's really cool."

]

},

{

"title": "substrate-fixed",

"url": "https://crates.io/crates/substrate-fixed",

"excerpts": [

"Fixed-point numbers for substrate",

"64,079 Downloads all time",

"Repository\ngithub.com/encointer/substrate-fixed"

]

},

{

"title": "Crate mat - Rust",

"url": "https://docs.rs/mat",

"excerpts": [

"Statically sized matrices for no_std applications. This library
provides support for creating and performing mathematical operations on
statically sized ..."

]

},

{

"title": "DMat3 in glam::f64 - Rust - Docs.rs",

"url": "https://docs.rs/glam/latest/glam/f64/struct.DMat3.html",

"excerpts": [

"Creates a 3x3 matrix from a [f64; 9] array stored in column major
order. If your data is stored in row major you will need to transpose
the returned matrix."

]

},

{

"title": "Mini Matrix Library (crates.io) - crate description and docs",

"url": "https://crates.io/crates/mini-matrix",

"excerpts": [

" * Vector and Matrix Operations"

]

}

],

"reasoning": "The most directly relevant excerpts demonstrate concrete,
concrete examples of micro-crates designed for no_std or wasm contexts
and with minimal dependencies. For instance, the bitintr entries
emphasize a portable, no_std library exposing low-level bit manipulation
intrinsics and minimum rustc version, which clearly maps to a tiny,
focused crate that could be kept under 300 LOC while delivering high
utility across platforms. Similarly, tinybitset is described as a small,
fixed-size bitset using const generics, offering a compact primitive
that likely fits well under 300 LOC while serving a broad use-case in
embedded or systems programming. The substrate-fixed entries explicitly
describe fixed-point types with concise APIs and no-std compatibility,
aligning with the fixed-point niche highlighted in the field value as a
high-potential area for small crates. The substrate-fixed excerpt also
notes licensing and repository metadata, reinforcing the practical
viability of these micro-libs in real-world ecosystems. WASM-focused
micro-crates are implied in the 55 bytes of WebAssembly reference,
suggesting opportunities for tiny, wasm-friendly utilities. The excerpts
about no_std and portability (bitintr) and the fixed-point ecosystem
(substrate-fixed) directly support the core claim that micro-crates
serving embedded/no_std/wasm contexts have significant PMF when kept
lean and dependency-light. The other excerpts about low-footprint,
minimal-licensing entries (tinybitset) and the explicit focus on
no_std/Rust in various crates further support the outlined opportunity
space. In sum, the strongest support comes from concrete examples of
small, no_std/wasm-oriented crates (bitintr, tinybitset,
substrate-fixed), followed by WASM/no_std hints (55 bytes WASM
reference) and fixed-point/minimal math crates, which collectively
substantiate the field value's thesis about micro-crates and lean,
highly-reusable primitives as a key opportunity category. The remaining
excerpts provide broader context about minimal dependencies and
cross-cutting themes that reinforce the proposed strategic directions
but are less directly tied to a single field claim.",

"confidence": "high"

},

{

"field": "c_cpp_porting_candidates",

"citations": [

{

"title": "rand_pcg - Rust",

"url": "https://docs.rs/rand_pcg",

"excerpts": [

"The `rand_pcg` crate provides a native Rust implementation of PCG
random number generators, including Pcg32, Pcg64, and Pcg64Mcg.",

"A native Rust implementation of a small selection of PCG generators.
The primary goal of this crate is simple, minimal, well-tested code."

]

},

{

"title": "rand_pcg - PCG generators (Rust)",

"url": "https://rust-random.github.io/rand/rand_pcg/",

"excerpts": [

"The PCG random number generators. This is a native Rust implementation
of a small selection of [PCG generators](https://www.pcg-random.org/).",

"This crate provides: Pcg32 aka Lcg64Xsh32 , officially known as pcg32 ,
a general purpose RNG. This is a good choice on both 32-bit and 64-bit
CPUs (for 32 ...",

"A native Rust implementation of a small selection of PCG generators.
The primary goal of this crate is simple, minimal, well-tested code."

]

},

{

"title": "PCG RNG ecosystem (pcg_rand and related crates)",

"url": "https://crates.io/crates/pcg_rand",

"excerpts": [

"PCG stands for Permuted Congruential generators. They are a simple
family of\nrandom number generators which use the much denounced Linear
Congruential\nGenerator as a base. To overcome the well known
limitations of the LCG Generator\nthe PCG family utilizes permutation
functions to permute the output.",

"This library currently provides 32 and 64 bit generators. It provides
the major \"stream\" types, including the unique stream which is
determined\nby their current location in memory.",

"pcg\\_rand - crates.io: Rust Package Registr",

"An implementation of the PCG family of random number generators in pure
Rust"

]

},

{

"title": "morton-nd/morton-nd: A header-only compile-time ...",

"url": "https://github.com/morton-nd/morton-nd",

"excerpts": [

"A header-only Morton encode/decode library (C++14) capable of encoding
from and decoding to N-dimensional space. All algorithms are generated
at compile-time."

]

}

],

"reasoning": "- The excerpts describing PCG family and PCG generators
are highly relevant to the SplitMix/RNG candidate in the fine-grained
field value. They discuss PCG variants (Pcg32, Pcg64, etc.),
portability, no_std status, and practical implementation details, which
directly informs a small Rust crate focused on PCG RNGs and their
variants. For example, content describing PCG as a family of simple,
fast, and well-tested generators (with references to specific
implementations and documentation) directly supports porting and
implementing PCG-based utilities in under-300 lines. This aligns with
the field's emphasis on compact, high-value RNG primitives that could be
ported as tiny crates.",

"confidence": "high"

},

{

"field": "opportunity_summary_table",

"citations": [

{

"title": "bitintr - Rust",

"url": "https://gnzlbg.github.io/bitintr/",

"excerpts": [

"bitintr offers portable bit manipulation intrinsics (@github,
@crates.io). The intrinsics are named after their CPU instruction and
organized in modules ..."

]

},

{

"title": "gnzlbg/bitintr: Portable Bitwise Manipulation Intrinsics",

"url": "https://github.com/gnzlbg/bitintr",

"excerpts": [

"This #![no_std] library exposes safe and portable low-level bit
manipulation instruction set architectures. The Minimum Supported Rust
Version is 1.36.0.",

"Portable Bitwise Manipulation Intrinsics",

"Portable Bitwise Manipulation Intrinsics",

"The intrinsics are exposed via traits named after their CPU
instruction. These\ntraits are implemented for all integer types
*except* `u128/i128`.",

"\n * * * * ",

"\n * * * * ",

" +
[`ABM`](https://en.wikipedia.org/wiki/Bit_Manipulation_Instruction_Sets.28Advanced_Bit_Manipulation.29):
Advanced Bit Manipulation instructions
([`bitintr::x86::abm`](https://gnzlbg.github.io/bitintr/bitintr/x86/abm/index.html)).",

" +
[`TBM`](https://en.wikipedia.org/wiki/Bit_Manipulation_Instruction_Sets.28Trailing_Bit_Manipulation.29):
Trailing Bit Manipulation instructions
([`bitintr::x86::tbm`](https://gnzlbg.github.io/bitintr/bitintr/x86/tbm/index.html)).",

"Licensed under the [MIT
license](https://github.com/gnzlbg/bitintr/blob/master/license.md).",

"This `#![no_std]` library exposes *safe* and *portable* low-level bit
manipulation\ninstruction set architectures."

]

},

{

"title": "bitintr 0.3.0 - Docs.rs",

"url": "http://docs.rs/bitintr/0.3.0/bitintr",

"excerpts": [

"The intrinsics are exposed via traits named after their CPU
instruction. These\ntraits are implemented for all integer types
*except* `u128/i128`.",

"The intrinsics are exposed via traits named after their CPU
instruction. These\ntraits are implemented for all integer types
*except* `u128/i128`.",

" +
[`ABM`](https://en.wikipedia.org/wiki/Bit_Manipulation_Instruction_Sets.28Advanced_Bit_Manipulation.29):
Advanced Bit Manipulation instructions
([`bitintr::x86::abm`](https://gnzlbg.github.io/bitintr/bitintr/x86/abm/index.html)).",

"Licensed under the [MIT
license](https://github.com/gnzlbg/bitintr/blob/master/license.md).",

"This `#![no_std]` library exposes *safe* and *portable* low-level bit
manipulation\ninstruction set architectures."

]

},

{

"title": "Bitintr crate - Rust crates.io",

"url": "https://crates.io/crates/bitintr",

"excerpts": [

"These traits are implemented for all integer types except u128/i128 .",

"28/i128 . The following ISAs are implemented:\n * x86 (\nbitintr::x86
):\n * ABM : Advanced Bit Manipulation instructions (\nbitintr::x86::abm
). * TBM : Trailing Bit Manipulation instructions (\nbitintr::x86::tbm
). * BMI : Bit Manipulation Instruction Set 1.0 (\nbitintr::x86::bmi ).
* BMI2 : Bit Manipulation Instruction Set 2.0 (\nbitintr::x86::bmi2 ). *
ARM (\nbitintr::arm ):\n * ARMv5 :\nbitintr::arm::v5 . * ARMv6
:\nbitintr::arm::v6 . * ARMv7 :\nbitintr::arm::v7 . * ARMv8
:\nbitintr::arm::v8 . The actual code generated depends on the integer
types involved and the features\nsupported by the target architecture.",

"This `#![no_std]` library exposes *safe* and *portable* low-level bit
manipulation\ninstruction set architectures. The Minimum Supported Rust
Version is 1.36.0.",

"The intrinsics are exposed via traits named after their CPU
instruction. These traits are implemented for all integer types except
u128/i128 ",

"#! [no_std] library exposes safe and portable low-level bit
manipulation\ninstruction set architectures.",

"Licensed under the [MIT
license](https://github.com/gnzlbg/bitintr/blob/master/license.md).",

"The intrinsics are exposed via traits named after their CPU
instruction."

]

},

{

"title": "Bit-twiddling crates and references in the provided source",

"url": "https://docs.rs/tinybitset",

"excerpts": [

"One unique feature of this crate is that it uses const generics to have
a single generic bitset type whose size and underlying storage type can
be chosen with ... tinybitset 0.0.2\n ",

"One unique feature of this crate is that it uses const generics to have
a single generic bitset type whose size and underlying storage type can
be chosen with ... tinybitset 0.0.2\n "

]

},

{

"title": "Bit Twiddling Hacks",

"url": "https://graphics.stanford.edu/~seander/bithacks.html",

"excerpts": [

"Bit Twiddling Hacks",

"\nBy Sean Eron Anderson seander@cs.stanford.edu Individually, the code
snippets here are in the public domain (unless otherwise noted) — feel
free to use them however you please. The aggregate collection and
descriptions are © 1997-2005 Sean Eron Anderson. The code and
descriptions are distributed in the hope that they will be useful,",

"The code and descriptions are distributed in the hope that they will be
useful,\nbut WITHOUT ANY WARRANTY and without even the implied warranty
of\nmerchantability or fitness for a particular purpose.",

"Bit Twiddling Hacks. By Sean Eron Anderson seander@cs.stanford.edu.
Individually, the code snippets here are in the public domain (unless
otherwise noted) ... Bit Twiddling Hack",

"As of May 5, 2005, all the code has been tested thoroughly. Thousands
of\npeople have read it.",

"n and\ncountbetween on April 10, 2005. Compute the lexicographically
next bit permutation Suppose we have a pattern of N bits set to 1 in an
integer and we want the next permutation of N 1 bits in a
lexicographical sense. For example, if N is 3 and the bit pattern is
00010011, the next patterns would be 00010101, 00010110,
00011001,00011010, 00011100, 00100011, and so forth. The following is a
fast way to compute the next permutation. unsigned int v; // current
permutation of bits unsigned int w;",

"unsigned int t = v | (v - 1); // t gets v's least significant 0 bits
set to 1\n// Next set to 1 the most significant bit to change, // set to
0 the least significant ones, and add the necessary 1 bits.",

"What he hasn't tested, I have checked against all\npossible inputs on a
32-bit machine.",

"int y; int r; // the result goes here r = y ^ ((x ^ y) & -(x < y)); //
min(x, y)",

"To find the maximum, use:\nr = x ^ ((x ^ y) & -(x < y)); // max(x, y)",

"Quick and dirty versions: If you know that INT_MIN <= x - y <=
INT_MAX,\nthen you can use the following, which are faster because (x -
y) only needs to be evaluated once. r = y + ((x - y) & ((x - y) >>
(sizeof(int) * CHAR_BIT - 1))); // min(x, y)",

"r = x - ((x - y) & ((x - y) >> (sizeof(int) * CHAR_BIT - 1))); //
max(x, y) Note that the 1989 ANSI C specification doesn't specify the
result of signed right-shift, so these aren't portable.",

"r = x ^ ((x ^ y) & -(x < y)); // max(x, y)",

"The naive approach requires one iteration per bit, until no more bits
are set. So on a 32-bit word with only the high set, it will go through
32 iterations. Compute the minimum (min) or maximum (max) of two
integers without branching",

"r = y + ((x - y) & ((x - y) >> (sizeof(int) * CHAR_BIT - 1))); //
min(x, y)",

"Compute the minimum (min) or maximum (max) of two integers without
branching\nint x; // we want to find the minimum of x and y\nint y; int
r; // the result goes here r = y ^ ((x ^ y) & -(x < y)); // min(x, y) On
some rare machines where branching is very expensive and no
condition\nmove instructions exist, the above expression\nmight be
faster than the obvious approach, r = (x < y) ? x : y, even though it
involves two more instructions. (Typically, the obvious approach is
best, though.) It works because if x < y, then -(x < y) will be all
ones, so r = y ^ (x ^ y) & ~0 = y ^ x ^ y = x. Otherwise, if x >= y,
then -(x < y) will be all zeros, so r = y ^ ((x ^ y) & 0) = y. On some
machines, evaluating (x < y) as 0 or 1 requires a branch instruction, so
there may be n",

"It works because if x < y, then -(x < y) will be all ones, so r = y ^
(x ^ y) & ~0 = y ^ x ^ y = x. Otherwise, if x >= y, then -(x < y) will
be all zeros, so r = y ^ ((x ^ y) & 0) = y.",

"Bit Twiddling Hacks. By Sean Eron Anderson",

"r = y ^ ((x ^ y) & -(x < y)); // min(x, y)",

"The method first shifts and XORs the eight nibbles of the 32-bit value
together, leaving the result in the lowest nibble of v. Next, the binary
number 0110 ..."

]

},

{

"title": "has_fast_pdep crate page",

"url": "https://crates.io/crates/has_fast_pdep",

"excerpts": [

"A single-function, `no-std` library that returns `true` if the current
CPU implements PDEP and PEXT with fast, non-microcoded hardware.",

"Rationale\n---------\n\nZen, Zen+, Zen 2, and Hygon Dhyana CPUs
implement PDEP and PEXT using microcode in a way that makes them slower
than well-optimized, non-intrinsic fallbacks. In performance-critical
code, checking for BMI2 support isn't enough—you could end up hurting
performance on said CPUs where these instructions exist but are slow.
This crate helps you avoid that by detecting speed, not just support.",

"has_fast_pdep = \"0.1\"",

"The result of the hardware check is determined once at runtime. After
the initial check, all future\ncalls to `has_fast_pdep` becomes a simple
`true` or `false` with zero branching or logic. On x86 targets, CPUID is
used directly without probing for its existence. This is intentional.",

"You can view the documentation on docs.rs
[here](https://docs.rs/has_fast_pdep).",

"Rationale\n---------\n\nZen, Zen+, Zen 2, and Hygon Dhyana CPUs
implement PDEP and PEXT using microcode in a way that makes them slower
than well-optimized, non-intrinsic fallbacks. In performance-critical
code, checking for BMI2 support isn't enough—you could end up hurting
performance on said CPUs where these instructions exist but are slow.
This crate helps you avoid that by detecting speed, not just support",

"Implementation Details\n----------------------\n\nThe result of the
hardware check is determined once at runtime. After the initial check,
all future\ncalls to `has_fast_pdep` becomes a simple `true` or `false`
with zero branching or logic.",

"pkg:cargo/has\\_fast\\_pdep@0.1.3",

"Detect fast hardware support for PDEP/PEXT.",

"3 months ago"

]

},

{

"title": "Bitintr 0.3.0 Documentation and Repository",

"url": "http://docs.rs/bitintr/latest/bitintr",

"excerpts": [

"This `#![no_std]` library exposes *safe* and *portable* low-level bit
manipulation\ninstruction set architectures.",

"The intrinsics are exposed via traits named after their CPU
instruction."

]

}

],

"reasoning": "The most directly relevant material describes portable,
no_std, low-dependency bit manipulation infrastructure and ornamented
intrinsics coverage, which underpin a Modern, Portable Bit-Twiddling
Microcrate. Content that explains bit manipulation intrinsics, the
architecture coverage (x86 BMI, TBM, BMI2; ARM variants), and the
safe/no_std presentation supports the need for a compact crate that
exposes a broad but minimal interface for bit-level operations across
platforms. Quoting passages that characterize portable bit manipulation
intrinsics and the no_std design reinforces the case that a small,
interoperable crate can fill a gap where existing crates are larger,
less portable, or less safe for embedded or WASM targets. Additionally,
references to bit-twiddling hacks and classic bit manipulation
techniques establish a well-documented foundation for implementing a
minimal, high-utility crate that provides safe wrappers around low-level
CPU instructions, without requiring heavy dependencies. This aligns with
the proposed opportunity of a digital, portable bit-twiddling microcrate
that exposes a safe API for PDEP/PEXT-like functionality and Morton-code
related utilities, especially in environments where WASM or no_std is
essential. Several excerpts explicitly convey the scope and nature of
portable intrinsic sets, the no_std guarantee, and the breadth of
supported ISAs, which are essential design constraints for the
microcrate. By citing these excerpts, we connect the opportunity to
concrete, historically grounded references for bit manipulation
techniques and portable instruction coverage that the microcrate would
standardize and wrap safely for Rust developers. \n\nThe other
opportunties in the table (PCG/Xoshiro RNGs, Ziggurat samplers, small
fixed-point/math crates, tiny matrix/graph utilities, portable SIMD
micro-helpers, and primitive CPU feature detection) map onto excerpts
that discuss growth areas in minimalistic RNG implementations,
Ziggurat-based sampling, fixed-point arithmetic in constrained
environments, compact matrix libraries, and SIMD portability concerns.
Excerpts mentioning PCG/XXHash-like RNG ecosystems (pcg_rand, rand_pcg,
rand_xoshiro), compact RNG design, and SIMD portability issues provide
supporting context that these areas are active, high-value niches.
Similarly, references to Ziggurat-based sampling and SIMD-related
research underpin the feasibility and value of minimal microcrates for
statistical samplers and fast numeric routines in no_std/embedded or
WASM contexts. The cited references to portable SIMD and discussion
threads about reducing dependency footprint further justify the
\"Portable SIMD Micro-Helpers\" and \"Minimal CPU Feature Detection\"
opportunities as ripe for focused crates. The goal is to illustrate how
these excerpts collectively validate the proposed opportunities by
showing existing literature, practical constraints (no_std, WASM), and a
history of efficient, minimalistic implementations that the microcrates
could emulate or improve upon. \n\nConfidence is high for the core
bit-twiddling microcrate inference, given multiple excerpts explicitly
address portable bitwise intrinsics, no_std, and cross-architecture
coverage, which directly underpin the design constraints and the value
proposition. For RNG/minimal math and SIMD-related microcrates, the
support is strong but slightly less direct (involving related
discussions and existing crates, which nonetheless establish market
demand and technical viability).",

"confidence": "high"

},

{

"field": "c_cpp_porting_candidates.4",

"citations": [

{

"title": "morton-nd/morton-nd: A header-only compile-time ...",

"url": "https://github.com/morton-nd/morton-nd",

"excerpts": [

"A header-only Morton encode/decode library (C++14) capable of encoding
from and decoding to N-dimensional space. All algorithms are generated
at compile-time."

]

}

],

"reasoning": "The fine-grained field value discusses Morton codes (bit
interleaving) as a compact, foundational utility that would benefit from
a small Rust crate under 100 lines of code. Among the excerpts, the only
one that touches on Morton-related content is a C++ header-only library
for Morton encode/decode, which confirms the existence of Morton-based
algorithms in other ecosystems but does not mention Rust or a ready-made
Rust port. This indicates a potential gap in the Rust ecosystem for a
minimal Morton-codes utility, and that the closest supporting artifact
is the C++ implementation rather than Rust-specific work. The other
excerpts describe PCG RNG implementations and do not pertain to Morton
codes, interleaving, or spatial indexing utilities, thus offering little
direct relevance to the finegrained field value.",

"confidence": "low"

},

{

"field": "opportunity_summary_table.8",

"citations": [

{

"title": "Bitintr crate - Rust crates.io",

"url": "https://crates.io/crates/bitintr",

"excerpts": [

"This `#![no_std]` library exposes *safe* and *portable* low-level bit
manipulation\ninstruction set architectures. The Minimum Supported Rust
Version is 1.36.0.",

"The intrinsics are exposed via traits named after their CPU
instruction."

]

},

{

"title": "gnzlbg/bitintr: Portable Bitwise Manipulation Intrinsics",

"url": "https://github.com/gnzlbg/bitintr",

"excerpts": [

"This `#![no_std]` library exposes *safe* and *portable* low-level bit
manipulation\ninstruction set architectures.",

"This #![no_std] library exposes safe and portable low-level bit
manipulation instruction set architectures. The Minimum Supported Rust
Version is 1.36.0."

]

},

{

"title": "Bitintr 0.3.0 Documentation and Repository",

"url": "http://docs.rs/bitintr/latest/bitintr",

"excerpts": [

"This `#![no_std]` library exposes *safe* and *portable* low-level bit
manipulation\ninstruction set architectures.",

"The intrinsics are exposed via traits named after their CPU
instruction."

]

},

{

"title": "bitintr 0.3.0 - Docs.rs",

"url": "http://docs.rs/bitintr/0.3.0/bitintr",

"excerpts": [

"This `#![no_std]` library exposes *safe* and *portable* low-level bit
manipulation\ninstruction set architectures."

]

}

],

"reasoning": "The target fine-grained field describes a tiny,
constant-evaluable, no_std matrix primitive suitable for 2x2/3x3
transformations in embedded or WASM contexts, intended to avoid
dependency bloat and reduce compile times. Excerpts that illustrate how
Rust crates can be designed as no_std, portable, and focused on
low-level functionality support this objective by showing patterns for
compact, dependency-light libraries and safe abstractions over
architecture-specific features. Specifically, a crate that is declared
with #![no_std] and exposes safe, portable low-level capabilities
demonstrates the feasibility of building small, targeted math primitives
without pulling in a heavy runtime or large dependencies. Additional
excerpts highlight the idea of minimal, specialized intrinsics and tiny
helpers that stay lean, which is consistent with creating a compact
matrix microcrate focused on essential 2D/3D transformations.
Concretely, the excerpts show: a no_std design for a low-level, portable
interface, and a wording that emphasizes safety and portability across
architectures; the documentation confirms this approach for a small,
focused crate; and the related discussion of exposing minimal,
architecture-specific intrinsics aligns with building a tiny math crate
that could be const-evaluable for compile-time computation. Taken
together, these points support the viability and design considerations
for a tiny 2x2/3x3 Rust matrix microcrate intended for embedded and WASM
contexts.",

"confidence": "medium"

},

{

"field": "opportunity_summary_table.11",

"citations": [

{

"title": "Bit Twiddling Hacks",

"url": "https://graphics.stanford.edu/~seander/bithacks.html",

"excerpts": [

"r = y + ((x - y) & ((x - y) >> (sizeof(int) * CHAR_BIT - 1))); //
min(x, y)",

"r = y ^ ((x ^ y) & -(x < y)); // min(x, y)",

"Compute the minimum (min) or maximum (max) of two integers without
branching\nint x; // we want to find the minimum of x and y\nint y; int
r; // the result goes here r = y ^ ((x ^ y) & -(x < y)); // min(x, y) On
some rare machines where branching is very expensive and no
condition\nmove instructions exist, the above expression\nmight be
faster than the obvious approach, r = (x < y) ? x : y, even though it
involves two more instructions. (Typically, the obvious approach is
best, though.) It works because if x < y, then -(x < y) will be all
ones, so r = y ^ (x ^ y) & ~0 = y ^ x ^ y = x. Otherwise, if x >= y,
then -(x < y) will be all zeros, so r = y ^ ((x ^ y) & 0) = y. On some
machines, evaluating (x < y) as 0 or 1 requires a branch instruction, so
there may be n",

"It works because if x < y, then -(x < y) will be all ones, so r = y ^
(x ^ y) & ~0 = y ^ x ^ y = x. Otherwise, if x >= y, then -(x < y) will
be all zeros, so r = y ^ ((x ^ y) & 0) = y.",

"To find the maximum, use:\nr = x ^ ((x ^ y) & -(x < y)); // max(x, y)",

"Quick and dirty versions: If you know that INT_MIN <= x - y <=
INT_MAX,\nthen you can use the following, which are faster because (x -
y) only needs to be evaluated once. r = y + ((x - y) & ((x - y) >>
(sizeof(int) * CHAR_BIT - 1))); // min(x, y)",

"The naive approach requires one iteration per bit, until no more bits
are set. So on a 32-bit word with only the high set, it will go through
32 iterations. Compute the minimum (min) or maximum (max) of two
integers without branching",

"r = x ^ ((x ^ y) & -(x < y)); // max(x, y)",

"Bit Twiddling Hacks. By Sean Eron Anderson",

"unsigned int t = v | (v - 1); // t gets v's least significant 0 bits
set to 1\n// Next set to 1 the most significant bit to change, // set to
0 the least significant ones, and add the necessary 1 bits.",

"int y; int r; // the result goes here r = y ^ ((x ^ y) & -(x < y)); //
min(x, y)",

"Bit Twiddling Hacks",

"\nBy Sean Eron Anderson seander@cs.stanford.edu Individually, the code
snippets here are in the public domain (unless otherwise noted) — feel
free to use them however you please. The aggregate collection and
descriptions are © 1997-2005 Sean Eron Anderson. The code and
descriptions are distributed in the hope that they will be useful,",

"n and\ncountbetween on April 10, 2005. Compute the lexicographically
next bit permutation Suppose we have a pattern of N bits set to 1 in an
integer and we want the next permutation of N 1 bits in a
lexicographical sense. For example, if N is 3 and the bit pattern is
00010011, the next patterns would be 00010101, 00010110,
00011001,00011010, 00011100, 00100011, and so forth. The following is a
fast way to compute the next permutation. unsigned int v; // current
permutation of bits unsigned int w;",

"What he hasn't tested, I have checked against all\npossible inputs on a
32-bit machine.",

"The code and descriptions are distributed in the hope that they will be
useful,\nbut WITHOUT ANY WARRANTY and without even the implied warranty
of\nmerchantability or fitness for a particular purpose.",

"Bit Twiddling Hacks. By Sean Eron Anderson seander@cs.stanford.edu.
Individually, the code snippets here are in the public domain (unless
otherwise noted) ... Bit Twiddling Hack",

"As of May 5, 2005, all the code has been tested thoroughly. Thousands
of\npeople have read it.",

"The method first shifts and XORs the eight nibbles of the 32-bit value
together, leaving the result in the lowest nibble of v. Next, the binary
number 0110 ..."

]

}

],

"reasoning": "The core fine-grained field value seeks explicit
branchless techniques to compute the minimum or maximum of two integers
using bitwise operations, which are central to avoiding timing
side-channels in cryptographic or security-sensitive contexts. Several
excerpts provide concrete, implementable formulas: for example, a direct
expression using a bitwise formulation to select min without a branch,
and related identities that avoid conditional branches by exploiting
bitwise masks. These excerpts describe the canonical branchless min/max
patterns and show how to combine XOR and AND/OR masks to select the
desired value without branching. Additional excerpts discuss broader
bit-twiddling hacks and high-signal references that corroborate these
techniques or provide complementary formulas. Together, they establish
both the existence of branchless selection patterns and practical
implementations, supporting the claim that such primitives are valuable
for cryptographic and performance-critical code. The links in these
excerpts point to well-known sources of bit-twiddling techniques and
practical crates that illustrate or rely on such methods, reinforcing
the relevance and applicability of these ideas in Rust ecosystems and
broader contexts.",

"confidence": "high"

},

{

"field": "c_cpp_porting_candidates.4.description",

"citations": [

{

"title": "morton-nd/morton-nd: A header-only compile-time ...",

"url": "https://github.com/morton-nd/morton-nd",

"excerpts": [

"A header-only Morton encode/decode library (C++14) capable of encoding
from and decoding to N-dimensional space. All algorithms are generated
at compile-time."

]

}

],

"reasoning": "The described algorithm explicitly pertains to
interleaving bits of coordinates to form a single-dimensional
representation, i.e., the Z-order (Morton) curve. The excerpt mentions a
header-only library for Morton encode/decode, which directly embodies
this concept. This supports the notion that a Rust port or a small
Rust-based library implementing Morton encoding/decoding would fulfill
the research goal of a compact, high-impact, low-loc library useful for
spatial indexing tasks in graphics, games, or databases. The existence
of a C++-based reference demonstrates the core algorithmic viability and
may inform API design, performance considerations, and potential porting
challenges to Rust.",

"confidence": "high"

},

{

"field": "c_cpp_porting_candidates.4.porting_rationale",

"citations": [

{

"title": "morton-nd/morton-nd: A header-only compile-time ...",

"url": "https://github.com/morton-nd/morton-nd",

"excerpts": [

"A header-only Morton encode/decode library (C++14) capable of encoding
from and decoding to N-dimensional space. All algorithms are generated
at compile-time."

]

}

],

"reasoning": "The user's fine-grained field targets the idea that a
tiny, highly portable Morton encoding/decoding primitive would fill a
missing or underdeveloped space in Rust. The excerpt provides a concrete
example of the same primitive implemented in C++ as a compact,
header-only library with compile-time generation. This demonstrates that
the core bit-twiddling logic for Morton encoding/decoding is inherently
small and self-contained, aligning with the premise that a small Rust
crate could implement this primitive efficiently (likely under 300 LOC).
While the excerpt itself is in C++, it directly supports the feasibility
and value of creating a Rust version as a lightweight, reusable utility,
which is exactly the type of opportunity the field value describes. The
evidence suggests a recognizable gap in Rust tooling for this primitive,
and the compactness of the C++ implementation reinforces the
plausibility of a minimal Rust crate meeting the stated constraints and
potential high usage. ",

"confidence": "high"

},

{

"field": "opportunity_summary_table.5",

"citations": [

{

"title": "bitintr - Rust",

"url": "https://gnzlbg.github.io/bitintr/",

"excerpts": [

"bitintr offers portable bit manipulation intrinsics (@github,
@crates.io). The intrinsics are named after their CPU instruction and
organized in modules ..."

]

},

{

"title": "gnzlbg/bitintr: Portable Bitwise Manipulation Intrinsics",

"url": "https://github.com/gnzlbg/bitintr",

"excerpts": [

"This #![no_std] library exposes safe and portable low-level bit
manipulation instruction set architectures. The Minimum Supported Rust
Version is 1.36.0.",

"The intrinsics are exposed via traits named after their CPU
instruction. These\ntraits are implemented for all integer types
*except* `u128/i128`.",

"Licensed under the [MIT
license](https://github.com/gnzlbg/bitintr/blob/master/license.md).",

"This `#![no_std]` library exposes *safe* and *portable* low-level bit
manipulation\ninstruction set architectures."

]

},

{

"title": "bitintr 0.3.0 - Docs.rs",

"url": "http://docs.rs/bitintr/0.3.0/bitintr",

"excerpts": [

"The intrinsics are exposed via traits named after their CPU
instruction. These\ntraits are implemented for all integer types
*except* `u128/i128`.",

"The intrinsics are exposed via traits named after their CPU
instruction. These\ntraits are implemented for all integer types
*except* `u128/i128`.",

"Licensed under the [MIT
license](https://github.com/gnzlbg/bitintr/blob/master/license.md).",

"This `#![no_std]` library exposes *safe* and *portable* low-level bit
manipulation\ninstruction set architectures."

]

},

{

"title": "Bitintr crate - Rust crates.io",

"url": "https://crates.io/crates/bitintr",

"excerpts": [

"This `#![no_std]` library exposes *safe* and *portable* low-level bit
manipulation\ninstruction set architectures. The Minimum Supported Rust
Version is 1.36.0.",

"The intrinsics are exposed via traits named after their CPU
instruction. These traits are implemented for all integer types except
u128/i128 ",

"#! [no_std] library exposes safe and portable low-level bit
manipulation\ninstruction set architectures.",

"Licensed under the [MIT
license](https://github.com/gnzlbg/bitintr/blob/master/license.md).",

"The intrinsics are exposed via traits named after their CPU
instruction."

]

},

{

"title": "Bitintr 0.3.0 Documentation and Repository",

"url": "http://docs.rs/bitintr/latest/bitintr",

"excerpts": [

"This `#![no_std]` library exposes *safe* and *portable* low-level bit
manipulation\ninstruction set architectures.",

"The intrinsics are exposed via traits named after their CPU
instruction."

]

}

],

"reasoning": "The target field describes Portable SIMD micro-helpers
intended to fill gaps in the Rust SIMD ecosystem with small, high-impact
libraries that provide safe, portable access to low-level operations.
The most relevant excerpts describe a Rust crate that exposes portable,
safe, low-level bit manipulation intrinsics across architectures in a
no_std context, with traits named after CPU instructions and broad
coverage across x86 and ARM families. This directly maps to the notion
of lightweight, ergonomic wrappers around primitive operations that
could be extended to SIMD-like operations, enabling wide applicability
and performance portability. Additional excerpts emphasize that these
intrinsics are designed to be portable and safe across architectures,
with explicit support or non-support notes for certain types and ISAs,
which informs how a small SIMD helper crate might expose a consistent
API while remaining cross-platform. Documentation-focused excerpts
reiterate safe, portable, and no_std characteristics, which are
desirable properties for small, robust libraries. Collectively, these
excerpts support the idea that a compact, well-scoped crate providing
portable SIMD helpers—covering horizontal reductions, swizzles, or
similar primitives—fits an ecosystem gap and could be both high-value
and feasible to implement and test. The presence of companion crates
like bitintr and discussions around PDEP/PEXT also illustrate a pattern
of narrow, high-impact low-level utilities that a PMF opportunity could
emulate or extend into SIMD-specific helpers. The strongest support
comes from explicit statements about portable, no_std, and
architecture-aware intrinsics, which align with the envisioned
micro-helper model. The other excerpts provide corroborating context
about ecosystem practices and documentation approaches that a small SIMD
crate would adopt.",

"confidence": "high"

},

{

"field": "c_cpp_porting_candidates.4.source_and_license",

"citations": [

{

"title": "morton-nd/morton-nd: A header-only compile-time ...",

"url": "https://github.com/morton-nd/morton-nd",

"excerpts": [

"A header-only Morton encode/decode library (C++14) capable of encoding
from and decoding to N-dimensional space. All algorithms are generated
at compile-time."

]

}

],

"reasoning": "The finegrained field value asserts that there is a
classic bit-twiddling hack with public-domain licensing, and that
reference implementations are found in graphics programming resources
and in the morton-nd/morton-nd C++ header-only library. The excerpt
provides evidence of a concrete, compact, header-only C++14
implementation for Morton encodings/decoding, described as a header-only
library. This aligns with the idea of a small, self-contained component
suitable for porting into Rust under a similarly permissive license and
with a minimal surface area for testing (under 300 lines). While the
excerpt does not explicitly state the licensing terms (public domain)
for that C++ library, it does confirm the existence and characteristics
of a compact, header-only reference that could guide a Rust port.
Therefore, the excerpt is highly relevant to evaluating the feasibility
and approach for a small Rust port of a Morton-code utility, and it
informs licensing considerations by suggesting a permissive, header-only
precedent in practice. The link to a concrete C++ header-only
implementation strengthens the case that a Rust port could achieve a
similar compact footprint and ease of use. ",

"confidence": "medium"

},

{

"field": "c_cpp_porting_candidates.4.utility_name",

"citations": [

{

"title": "morton-nd/morton-nd: A header-only compile-time ...",

"url": "https://github.com/morton-nd/morton-nd",

"excerpts": [

"A header-only Morton encode/decode library (C++14) capable of encoding
from and decoding to N-dimensional space. All algorithms are generated
at compile-time."

]

}

],

"reasoning": "The field value refers to Morton Codes implemented via bit
interleaving. The excerpt describes a header-only Morton encode/decode
library, which embodies the same core concept of Morton codes through
bit interleaving used for N-dimensional space encoding/decoding. This
confirms that Morton codes are a recognized utility area and that there
are existing implementations for similar interleaving functionality.
While the excerpt is about a C++ library rather than Rust, the core idea
and implementation approach (compile-time code generation for Morton
interleaving) are directly relevant to evaluating Rust porting
opportunities, as it provides a concrete target concept (Morton codes)
that could be translated into small Rust libraries under 300 LOC. The
fact that the library is header-only emphasizes a minimal, install-light
approach that aligns with the goal of small, high-utility Rust
libraries. However, since the language and ecosystem differ, this
excerpt does not confirm a Rust port exists, but it supports the locus
of interest (Morton codes) and provides a concrete reference point for
potential Rust implementations.",

"confidence": "medium"

},

{

"field": "opportunity_summary_table.8.pmf_probability_score",

"citations": [

{

"title": "gnzlbg/bitintr: Portable Bitwise Manipulation Intrinsics",

"url": "https://github.com/gnzlbg/bitintr",

"excerpts": [

"This #![no_std] library exposes safe and portable low-level bit
manipulation instruction set architectures. The Minimum Supported Rust
Version is 1.36.0.",

"This `#![no_std]` library exposes *safe* and *portable* low-level bit
manipulation\ninstruction set architectures."

]

},

{

"title": "Bitintr crate - Rust crates.io",

"url": "https://crates.io/crates/bitintr",

"excerpts": [

"This `#![no_std]` library exposes *safe* and *portable* low-level bit
manipulation\ninstruction set architectures. The Minimum Supported Rust
Version is 1.36.0.",

"The intrinsics are exposed via traits named after their CPU
instruction."

]

},

{

"title": "Bitintr 0.3.0 Documentation and Repository",

"url": "http://docs.rs/bitintr/latest/bitintr",

"excerpts": [

"This `#![no_std]` library exposes *safe* and *portable* low-level bit
manipulation\ninstruction set architectures.",

"The intrinsics are exposed via traits named after their CPU
instruction."

]

},

{

"title": "bitintr 0.3.0 - Docs.rs",

"url": "http://docs.rs/bitintr/0.3.0/bitintr",

"excerpts": [

"This `#![no_std]` library exposes *safe* and *portable* low-level bit
manipulation\ninstruction set architectures."

]

}

],

"reasoning": "The most credible support comes from evidence describing a
portable, no_std crate that exposes safe, low-level bit manipulation
intrinsics across architectures. This directly matches the target
profile of a small Rust library (likely under a few hundred lines) that
would be widely reusable in systems programming and could see high
adoption due to its foundational utility. The description emphasizes
portability and safety, which are highly valued for broad ecosystem
impact, reinforcing the plausibility of a strong PMF signal. Additional
excerpts reinforce the same theme by noting the crate name, repository,
and documentation pages, underscoring that this is a concrete,
minimalistic, and reusable primitive library. This combination provides
a coherent narrative that such a compact, safe, portable intrinsic
library has a high chance of filling an ecosystem gap, aligning with the
0.8/1.0 PMF target. While the excerpts do not state LOC counts
explicitly, the emphasis on minimal, no_std, and portable fundamentals
supports the interpretation that the library could reasonably be under
300 lines and highly testable across platforms. Collectively, these
excerpts substantiate a strong, coherent link between an under-300 LOC
Rust intrinsic library and a high PMF likelihood for broad use. ",

"confidence": "medium"

},

{

"field": "opportunity_summary_table.0",

"citations": [

{

"title": "bitintr - Rust",

"url": "https://gnzlbg.github.io/bitintr/",

"excerpts": [

"bitintr offers portable bit manipulation intrinsics (@github,
@crates.io). The intrinsics are named after their CPU instruction and
organized in modules ..."

]

},

{

"title": "gnzlbg/bitintr: Portable Bitwise Manipulation Intrinsics",

"url": "https://github.com/gnzlbg/bitintr",

"excerpts": [

"The intrinsics are exposed via traits named after their CPU
instruction. These\ntraits are implemented for all integer types
*except* `u128/i128`.",

"This `#![no_std]` library exposes *safe* and *portable* low-level bit
manipulation\ninstruction set architectures.",

"This #![no_std] library exposes safe and portable low-level bit
manipulation instruction set architectures. The Minimum Supported Rust
Version is 1.36.0.",

"Portable Bitwise Manipulation Intrinsics",

"Portable Bitwise Manipulation Intrinsics",

"Licensed under the [MIT
license](https://github.com/gnzlbg/bitintr/blob/master/license.md)."

]

},

{

"title": "bitintr 0.3.0 - Docs.rs",

"url": "http://docs.rs/bitintr/0.3.0/bitintr",

"excerpts": [

"The intrinsics are exposed via traits named after their CPU
instruction. These\ntraits are implemented for all integer types
*except* `u128/i128`.",

"The intrinsics are exposed via traits named after their CPU
instruction. These\ntraits are implemented for all integer types
*except* `u128/i128`.",

"This `#![no_std]` library exposes *safe* and *portable* low-level bit
manipulation\ninstruction set architectures.",

"Licensed under the [MIT
license](https://github.com/gnzlbg/bitintr/blob/master/license.md)."

]

},

{

"title": "Bitintr 0.3.0 Documentation and Repository",

"url": "http://docs.rs/bitintr/latest/bitintr",

"excerpts": [

"This `#![no_std]` library exposes *safe* and *portable* low-level bit
manipulation\ninstruction set architectures.",

"The intrinsics are exposed via traits named after their CPU
instruction."

]

},

{

"title": "Bitintr crate - Rust crates.io",

"url": "https://crates.io/crates/bitintr",

"excerpts": [

"The intrinsics are exposed via traits named after their CPU
instruction.",

"28/i128 . The following ISAs are implemented:\n * x86 (\nbitintr::x86
):\n * ABM : Advanced Bit Manipulation instructions (\nbitintr::x86::abm
). * TBM : Trailing Bit Manipulation instructions (\nbitintr::x86::tbm
). * BMI : Bit Manipulation Instruction Set 1.0 (\nbitintr::x86::bmi ).
* BMI2 : Bit Manipulation Instruction Set 2.0 (\nbitintr::x86::bmi2 ). *
ARM (\nbitintr::arm ):\n * ARMv5 :\nbitintr::arm::v5 . * ARMv6
:\nbitintr::arm::v6 . * ARMv7 :\nbitintr::arm::v7 . * ARMv8
:\nbitintr::arm::v8 . The actual code generated depends on the integer
types involved and the features\nsupported by the target architecture.",

"The intrinsics are exposed via traits named after their CPU
instruction. These traits are implemented for all integer types except
u128/i128 ",

"#! [no_std] library exposes safe and portable low-level bit
manipulation\ninstruction set architectures.",

"Licensed under the [MIT
license](https://github.com/gnzlbg/bitintr/blob/master/license.md)."

]

},

{

"title": "has_fast_pdep crate page",

"url": "https://crates.io/crates/has_fast_pdep",

"excerpts": [

"A single-function, `no-std` library that returns `true` if the current
CPU implements PDEP and PEXT with fast, non-microcoded hardware.",

"Rationale\n---------\n\nZen, Zen+, Zen 2, and Hygon Dhyana CPUs
implement PDEP and PEXT using microcode in a way that makes them slower
than well-optimized, non-intrinsic fallbacks. In performance-critical
code, checking for BMI2 support isn't enough—you could end up hurting
performance on said CPUs where these instructions exist but are slow.
This crate helps you avoid that by detecting speed, not just support.",

"The result of the hardware check is determined once at runtime. After
the initial check, all future\ncalls to `has_fast_pdep` becomes a simple
`true` or `false` with zero branching or logic. On x86 targets, CPUID is
used directly without probing for its existence. This is intentional.",

"You can view the documentation on docs.rs
[here](https://docs.rs/has_fast_pdep).",

"Rationale\n---------\n\nZen, Zen+, Zen 2, and Hygon Dhyana CPUs
implement PDEP and PEXT using microcode in a way that makes them slower
than well-optimized, non-intrinsic fallbacks. In performance-critical
code, checking for BMI2 support isn't enough—you could end up hurting
performance on said CPUs where these instructions exist but are slow.
This crate helps you avoid that by detecting speed, not just support",

"Implementation Details\n----------------------\n\nThe result of the
hardware check is determined once at runtime. After the initial check,
all future\ncalls to `has_fast_pdep` becomes a simple `true` or `false`
with zero branching or logic.",

"Detect fast hardware support for PDEP/PEXT."

]

}

],

"reasoning": "The strongest support comes from direct descriptions of
the Bitintr crate, which is explicitly a portable, low-level bit
manipulation intrinsics library aimed at being safe and portable across
architectures, and which is designed as a no_std crate. This aligns with
the proposed opportunity of a modern, portable bit-twiddling microcrate
that fills gaps left by the unmaintained bitintr crate, especially for
PDEP/PEXT and Morton coding, which are highlighted as missing from
standard libraries and crucial for graphics, compression, and
cryptography. Additional excerpts emphasize the no_std constraint and
cross-architecture coverage, which underpin the portability and small
footprint goals of a concise Rust library. The Bitintr crate
documentation further notes that the intrinsics are exposed via
CPU-instruction-named traits and that the crate targets multiple
architectures (x86, TBM, BMI, BMI2, ARM variants), reinforcing the
feasibility of a small, portable crate with broad applicability. The
presence of Bitintr's focus on safe, portable low-level bit manipulation
supports the premise that there is a recognized need for a modern
alternative that remains dependency-free and suitable for WASM or native
targets. Supporting materials from Bitintr crates.io entries reiterate
the no_std design and the limitation that certain wide types (e.g.,
u128/i128) may not be implemented, which helps scope the under-300-loc
goal and clarifies architectural trade-offs. Related entries about Bit
Twiddling Hacks and fracture points like has_fast_pdep provide context
for performance-oriented decisions and testing strategies (e.g., runtime
detection of fast PDEP/PEXT) that are relevant to designing a lean,
verifiable crate whose primary value is in fast bit-twiddling primitives
and possibly Morton coding helpers. The canonical algorithms references
and bit-twiddling resources cited in the excerpts offer authoritative
testbeds and validation targets for correctness, which supports the plan
to build a small, well-tested library with real-world applicability in
graphics, compression, cryptography, and similar domains. Collectively,
these excerpts substantiate the core claim that a modern, portable,
under-300-loc bit-twiddling crate is both needed and technically
feasible, with clear paths for testing, verification, and platform-aware
optimizations. ",

"confidence": "high"

},

{

"field": "opportunity_summary_table.11.reasoning",

"citations": [

{

"title": "Bit Twiddling Hacks",

"url": "https://graphics.stanford.edu/~seander/bithacks.html",

"excerpts": [

"Compute the minimum (min) or maximum (max) of two integers without
branching\nint x; // we want to find the minimum of x and y\nint y; int
r; // the result goes here r = y ^ ((x ^ y) & -(x < y)); // min(x, y) On
some rare machines where branching is very expensive and no
condition\nmove instructions exist, the above expression\nmight be
faster than the obvious approach, r = (x < y) ? x : y, even though it
involves two more instructions. (Typically, the obvious approach is
best, though.) It works because if x < y, then -(x < y) will be all
ones, so r = y ^ (x ^ y) & ~0 = y ^ x ^ y = x. Otherwise, if x >= y,
then -(x < y) will be all zeros, so r = y ^ ((x ^ y) & 0) = y. On some
machines, evaluating (x < y) as 0 or 1 requires a branch instruction, so
there may be n",

"r = x ^ ((x ^ y) & -(x < y)); // max(x, y)",

"To find the maximum, use:\nr = x ^ ((x ^ y) & -(x < y)); // max(x, y)",

"Quick and dirty versions: If you know that INT_MIN <= x - y <=
INT_MAX,\nthen you can use the following, which are faster because (x -
y) only needs to be evaluated once. r = y + ((x - y) & ((x - y) >>
(sizeof(int) * CHAR_BIT - 1))); // min(x, y)",

"int y; int r; // the result goes here r = y ^ ((x ^ y) & -(x < y)); //
min(x, y)"

]

}

],

"reasoning": "The fine-grained value claims that branchless,
constant-time integer primitives are provided by the Bit Twiddling Hacks
techniques, which avoid timing side-channels in security-sensitive
contexts. The most directly supportive excerpts explicitly present
formulas for selecting min and max without branches, such as min(x, y)
implemented as r = y ^ ((x ^ y) & -(x < y)) and max(x, y) implemented as
r = x ^ ((x ^ y) & -(x < y)). These excerpts prove the core mechanism:
using bitwise operations combined with the negation of a comparison to
produce a branchless result. Additional excerpts reinforce the same
concept with related patterns (e.g., min/max without branching via
alternative expressions) and provide broader context on Bit Twiddling
Hacks. Collectively, they corroborate the existence and utility of
branchless, constant-time integer primitives within the Bit Twiddling
Hacks collection, supporting the idea that such primitives fill a needed
niche (cryptography/security-sensitive contexts) and have demonstrated
value in practice through widely cited techniques and public-domain
code. The remaining excerpts add supplementary context about the Bit
Twiddling Hacks collection but do not directly present the same explicit
branchless min/max patterns, making them supportive rather than central
to the claim.",

"confidence": "high"

},

{

"field": "opportunity_summary_table.8.ease_of_success_testing",

"citations": [

{

"title": "Bitintr crate - Rust crates.io",

"url": "https://crates.io/crates/bitintr",

"excerpts": [

"This `#![no_std]` library exposes *safe* and *portable* low-level bit
manipulation\ninstruction set architectures. The Minimum Supported Rust
Version is 1.36.0.",

"The intrinsics are exposed via traits named after their CPU
instruction."

]

},

{

"title": "gnzlbg/bitintr: Portable Bitwise Manipulation Intrinsics",

"url": "https://github.com/gnzlbg/bitintr",

"excerpts": [

"This `#![no_std]` library exposes *safe* and *portable* low-level bit
manipulation\ninstruction set architectures.",

"This #![no_std] library exposes safe and portable low-level bit
manipulation instruction set architectures. The Minimum Supported Rust
Version is 1.36.0."

]

},

{

"title": "Bitintr 0.3.0 Documentation and Repository",

"url": "http://docs.rs/bitintr/latest/bitintr",

"excerpts": [

"This `#![no_std]` library exposes *safe* and *portable* low-level bit
manipulation\ninstruction set architectures.",

"The intrinsics are exposed via traits named after their CPU
instruction."

]

},

{

"title": "bitintr 0.3.0 - Docs.rs",

"url": "http://docs.rs/bitintr/0.3.0/bitintr",

"excerpts": [

"This `#![no_std]` library exposes *safe* and *portable* low-level bit
manipulation\ninstruction set architectures."

]

}

],

"reasoning": "The excerpts describe a compact, portable, no_std crate
that provides safe, low-level bit manipulation intrinsics for CPU
architectures. This aligns with the requested target of under-300-line
Rust libraries in the CPU domain, since it exemplifies a small,
specialized library focused on a hardware-facing capability. The
documentation notes that the crate exposes intrinsics via traits named
after CPU instructions, reinforcing the CPU-centric scope. The no_std
attribute and minimum supported Rust version details further illustrate
constraints and portability considerations relevant to keeping a library
small and focused. While none of the excerpts discuss PMF or explicit
testing ease, they demonstrate the viability and design patterns for a
tiny, high-utility Rust library in the CPU domain, which can inform
feasibility and verification strategies for similarly scoped
opportunities. The absence of explicit testing-ease metrics means the
target PMF-ease score cannot be conclusively supported by these excerpts
alone, but the demonstrated pattern supports the plausibility of small,
high-impact crates in this space.",

"confidence": "low"

},

{

"field": "opportunity_summary_table.11.opportunity_name",

"citations": [

{

"title": "Bit Twiddling Hacks",

"url": "https://graphics.stanford.edu/~seander/bithacks.html",

"excerpts": [

"r = y + ((x - y) & ((x - y) >> (sizeof(int) * CHAR_BIT - 1))); //
min(x, y)",

"Quick and dirty versions: If you know that INT_MIN <= x - y <=
INT_MAX,\nthen you can use the following, which are faster because (x -
y) only needs to be evaluated once. r = y + ((x - y) & ((x - y) >>
(sizeof(int) * CHAR_BIT - 1))); // min(x, y)",

"r = y ^ ((x ^ y) & -(x < y)); // min(x, y)",

"Compute the minimum (min) or maximum (max) of two integers without
branching\nint x; // we want to find the minimum of x and y\nint y; int
r; // the result goes here r = y ^ ((x ^ y) & -(x < y)); // min(x, y) On
some rare machines where branching is very expensive and no
condition\nmove instructions exist, the above expression\nmight be
faster than the obvious approach, r = (x < y) ? x : y, even though it
involves two more instructions. (Typically, the obvious approach is
best, though.) It works because if x < y, then -(x < y) will be all
ones, so r = y ^ (x ^ y) & ~0 = y ^ x ^ y = x. Otherwise, if x >= y,
then -(x < y) will be all zeros, so r = y ^ ((x ^ y) & 0) = y. On some
machines, evaluating (x < y) as 0 or 1 requires a branch instruction, so
there may be n",

"int y; int r; // the result goes here r = y ^ ((x ^ y) & -(x < y)); //
min(x, y)",

"It works because if x < y, then -(x < y) will be all ones, so r = y ^
(x ^ y) & ~0 = y ^ x ^ y = x. Otherwise, if x >= y, then -(x < y) will
be all zeros, so r = y ^ ((x ^ y) & 0) = y.",

"The naive approach requires one iteration per bit, until no more bits
are set. So on a 32-bit word with only the high set, it will go through
32 iterations. Compute the minimum (min) or maximum (max) of two
integers without branching",

"To find the maximum, use:\nr = x ^ ((x ^ y) & -(x < y)); // max(x, y)",

"r = x ^ ((x ^ y) & -(x < y)); // max(x, y)",

"unsigned int t = v | (v - 1); // t gets v's least significant 0 bits
set to 1\n// Next set to 1 the most significant bit to change, // set to
0 the least significant ones, and add the necessary 1 bits.",

"Bit Twiddling Hacks",

"\nBy Sean Eron Anderson seander@cs.stanford.edu Individually, the code
snippets here are in the public domain (unless otherwise noted) — feel
free to use them however you please. The aggregate collection and
descriptions are © 1997-2005 Sean Eron Anderson. The code and
descriptions are distributed in the hope that they will be useful,",

"What he hasn't tested, I have checked against all\npossible inputs on a
32-bit machine.",

"The code and descriptions are distributed in the hope that they will be
useful,\nbut WITHOUT ANY WARRANTY and without even the implied warranty
of\nmerchantability or fitness for a particular purpose.",

"Bit Twiddling Hacks. By Sean Eron Anderson seander@cs.stanford.edu.
Individually, the code snippets here are in the public domain (unless
otherwise noted) ... Bit Twiddling Hack",

"As of May 5, 2005, all the code has been tested thoroughly. Thousands
of\npeople have read it.",

"The method first shifts and XORs the eight nibbles of the 32-bit value
together, leaving the result in the lowest nibble of v. Next, the binary
number 0110 ..."

]

}

],

"reasoning": "The target fine-grained field value corresponds to
branchless integer selection, specifically min/max without branching.
Excerpts that explicitly present a branchless approach to min or max are
highly relevant, as they provide concrete formulas suitable for a small
Rust library. The most directly relevant passages show exact expressions
for computing the minimum of two integers without conditional branches,
such as r = y + ((x - y) & ((x - y) >> (size)) which computes min
without branching, and r = y ^ ((x ^ y) & -(x < y)) for min, and r = x ^
((x ^ y) & -(x < y)) for max. Additional items reiterate the same idea
or present related branchless techniques (e.g., using bit tricks to
derive min/max or discuss the symmetry of techniques). These excerpts
collectively confirm that the core concept—branchless min/max operations
using bitwise tricks—is well covered, and they provide concrete code
patterns that can be ported to Rust libraries, including cross-platform
considerations and performance notes. Excerpts that discuss broader Bit
Twiddling Hacks context or provide ancillary details without presenting
a direct formula are considered supportive context but less directly
useful for implementing a small, reusable library around the exact
branchless min/max concept. Overall, the strongest evidence comes from
explicit min/max formulas without branching, followed by corroborating
statements and variations of the same technique, with diminishing
relevance for excerpts that mainly discuss surrounding context or
non-min/max bit tricks.",

"confidence": "high"

},

{

"field": "opportunity_summary_table.5.ease_of_success_testing",

"citations": [

{

"title": "gnzlbg/bitintr: Portable Bitwise Manipulation Intrinsics",

"url": "https://github.com/gnzlbg/bitintr",

"excerpts": [

"The intrinsics are exposed via traits named after their CPU
instruction. These\ntraits are implemented for all integer types
*except* `u128/i128`.",

"This #![no_std] library exposes safe and portable low-level bit
manipulation instruction set architectures. The Minimum Supported Rust
Version is 1.36.0.",

"This `#![no_std]` library exposes *safe* and *portable* low-level bit
manipulation\ninstruction set architectures.",

"Licensed under the [MIT
license](https://github.com/gnzlbg/bitintr/blob/master/license.md)."

]

},

{

"title": "bitintr 0.3.0 - Docs.rs",

"url": "http://docs.rs/bitintr/0.3.0/bitintr",

"excerpts": [

"The intrinsics are exposed via traits named after their CPU
instruction. These\ntraits are implemented for all integer types
*except* `u128/i128`.",

"The intrinsics are exposed via traits named after their CPU
instruction. These\ntraits are implemented for all integer types
*except* `u128/i128`.",

"This `#![no_std]` library exposes *safe* and *portable* low-level bit
manipulation\ninstruction set architectures.",

"Licensed under the [MIT
license](https://github.com/gnzlbg/bitintr/blob/master/license.md)."

]

},

{

"title": "Bitintr crate - Rust crates.io",

"url": "https://crates.io/crates/bitintr",

"excerpts": [

"The intrinsics are exposed via traits named after their CPU
instruction.",

"This `#![no_std]` library exposes *safe* and *portable* low-level bit
manipulation\ninstruction set architectures. The Minimum Supported Rust
Version is 1.36.0.",

"The intrinsics are exposed via traits named after their CPU
instruction. These traits are implemented for all integer types except
u128/i128 ",

"#! [no_std] library exposes safe and portable low-level bit
manipulation\ninstruction set architectures.",

"Licensed under the [MIT
license](https://github.com/gnzlbg/bitintr/blob/master/license.md)."

]

},

{

"title": "Bitintr 0.3.0 Documentation and Repository",

"url": "http://docs.rs/bitintr/latest/bitintr",

"excerpts": [

"The intrinsics are exposed via traits named after their CPU
instruction.",

"This `#![no_std]` library exposes *safe* and *portable* low-level bit
manipulation\ninstruction set architectures."

]

},

{

"title": "bitintr - Rust",

"url": "https://gnzlbg.github.io/bitintr/",

"excerpts": [

"bitintr offers portable bit manipulation intrinsics (@github,
@crates.io). The intrinsics are named after their CPU instruction and
organized in modules ..."

]

}

],

"reasoning": "The most relevant information touches on core attributes
that influence testing feasibility: portability and safety. A library
declared as #![no_std] and described as safe and portable across
low-level bit manipulation intrinsics suggests it can be tested in
minimal environments and across targets, which supports an assessment of
high ease of testing. The detail that its intrinsics are exposed via
traits and implemented for all integer types (except certain edge cases)
indicates broad API coverage, which aids comprehensive test design and
reduces corner-case risk, reinforcing a high ease of testing. General
documentation and repository presence further support practical
verification and reproducibility, while licensing and high-level
descriptions, though helpful, contribute less directly to testing ease.
Together, these excerpts build a narrative that the bitintr library is
designed for portability, safety, and broad applicability, aligning with
a high ease-of-testing assessment. Specifically: the no_std
safe-and-portable claim signals cross-environment testability, the
trait-based exposure across most integer types suggests extensive test
coverage opportunities, and the ongoing documentation and crate presence
indicate accessible testing resources and artifacts.",

"confidence": "medium"

},

{

"field": "opportunity_summary_table.11.relevant_artifacts_links",

"citations": [

{

"title": "Bit Twiddling Hacks",

"url": "https://graphics.stanford.edu/~seander/bithacks.html",

"excerpts": [

"Bit Twiddling Hacks. By Sean Eron Anderson",

"\nBy Sean Eron Anderson seander@cs.stanford.edu Individually, the code
snippets here are in the public domain (unless otherwise noted) — feel
free to use them however you please. The aggregate collection and
descriptions are © 1997-2005 Sean Eron Anderson. The code and
descriptions are distributed in the hope that they will be useful,",

"r = y + ((x - y) & ((x - y) >> (sizeof(int) * CHAR_BIT - 1))); //
min(x, y)",

"int y; int r; // the result goes here r = y ^ ((x ^ y) & -(x < y)); //
min(x, y)",

"To find the maximum, use:\nr = x ^ ((x ^ y) & -(x < y)); // max(x, y)",

"r = y ^ ((x ^ y) & -(x < y)); // min(x, y)"

]

}

],

"reasoning": "The fine-grained field value points to Bit Twiddling Hacks
with the URL to the bithacks page, and credits Hacker's Delight along
with a Rust subtle crate as artifacts to reference for constructing
small, highly useful Rust libraries. The most directly relevant excerpts
explicitly identify Bit Twiddling Hacks and the author, providing clear
alignment with the field value. The highly relevant excerpts confirm the
source title and author, and include snippets or references to the
bithacks page, which supports the intended artifact identification.
Other highly relevant snippets present concrete code examples from Bit
Twiddling Hacks that illustrate the nature of the bit-twiddling
techniques described on that page, reinforcing the core topic of the
field value. Together, these excerpts substantiate the linkage to the
bithacks resource and its author, which matches the field value's first
two components. The remaining cited content that reiterates the page and
code context further corroborates the same source material. While none
of the excerpts explicitly mention Hacker's Delight or the subtle crate
by name, the core relevance is established through explicit
identification of Bit Twiddling Hacks and its author, which are the
primary anchors in the field value.",

"confidence": "medium"

},

{

"field": "opportunity_summary_table.5.reasoning",

"citations": [

{

"title": "gnzlbg/bitintr: Portable Bitwise Manipulation Intrinsics",

"url": "https://github.com/gnzlbg/bitintr",

"excerpts": [

"This #![no_std] library exposes safe and portable low-level bit
manipulation instruction set architectures. The Minimum Supported Rust
Version is 1.36.0.",

"The intrinsics are exposed via traits named after their CPU
instruction. These\ntraits are implemented for all integer types
*except* `u128/i128`.",

"This `#![no_std]` library exposes *safe* and *portable* low-level bit
manipulation\ninstruction set architectures.",

"Licensed under the [MIT
license](https://github.com/gnzlbg/bitintr/blob/master/license.md)."

]

},

{

"title": "Bitintr crate - Rust crates.io",

"url": "https://crates.io/crates/bitintr",

"excerpts": [

"This `#![no_std]` library exposes *safe* and *portable* low-level bit
manipulation\ninstruction set architectures. The Minimum Supported Rust
Version is 1.36.0.",

"The intrinsics are exposed via traits named after their CPU
instruction.",

"#! [no_std] library exposes safe and portable low-level bit
manipulation\ninstruction set architectures.",

"The intrinsics are exposed via traits named after their CPU
instruction. These traits are implemented for all integer types except
u128/i128 ",

"Licensed under the [MIT
license](https://github.com/gnzlbg/bitintr/blob/master/license.md)."

]

},

{

"title": "Bitintr 0.3.0 Documentation and Repository",

"url": "http://docs.rs/bitintr/latest/bitintr",

"excerpts": [

"The intrinsics are exposed via traits named after their CPU
instruction.",

"This `#![no_std]` library exposes *safe* and *portable* low-level bit
manipulation\ninstruction set architectures."

]

},

{

"title": "bitintr 0.3.0 - Docs.rs",

"url": "http://docs.rs/bitintr/0.3.0/bitintr",

"excerpts": [

"The intrinsics are exposed via traits named after their CPU
instruction. These\ntraits are implemented for all integer types
*except* `u128/i128`.",

"The intrinsics are exposed via traits named after their CPU
instruction. These\ntraits are implemented for all integer types
*except* `u128/i128`.",

"This `#![no_std]` library exposes *safe* and *portable* low-level bit
manipulation\ninstruction set architectures.",

"Licensed under the [MIT
license](https://github.com/gnzlbg/bitintr/blob/master/license.md)."

]

},

{

"title": "bitintr - Rust",

"url": "https://gnzlbg.github.io/bitintr/",

"excerpts": [

"bitintr offers portable bit manipulation intrinsics (@github,
@crates.io). The intrinsics are named after their CPU instruction and
organized in modules ..."

]

}

],

"reasoning": "The field value describes addressing gaps in a
portable-simd project by offering ergonomic, optimized wrappers for
fundamental SIMD operations (e.g., horizontal reductions, swizzles). The
excerpts collectively discuss a Rust crate that exposes portable,
low-level bit manipulation intrinsics in a safe, no_std, trait-based
interface, which is directly aligned with the notion of portable,
reusable SIMD primitives and ergonomic access. This demonstrates a
precedent and pattern for implementing portable SIMD-related utilities
in Rust, including safe abstraction over architecture-specific
intrinsics and cross-crate ergonomics. Specifically, the material
highlights: a portable set of bit manipulation intrinsics exposed safely
and portably, with a focus on traits and a platform-agnostic surface;
the no_std direction indicating minimal runtime requirements; and
explicit emphasis on safe, portable access to CPU-specific instructions.
While these excerpts do not mention portable-simd gaps or a helper crate
explicitly, they substantiate the feasibility and architectural approach
of building small, high-utility crates that encapsulate low-level
SIMD-like functionality in a portable and ergonomic way, which is
directly relevant to the proposed `portable-simd` helper crate and the
target use cases (DSP, image processing, scientific computing). They
provide concrete evidence of the kinds of design patterns (trait-based
exposure, safe abstractions, portability) that could be repurposed to
address the gaps described in the finegrained field value.",

"confidence": "medium"

},

{

"field": "opportunity_summary_table.5.opportunity_name",

"citations": [

{

"title": "gnzlbg/bitintr: Portable Bitwise Manipulation Intrinsics",

"url": "https://github.com/gnzlbg/bitintr",

"excerpts": [

"This #![no_std] library exposes safe and portable low-level bit
manipulation instruction set architectures. The Minimum Supported Rust
Version is 1.36.0.",

"The intrinsics are exposed via traits named after their CPU
instruction. These\ntraits are implemented for all integer types
*except* `u128/i128`.",

"This `#![no_std]` library exposes *safe* and *portable* low-level bit
manipulation\ninstruction set architectures.",

"Licensed under the [MIT
license](https://github.com/gnzlbg/bitintr/blob/master/license.md)."

]

},

{

"title": "bitintr 0.3.0 - Docs.rs",

"url": "http://docs.rs/bitintr/0.3.0/bitintr",

"excerpts": [

"The intrinsics are exposed via traits named after their CPU
instruction. These\ntraits are implemented for all integer types
*except* `u128/i128`.",

"The intrinsics are exposed via traits named after their CPU
instruction. These\ntraits are implemented for all integer types
*except* `u128/i128`.",

"This `#![no_std]` library exposes *safe* and *portable* low-level bit
manipulation\ninstruction set architectures.",

"Licensed under the [MIT
license](https://github.com/gnzlbg/bitintr/blob/master/license.md)."

]

},

{

"title": "bitintr - Rust",

"url": "https://gnzlbg.github.io/bitintr/",

"excerpts": [

"bitintr offers portable bit manipulation intrinsics (@github,
@crates.io). The intrinsics are named after their CPU instruction and
organized in modules ..."

]

},

{

"title": "Bitintr crate - Rust crates.io",

"url": "https://crates.io/crates/bitintr",

"excerpts": [

"This `#![no_std]` library exposes *safe* and *portable* low-level bit
manipulation\ninstruction set architectures. The Minimum Supported Rust
Version is 1.36.0.",

"The intrinsics are exposed via traits named after their CPU
instruction. These traits are implemented for all integer types except
u128/i128 ",

"#! [no_std] library exposes safe and portable low-level bit
manipulation\ninstruction set architectures.",

"The intrinsics are exposed via traits named after their CPU
instruction.",

"Licensed under the [MIT
license](https://github.com/gnzlbg/bitintr/blob/master/license.md)."

]

},

{

"title": "Bitintr 0.3.0 Documentation and Repository",

"url": "http://docs.rs/bitintr/latest/bitintr",

"excerpts": [

"The intrinsics are exposed via traits named after their CPU
instruction.",

"This `#![no_std]` library exposes *safe* and *portable* low-level bit
manipulation\ninstruction set architectures."

]

}

],

"reasoning": "The most directly relevant excerpts describe a Rust crate
that exposes safe and portable low-level bit manipulation intrinsics,
which are the building blocks for any SIMD-related tooling that requires
cross-architecture support. These excerpts emphasize portability, no_std
environments, and traits implemented for multiple integer types, which
align with the idea of micro-helpers that abstract over CPU
instructions. Additional excerpts reinforce the portable intrinsic theme
and describe the library's scope and licensing, which supports the
feasibility and adoption of such a micro-helper in the ecosystem. Even
though the exact term 'Portable SIMD Micro-Helpers' is not used, the
persevering through cross-CPU intrinsic abstractions and safe, portable
interfaces directly underpins the potential for small, high-impact
SIMD-related crates. Less directly relevant pieces are generic crate
descriptions or licensing details, which provide context but do not
specifically illuminate the SIMD-oriented opportunity. Overall, the
strongest support comes from explicit statements about portable,
low-level intrinsics and their safe, cross-architecture exposure;
subsequent excerpts add corroborating detail about the nature of such
internals and ecosystem considerations.",

"confidence": "medium"

},

{

"field": "opportunity_summary_table.5.pmf_probability_score",

"citations": [

{

"title": "gnzlbg/bitintr: Portable Bitwise Manipulation Intrinsics",

"url": "https://github.com/gnzlbg/bitintr",

"excerpts": [

"This #![no_std] library exposes safe and portable low-level bit
manipulation instruction set architectures. The Minimum Supported Rust
Version is 1.36.0.",

"The intrinsics are exposed via traits named after their CPU
instruction. These\ntraits are implemented for all integer types
*except* `u128/i128`.",

"This `#![no_std]` library exposes *safe* and *portable* low-level bit
manipulation\ninstruction set architectures.",

"Licensed under the [MIT
license](https://github.com/gnzlbg/bitintr/blob/master/license.md)."

]

},

{

"title": "bitintr - Rust",

"url": "https://gnzlbg.github.io/bitintr/",

"excerpts": [

"bitintr offers portable bit manipulation intrinsics (@github,
@crates.io). The intrinsics are named after their CPU instruction and
organized in modules ..."

]

},

{

"title": "bitintr 0.3.0 - Docs.rs",

"url": "http://docs.rs/bitintr/0.3.0/bitintr",

"excerpts": [

"The intrinsics are exposed via traits named after their CPU
instruction. These\ntraits are implemented for all integer types
*except* `u128/i128`.",

"The intrinsics are exposed via traits named after their CPU
instruction. These\ntraits are implemented for all integer types
*except* `u128/i128`.",

"This `#![no_std]` library exposes *safe* and *portable* low-level bit
manipulation\ninstruction set architectures.",

"Licensed under the [MIT
license](https://github.com/gnzlbg/bitintr/blob/master/license.md)."

]

},

{

"title": "Bitintr crate - Rust crates.io",

"url": "https://crates.io/crates/bitintr",

"excerpts": [

"This `#![no_std]` library exposes *safe* and *portable* low-level bit
manipulation\ninstruction set architectures. The Minimum Supported Rust
Version is 1.36.0.",

"The intrinsics are exposed via traits named after their CPU
instruction. These traits are implemented for all integer types except
u128/i128 ",

"The intrinsics are exposed via traits named after their CPU
instruction.",

"#! [no_std] library exposes safe and portable low-level bit
manipulation\ninstruction set architectures.",

"Licensed under the [MIT
license](https://github.com/gnzlbg/bitintr/blob/master/license.md)."

]

},

{

"title": "Bitintr 0.3.0 Documentation and Repository",

"url": "http://docs.rs/bitintr/latest/bitintr",

"excerpts": [

"The intrinsics are exposed via traits named after their CPU
instruction.",

"This `#![no_std]` library exposes *safe* and *portable* low-level bit
manipulation\ninstruction set architectures."

]

}

],

"reasoning": "The fine-grained field value targets a high PMF
(probability of a strong opportunity) for Rust-based 300 LOC libraries
in the Open Source CPU domain. Excerpts that emphasize a concrete Rust
library for portable, safe, and low-level bit manipulation strongly
indicate a viable, well-scoped opportunity area where succinct,
high-impact crates could excel. The most relevant excerpts describe a
no_std library that exposes safe and portable bit manipulation
intrinsics and architectures, which directly aligns with a class of
compact, highly useful libraries that are broadly reusable across
systems programming, embedded contexts, and performance-critical code.
This supports the notion that there exists meaningful demand and a
clear, finishable scope (short, targeted libraries) in this space.
Additional excerpts reinforce the same signal by noting the intrinsics
are exposed via CPU-instruction-named traits and that the project is
distributed as a crates.io crate with documentation, licensing, and
clearly defined scope, which further substantiates a high likelihood of
adoption and reuse in the ecosystem. Collectively, the cited content
demonstrates a real, existing pattern of small, practical, and portable
low-level Rust crates, which strengthens the assessment that a high-PMF
opportunity exists for similarly scoped 300 LOC libraries in this
domain. The presence of no_std compatibility, portability across
architectures, and a clear domain (bit manipulation intrinsics) provide
strong, coherent support for a high confidence in the PMF score. A more
tangential but supportive point is that documentation and licensing are
explicit, indicating a healthy maintenance and reuse potential for new
libraries in the same family, which complements the primary signal.
Overall, the strongest support comes from the explicit focus on safe,
portable intrinsics in a no_std context, followed by corroborating notes
about traits, CPU-instruction naming, and ecosystem presence, all of
which align with a high-probability opportunity profile for compact,
impactful Rust crates in the CPU domain.",

"confidence": "high"

},

{

"field": "opportunity_summary_table.0.opportunity_name",

"citations": [

{

"title": "bitintr - Rust",

"url": "https://gnzlbg.github.io/bitintr/",

"excerpts": [

"bitintr offers portable bit manipulation intrinsics (@github,
@crates.io). The intrinsics are named after their CPU instruction and
organized in modules ..."

]

},

{

"title": "gnzlbg/bitintr: Portable Bitwise Manipulation Intrinsics",

"url": "https://github.com/gnzlbg/bitintr",

"excerpts": [

"This `#![no_std]` library exposes *safe* and *portable* low-level bit
manipulation\ninstruction set architectures.",

"Portable Bitwise Manipulation Intrinsics",

"Portable Bitwise Manipulation Intrinsics",

"The intrinsics are exposed via traits named after their CPU
instruction. These\ntraits are implemented for all integer types
*except* `u128/i128`."

]

},

{

"title": "Bitintr 0.3.0 Documentation and Repository",

"url": "http://docs.rs/bitintr/latest/bitintr",

"excerpts": [

"This `#![no_std]` library exposes *safe* and *portable* low-level bit
manipulation\ninstruction set architectures.",

"The intrinsics are exposed via traits named after their CPU
instruction."

]

},

{

"title": "bitintr 0.3.0 - Docs.rs",

"url": "http://docs.rs/bitintr/0.3.0/bitintr",

"excerpts": [

"This `#![no_std]` library exposes *safe* and *portable* low-level bit
manipulation\ninstruction set architectures.",

"The intrinsics are exposed via traits named after their CPU
instruction. These\ntraits are implemented for all integer types
*except* `u128/i128`.",

"The intrinsics are exposed via traits named after their CPU
instruction. These\ntraits are implemented for all integer types
*except* `u128/i128`."

]

},

{

"title": "Bitintr crate - Rust crates.io",

"url": "https://crates.io/crates/bitintr",

"excerpts": [

"28/i128 . The following ISAs are implemented:\n * x86 (\nbitintr::x86
):\n * ABM : Advanced Bit Manipulation instructions (\nbitintr::x86::abm
). * TBM : Trailing Bit Manipulation instructions (\nbitintr::x86::tbm
). * BMI : Bit Manipulation Instruction Set 1.0 (\nbitintr::x86::bmi ).
* BMI2 : Bit Manipulation Instruction Set 2.0 (\nbitintr::x86::bmi2 ). *
ARM (\nbitintr::arm ):\n * ARMv5 :\nbitintr::arm::v5 . * ARMv6
:\nbitintr::arm::v6 . * ARMv7 :\nbitintr::arm::v7 . * ARMv8
:\nbitintr::arm::v8 . The actual code generated depends on the integer
types involved and the features\nsupported by the target architecture.",

"#! [no_std] library exposes safe and portable low-level bit
manipulation\ninstruction set architectures.",

"The intrinsics are exposed via traits named after their CPU
instruction. These traits are implemented for all integer types except
u128/i128 ",

"The intrinsics are exposed via traits named after their CPU
instruction."

]

},

{

"title": "has_fast_pdep crate page",

"url": "https://crates.io/crates/has_fast_pdep",

"excerpts": [

"A single-function, `no-std` library that returns `true` if the current
CPU implements PDEP and PEXT with fast, non-microcoded hardware.",

"Rationale\n---------\n\nZen, Zen+, Zen 2, and Hygon Dhyana CPUs
implement PDEP and PEXT using microcode in a way that makes them slower
than well-optimized, non-intrinsic fallbacks. In performance-critical
code, checking for BMI2 support isn't enough—you could end up hurting
performance on said CPUs where these instructions exist but are slow.
This crate helps you avoid that by detecting speed, not just support.",

"The result of the hardware check is determined once at runtime. After
the initial check, all future\ncalls to `has_fast_pdep` becomes a simple
`true` or `false` with zero branching or logic. On x86 targets, CPUID is
used directly without probing for its existence. This is intentional.",

"You can view the documentation on docs.rs
[here](https://docs.rs/has_fast_pdep).",

"Rationale\n---------\n\nZen, Zen+, Zen 2, and Hygon Dhyana CPUs
implement PDEP and PEXT using microcode in a way that makes them slower
than well-optimized, non-intrinsic fallbacks. In performance-critical
code, checking for BMI2 support isn't enough—you could end up hurting
performance on said CPUs where these instructions exist but are slow.
This crate helps you avoid that by detecting speed, not just support",

"Implementation Details\n----------------------\n\nThe result of the
hardware check is determined once at runtime. After the initial check,
all future\ncalls to `has_fast_pdep` becomes a simple `true` or `false`
with zero branching or logic.",

"Detect fast hardware support for PDEP/PEXT."

]

}

],

"reasoning": "The field value points to a compact, modern Rust crate
that offers portable bit-twiddling capabilities. Excerpts describing a
no-std, portable bit manipulation intrinsics library directly map to the
core idea of a small, cross-ISA crate that exposes
CPU-instruction-aligned operations in Rust. Specifically, a crate
described as \"Portable Bitwise Manipulation Intrinsics\" with a no_std
footprint and cross-ISA trait-based exposure aligns with the concept of
a modern, portable bit-twiddling microcrate. Additional excerpts
emphasize the library's safe abstractions over low-level bit-instruction
sets and the breadth of ISAs supported (x86, BMI, BMI2, ARM variants),
which reinforces the portability and minimalism that such a microcrate
would aim for. The presence of a no_std, portable interface and the
explicit enumeration of ISA targets illustrate how a small, high-utility
crate could fill a gap in the ecosystem for efficient bit manipulation
primitives, matching the envisioned opportunity. Contextual excerpts on
related micro-level facilities (e.g., a dedicated, fast-path hardware
check for PDEP/PEXT) further underscore the broader relevance of
bit-twiddling primitives in Rust ecosystems, though they are slightly
more specialized than the core microcrate idea. Overall, the strongest
support comes from descriptions of a portable, no_std bit manipulation
crate with instrumented ISA coverage, followed by mentions of the
general category of lightweight bit-intrinsics libraries.",

"confidence": "high"

},

{

"field": "opportunity_summary_table.6",

"citations": [

{

"title": "has_fast_pdep crate page",

"url": "https://crates.io/crates/has_fast_pdep",

"excerpts": [

"Implementation Details\n----------------------\n\nThe result of the
hardware check is determined once at runtime. After the initial check,
all future\ncalls to `has_fast_pdep` becomes a simple `true` or `false`
with zero branching or logic.",

"pkg:cargo/has\\_fast\\_pdep@0.1.3",

"Rationale\n---------\n\nZen, Zen+, Zen 2, and Hygon Dhyana CPUs
implement PDEP and PEXT using microcode in a way that makes them slower
than well-optimized, non-intrinsic fallbacks. In performance-critical
code, checking for BMI2 support isn't enough—you could end up hurting
performance on said CPUs where these instructions exist but are slow.
This crate helps you avoid that by detecting speed, not just support.",

"You can view the documentation on docs.rs
[here](https://docs.rs/has_fast_pdep).",

"Rationale\n---------\n\nZen, Zen+, Zen 2, and Hygon Dhyana CPUs
implement PDEP and PEXT using microcode in a way that makes them slower
than well-optimized, non-intrinsic fallbacks. In performance-critical
code, checking for BMI2 support isn't enough—you could end up hurting
performance on said CPUs where these instructions exist but are slow.
This crate helps you avoid that by detecting speed, not just support",

"Detect fast hardware support for PDEP/PEXT.",

"3 months ago",

"The result of the hardware check is determined once at runtime. After
the initial check, all future\ncalls to `has_fast_pdep` becomes a simple
`true` or `false` with zero branching or logic. On x86 targets, CPUID is
used directly without probing for its existence. This is intentional.",

"has_fast_pdep = \"0.1\"",

"A single-function, `no-std` library that returns `true` if the current
CPU implements PDEP and PEXT with fast, non-microcoded hardware."

]

},

{

"title": "gnzlbg/bitintr: Portable Bitwise Manipulation Intrinsics",

"url": "https://github.com/gnzlbg/bitintr",

"excerpts": [

"This #![no_std] library exposes safe and portable low-level bit
manipulation instruction set architectures. The Minimum Supported Rust
Version is 1.36.0.",

"The intrinsics are exposed via traits named after their CPU
instruction. These\ntraits are implemented for all integer types
*except* `u128/i128`.",

" +
[`ABM`](https://en.wikipedia.org/wiki/Bit_Manipulation_Instruction_Sets.28Advanced_Bit_Manipulation.29):
Advanced Bit Manipulation instructions
([`bitintr::x86::abm`](https://gnzlbg.github.io/bitintr/bitintr/x86/abm/index.html)).",

" +
[`TBM`](https://en.wikipedia.org/wiki/Bit_Manipulation_Instruction_Sets.28Trailing_Bit_Manipulation.29):
Trailing Bit Manipulation instructions
([`bitintr::x86::tbm`](https://gnzlbg.github.io/bitintr/bitintr/x86/tbm/index.html)).",

"This `#![no_std]` library exposes *safe* and *portable* low-level bit
manipulation\ninstruction set architectures.",

"Licensed under the [MIT
license](https://github.com/gnzlbg/bitintr/blob/master/license.md)."

]

},

{

"title": "bitintr - Rust",

"url": "https://gnzlbg.github.io/bitintr/",

"excerpts": [

"bitintr offers portable bit manipulation intrinsics (@github,
@crates.io). The intrinsics are named after their CPU instruction and
organized in modules ..."

]

},

{

"title": "bitintr 0.3.0 - Docs.rs",

"url": "http://docs.rs/bitintr/0.3.0/bitintr",

"excerpts": [

"The intrinsics are exposed via traits named after their CPU
instruction. These\ntraits are implemented for all integer types
*except* `u128/i128`.",

"The intrinsics are exposed via traits named after their CPU
instruction. These\ntraits are implemented for all integer types
*except* `u128/i128`.",

" +
[`ABM`](https://en.wikipedia.org/wiki/Bit_Manipulation_Instruction_Sets.28Advanced_Bit_Manipulation.29):
Advanced Bit Manipulation instructions
([`bitintr::x86::abm`](https://gnzlbg.github.io/bitintr/bitintr/x86/abm/index.html)).",

"This `#![no_std]` library exposes *safe* and *portable* low-level bit
manipulation\ninstruction set architectures.",

"Licensed under the [MIT
license](https://github.com/gnzlbg/bitintr/blob/master/license.md)."

]

},

{

"title": "Bitintr crate - Rust crates.io",

"url": "https://crates.io/crates/bitintr",

"excerpts": [

"This `#![no_std]` library exposes *safe* and *portable* low-level bit
manipulation\ninstruction set architectures. The Minimum Supported Rust
Version is 1.36.0.",

"The intrinsics are exposed via traits named after their CPU
instruction. These traits are implemented for all integer types except
u128/i128 ",

"#! [no_std] library exposes safe and portable low-level bit
manipulation\ninstruction set architectures.",

"These traits are implemented for all integer types except u128/i128 .",

"28/i128 . The following ISAs are implemented:\n * x86 (\nbitintr::x86
):\n * ABM : Advanced Bit Manipulation instructions (\nbitintr::x86::abm
). * TBM : Trailing Bit Manipulation instructions (\nbitintr::x86::tbm
). * BMI : Bit Manipulation Instruction Set 1.0 (\nbitintr::x86::bmi ).
* BMI2 : Bit Manipulation Instruction Set 2.0 (\nbitintr::x86::bmi2 ). *
ARM (\nbitintr::arm ):\n * ARMv5 :\nbitintr::arm::v5 . * ARMv6
:\nbitintr::arm::v6 . * ARMv7 :\nbitintr::arm::v7 . * ARMv8
:\nbitintr::arm::v8 . The actual code generated depends on the integer
types involved and the features\nsupported by the target architecture.",

"The intrinsics are exposed via traits named after their CPU
instruction.",

"Licensed under the [MIT
license](https://github.com/gnzlbg/bitintr/blob/master/license.md)."

]

},

{

"title": "Bitintr 0.3.0 Documentation and Repository",

"url": "http://docs.rs/bitintr/latest/bitintr",

"excerpts": [

"The intrinsics are exposed via traits named after their CPU
instruction.",

"This `#![no_std]` library exposes *safe* and *portable* low-level bit
manipulation\ninstruction set architectures."

]

},

{

"title": "Bit Twiddling Hacks",

"url": "https://graphics.stanford.edu/~seander/bithacks.html",

"excerpts": [

"Bit Twiddling Hacks",

"\nBy Sean Eron Anderson seander@cs.stanford.edu Individually, the code
snippets here are in the public domain (unless otherwise noted) — feel
free to use them however you please. The aggregate collection and
descriptions are © 1997-2005 Sean Eron Anderson. The code and
descriptions are distributed in the hope that they will be useful,",

"The code and descriptions are distributed in the hope that they will be
useful,\nbut WITHOUT ANY WARRANTY and without even the implied warranty
of\nmerchantability or fitness for a particular purpose.",

"Bit Twiddling Hacks. By Sean Eron Anderson seander@cs.stanford.edu.
Individually, the code snippets here are in the public domain (unless
otherwise noted) ... Bit Twiddling Hack",

"As of May 5, 2005, all the code has been tested thoroughly. Thousands
of\npeople have read it.",

"n and\ncountbetween on April 10, 2005. Compute the lexicographically
next bit permutation Suppose we have a pattern of N bits set to 1 in an
integer and we want the next permutation of N 1 bits in a
lexicographical sense. For example, if N is 3 and the bit pattern is
00010011, the next patterns would be 00010101, 00010110,
00011001,00011010, 00011100, 00100011, and so forth. The following is a
fast way to compute the next permutation. unsigned int v; // current
permutation of bits unsigned int w;",

"unsigned int t = v | (v - 1); // t gets v's least significant 0 bits
set to 1\n// Next set to 1 the most significant bit to change, // set to
0 the least significant ones, and add the necessary 1 bits.",

"What he hasn't tested, I have checked against all\npossible inputs on a
32-bit machine.",

"int y; int r; // the result goes here r = y ^ ((x ^ y) & -(x < y)); //
min(x, y)",

"To find the maximum, use:\nr = x ^ ((x ^ y) & -(x < y)); // max(x, y)",

"Quick and dirty versions: If you know that INT_MIN <= x - y <=
INT_MAX,\nthen you can use the following, which are faster because (x -
y) only needs to be evaluated once. r = y + ((x - y) & ((x - y) >>
(sizeof(int) * CHAR_BIT - 1))); // min(x, y)",

"r = x - ((x - y) & ((x - y) >> (sizeof(int) * CHAR_BIT - 1))); //
max(x, y) Note that the 1989 ANSI C specification doesn't specify the
result of signed right-shift, so these aren't portable.",

"r = x ^ ((x ^ y) & -(x < y)); // max(x, y)",

"The naive approach requires one iteration per bit, until no more bits
are set. So on a 32-bit word with only the high set, it will go through
32 iterations. Compute the minimum (min) or maximum (max) of two
integers without branching",

"r = y + ((x - y) & ((x - y) >> (sizeof(int) * CHAR_BIT - 1))); //
min(x, y)",

"Compute the minimum (min) or maximum (max) of two integers without
branching\nint x; // we want to find the minimum of x and y\nint y; int
r; // the result goes here r = y ^ ((x ^ y) & -(x < y)); // min(x, y) On
some rare machines where branching is very expensive and no
condition\nmove instructions exist, the above expression\nmight be
faster than the obvious approach, r = (x < y) ? x : y, even though it
involves two more instructions. (Typically, the obvious approach is
best, though.) It works because if x < y, then -(x < y) will be all
ones, so r = y ^ (x ^ y) & ~0 = y ^ x ^ y = x. Otherwise, if x >= y,
then -(x < y) will be all zeros, so r = y ^ ((x ^ y) & 0) = y. On some
machines, evaluating (x < y) as 0 or 1 requires a branch instruction, so
there may be n",

"It works because if x < y, then -(x < y) will be all ones, so r = y ^
(x ^ y) & ~0 = y ^ x ^ y = x. Otherwise, if x >= y, then -(x < y) will
be all zeros, so r = y ^ ((x ^ y) & 0) = y.",

"Bit Twiddling Hacks. By Sean Eron Anderson",

"r = y ^ ((x ^ y) & -(x < y)); // min(x, y)",

"The method first shifts and XORs the eight nibbles of the 32-bit value
together, leaving the result in the lowest nibble of v. Next, the binary
number 0110 ..."

]

},

{

"title": "Bit-twiddling crates and references in the provided source",

"url": "https://docs.rs/tinybitset",

"excerpts": [

"One unique feature of this crate is that it uses const generics to have
a single generic bitset type whose size and underlying storage type can
be chosen with ... tinybitset 0.0.2\n ",

"One unique feature of this crate is that it uses const generics to have
a single generic bitset type whose size and underlying storage type can
be chosen with ... tinybitset 0.0.2\n "

]

}

],

"reasoning": "The requested minimal CPU feature-detection crate
emphasizes lightweight, cross-platform, no_std-first design that detects
essential CPU capabilities at runtime (CPUID on x86, auxv on Linux,
sysctl on macOS). The most directly relevant material discusses
runtime/hardware checks and the tradeoffs of fast-path detection for
specific instructions (for example, PDEP/PEXT) and the need to balance
between broad compatibility and performance. These sources describe how
detection can be implemented with minimal overhead, including runtime
checks that yield a simple boolean result after an initial probe, which
aligns with the concept of a minimal feature detector. Additionally,
documentation about portable, no_std bit manipulation crates
demonstrates the ecosystem's emphasis on small, cross-platform,
low-level interfaces, which supports building a small feature-detection
crate as a lean, reusable component rather than a large,
dependency-heavy one. Practical references provided in these excerpts
(Intel manuals, Linux getauxval, and the cpufeatures-like crates) give
concrete avenues for implementing such a detector across platforms,
which directly informs the design and verification strategy for a
minimal detector crate. Overall, the strongest support comes from
discussions of runtime detection logic and pragmatic cross-platform
constraints, with secondary support from no_std, portable crate design
patterns that accompany such functionality.",

"confidence": "medium"

},

{

"field": "opportunity_summary_table.0.reasoning",

"citations": [

{

"title": "gnzlbg/bitintr: Portable Bitwise Manipulation Intrinsics",

"url": "https://github.com/gnzlbg/bitintr",

"excerpts": [

"This `#![no_std]` library exposes *safe* and *portable* low-level bit
manipulation\ninstruction set architectures.",

"Portable Bitwise Manipulation Intrinsics",

"Portable Bitwise Manipulation Intrinsics",

"The intrinsics are exposed via traits named after their CPU
instruction. These\ntraits are implemented for all integer types
*except* `u128/i128`.",

"This #![no_std] library exposes safe and portable low-level bit
manipulation instruction set architectures. The Minimum Supported Rust
Version is 1.36.0.",

"Licensed under the [MIT
license](https://github.com/gnzlbg/bitintr/blob/master/license.md)."

]

},

{

"title": "Bitintr 0.3.0 Documentation and Repository",

"url": "http://docs.rs/bitintr/latest/bitintr",

"excerpts": [

"This `#![no_std]` library exposes *safe* and *portable* low-level bit
manipulation\ninstruction set architectures.",

"The intrinsics are exposed via traits named after their CPU
instruction."

]

},

{

"title": "bitintr 0.3.0 - Docs.rs",

"url": "http://docs.rs/bitintr/0.3.0/bitintr",

"excerpts": [

"This `#![no_std]` library exposes *safe* and *portable* low-level bit
manipulation\ninstruction set architectures.",

"The intrinsics are exposed via traits named after their CPU
instruction. These\ntraits are implemented for all integer types
*except* `u128/i128`.",

"The intrinsics are exposed via traits named after their CPU
instruction. These\ntraits are implemented for all integer types
*except* `u128/i128`.",

"Licensed under the [MIT
license](https://github.com/gnzlbg/bitintr/blob/master/license.md)."

]

},

{

"title": "Bitintr crate - Rust crates.io",

"url": "https://crates.io/crates/bitintr",

"excerpts": [

"The intrinsics are exposed via traits named after their CPU
instruction.",

"28/i128 . The following ISAs are implemented:\n * x86 (\nbitintr::x86
):\n * ABM : Advanced Bit Manipulation instructions (\nbitintr::x86::abm
). * TBM : Trailing Bit Manipulation instructions (\nbitintr::x86::tbm
). * BMI : Bit Manipulation Instruction Set 1.0 (\nbitintr::x86::bmi ).
* BMI2 : Bit Manipulation Instruction Set 2.0 (\nbitintr::x86::bmi2 ). *
ARM (\nbitintr::arm ):\n * ARMv5 :\nbitintr::arm::v5 . * ARMv6
:\nbitintr::arm::v6 . * ARMv7 :\nbitintr::arm::v7 . * ARMv8
:\nbitintr::arm::v8 . The actual code generated depends on the integer
types involved and the features\nsupported by the target architecture.",

"#! [no_std] library exposes safe and portable low-level bit
manipulation\ninstruction set architectures.",

"The intrinsics are exposed via traits named after their CPU
instruction. These traits are implemented for all integer types except
u128/i128 ",

"Licensed under the [MIT
license](https://github.com/gnzlbg/bitintr/blob/master/license.md)."

]

},

{

"title": "bitintr - Rust",

"url": "https://gnzlbg.github.io/bitintr/",

"excerpts": [

"bitintr offers portable bit manipulation intrinsics (@github,
@crates.io). The intrinsics are named after their CPU instruction and
organized in modules ..."

]

},

{

"title": "has_fast_pdep crate page",

"url": "https://crates.io/crates/has_fast_pdep",

"excerpts": [

"A single-function, `no-std` library that returns `true` if the current
CPU implements PDEP and PEXT with fast, non-microcoded hardware.",

"Rationale\n---------\n\nZen, Zen+, Zen 2, and Hygon Dhyana CPUs
implement PDEP and PEXT using microcode in a way that makes them slower
than well-optimized, non-intrinsic fallbacks. In performance-critical
code, checking for BMI2 support isn't enough—you could end up hurting
performance on said CPUs where these instructions exist but are slow.
This crate helps you avoid that by detecting speed, not just support.",

"Rationale\n---------\n\nZen, Zen+, Zen 2, and Hygon Dhyana CPUs
implement PDEP and PEXT using microcode in a way that makes them slower
than well-optimized, non-intrinsic fallbacks. In performance-critical
code, checking for BMI2 support isn't enough—you could end up hurting
performance on said CPUs where these instructions exist but are slow.
This crate helps you avoid that by detecting speed, not just support",

"Implementation Details\n----------------------\n\nThe result of the
hardware check is determined once at runtime. After the initial check,
all future\ncalls to `has_fast_pdep` becomes a simple `true` or `false`
with zero branching or logic.",

"Detect fast hardware support for PDEP/PEXT."

]

}

],

"reasoning": "The target field emphasizes a crate that fills a gap by
providing a safe, dependency-free, no_std solution for high-demand
bit-manipulation primitives like PDEP/PEXT and Morton coding, and that
is suitable for WASM or native builds. Excerpts describing a crate that
offers portable, low-level bit manipulation intrinsics in a no_std
context directly support the core of this field value. They indicate a
design focus on safe, portable interfaces for CPU-specific instructions
and a broad ISA coverage, which aligns with the desired goal of a small,
high-value Rust library that can be broadly used in graphics,
compression, and cryptography workflows. Discussions of the minimum
supported Rust version and architecture-specific modules further
reinforce the no_std, cross-target nature of the library, which matches
the requirement for dependency-free and broad portability. In addition,
related material about detecting fast PDEP/PEXT capabilities (rather
than just support) underscores the practical importance of PDEP/PEXT in
performance-critical code, which is central to the field value's
emphasis on highly demanded primitives absent from std. Taken together,
these excerpts substantiate the connectivity between a minimal,
portable, no_std bit-manipulation crate and the described gap-filling
opportunity, while also highlighting practical considerations for
PDEP/PEXT usage and performance characteristics that would drive the
library's design and testing strategy.",

"confidence": "medium"

},

{

"field": "opportunity_summary_table.0.relevant_artifacts_links",

"citations": [

{

"title": "bitintr - Rust",

"url": "https://gnzlbg.github.io/bitintr/",

"excerpts": [

"bitintr offers portable bit manipulation intrinsics (@github,
@crates.io). The intrinsics are named after their CPU instruction and
organized in modules ..."

]

},

{

"title": "gnzlbg/bitintr: Portable Bitwise Manipulation Intrinsics",

"url": "https://github.com/gnzlbg/bitintr",

"excerpts": [

"The intrinsics are exposed via traits named after their CPU
instruction. These\ntraits are implemented for all integer types
*except* `u128/i128`.",

"This `#![no_std]` library exposes *safe* and *portable* low-level bit
manipulation\ninstruction set architectures.",

"This #![no_std] library exposes safe and portable low-level bit
manipulation instruction set architectures. The Minimum Supported Rust
Version is 1.36.0.",

"Portable Bitwise Manipulation Intrinsics",

"Portable Bitwise Manipulation Intrinsics",

"Licensed under the [MIT
license](https://github.com/gnzlbg/bitintr/blob/master/license.md)."

]

},

{

"title": "bitintr 0.3.0 - Docs.rs",

"url": "http://docs.rs/bitintr/0.3.0/bitintr",

"excerpts": [

"The intrinsics are exposed via traits named after their CPU
instruction. These\ntraits are implemented for all integer types
*except* `u128/i128`.",

"The intrinsics are exposed via traits named after their CPU
instruction. These\ntraits are implemented for all integer types
*except* `u128/i128`.",

"This `#![no_std]` library exposes *safe* and *portable* low-level bit
manipulation\ninstruction set architectures.",

"Licensed under the [MIT
license](https://github.com/gnzlbg/bitintr/blob/master/license.md)."

]

},

{

"title": "Bitintr 0.3.0 Documentation and Repository",

"url": "http://docs.rs/bitintr/latest/bitintr",

"excerpts": [

"This `#![no_std]` library exposes *safe* and *portable* low-level bit
manipulation\ninstruction set architectures.",

"The intrinsics are exposed via traits named after their CPU
instruction."

]

},

{

"title": "Bitintr crate - Rust crates.io",

"url": "https://crates.io/crates/bitintr",

"excerpts": [

"The intrinsics are exposed via traits named after their CPU
instruction.",

"28/i128 . The following ISAs are implemented:\n * x86 (\nbitintr::x86
):\n * ABM : Advanced Bit Manipulation instructions (\nbitintr::x86::abm
). * TBM : Trailing Bit Manipulation instructions (\nbitintr::x86::tbm
). * BMI : Bit Manipulation Instruction Set 1.0 (\nbitintr::x86::bmi ).
* BMI2 : Bit Manipulation Instruction Set 2.0 (\nbitintr::x86::bmi2 ). *
ARM (\nbitintr::arm ):\n * ARMv5 :\nbitintr::arm::v5 . * ARMv6
:\nbitintr::arm::v6 . * ARMv7 :\nbitintr::arm::v7 . * ARMv8
:\nbitintr::arm::v8 . The actual code generated depends on the integer
types involved and the features\nsupported by the target architecture.",

"The intrinsics are exposed via traits named after their CPU
instruction. These traits are implemented for all integer types except
u128/i128 ",

"#! [no_std] library exposes safe and portable low-level bit
manipulation\ninstruction set architectures.",

"Licensed under the [MIT
license](https://github.com/gnzlbg/bitintr/blob/master/license.md)."

]

},

{

"title": "has_fast_pdep crate page",

"url": "https://crates.io/crates/has_fast_pdep",

"excerpts": [

"A single-function, `no-std` library that returns `true` if the current
CPU implements PDEP and PEXT with fast, non-microcoded hardware.",

"Rationale\n---------\n\nZen, Zen+, Zen 2, and Hygon Dhyana CPUs
implement PDEP and PEXT using microcode in a way that makes them slower
than well-optimized, non-intrinsic fallbacks. In performance-critical
code, checking for BMI2 support isn't enough—you could end up hurting
performance on said CPUs where these instructions exist but are slow.
This crate helps you avoid that by detecting speed, not just support.",

"The result of the hardware check is determined once at runtime. After
the initial check, all future\ncalls to `has_fast_pdep` becomes a simple
`true` or `false` with zero branching or logic. On x86 targets, CPUID is
used directly without probing for its existence. This is intentional.",

"You can view the documentation on docs.rs
[here](https://docs.rs/has_fast_pdep).",

"Rationale\n---------\n\nZen, Zen+, Zen 2, and Hygon Dhyana CPUs
implement PDEP and PEXT using microcode in a way that makes them slower
than well-optimized, non-intrinsic fallbacks. In performance-critical
code, checking for BMI2 support isn't enough—you could end up hurting
performance on said CPUs where these instructions exist but are slow.
This crate helps you avoid that by detecting speed, not just support",

"Implementation Details\n----------------------\n\nThe result of the
hardware check is determined once at runtime. After the initial check,
all future\ncalls to `has_fast_pdep` becomes a simple `true` or `false`
with zero branching or logic.",

"Detect fast hardware support for PDEP/PEXT."

]

}

],

"reasoning": "The most directly relevant material describes a Rust
ecosystem focus on portable, low-level bit manipulation via no_std
libraries and traits named after CPU instructions. These excerpts
collectively establish a pattern of small, high-signal crates that
expose safe, portable bitwise operations across architectures, which is
precisely the type of under-300-line libraries that implement canonical
bit-manipulation algorithms in Rust. Discussions of concrete bitwise
intrinsics, their exposure as traits across integer types, and
cross-architecture support reinforce the feasibility of compact crates
delivering well-known bit-hack utilities, which maps to the canonical
algorithms and bit-hack topics in the valued references. The presence of
documentation and crates that enumerate supported instruction sets
(e.g., x86 BMI, BMI2, TBM, and ARM variants) further supports the notion
that highly focused, portable bit manipulation libraries are a realistic
area for small, high-value Rust crates that fill gaps in the ecosystem.
Additionally, the discussion of runtime hardware checks for specialized
bit-manipulation features (PDEP/PEXT) highlights performance-sensitive
avenues where a tiny crate could offer safe abstractions or fast-path
helpers, aligning with the WASM SIMD status/counterpart considerations
by signaling where SIMD or specialized paths matter. Together, these
excerpts illustrate a landscape where small, well-scoped
bit-manipulation crates are both viable and valuable, especially when
they provide portable abstractions or efficient feature-detection shims
that enable broader usage in CPU-domain code.",

"confidence": "medium"

},

{

"field": "opportunity_summary_table.6.opportunity_name",

"citations": [

{

"title": "has_fast_pdep crate page",

"url": "https://crates.io/crates/has_fast_pdep",

"excerpts": [

"The result of the hardware check is determined once at runtime. After
the initial check, all future\ncalls to `has_fast_pdep` becomes a simple
`true` or `false` with zero branching or logic. On x86 targets, CPUID is
used directly without probing for its existence. This is intentional.",

"Implementation Details\n----------------------\n\nThe result of the
hardware check is determined once at runtime. After the initial check,
all future\ncalls to `has_fast_pdep` becomes a simple `true` or `false`
with zero branching or logic.",

"Rationale\n---------\n\nZen, Zen+, Zen 2, and Hygon Dhyana CPUs
implement PDEP and PEXT using microcode in a way that makes them slower
than well-optimized, non-intrinsic fallbacks. In performance-critical
code, checking for BMI2 support isn't enough—you could end up hurting
performance on said CPUs where these instructions exist but are slow.
This crate helps you avoid that by detecting speed, not just support.",

"A single-function, `no-std` library that returns `true` if the current
CPU implements PDEP and PEXT with fast, non-microcoded hardware.",

"You can view the documentation on docs.rs
[here](https://docs.rs/has_fast_pdep)."

]

},

{

"title": "bitintr - Rust",

"url": "https://gnzlbg.github.io/bitintr/",

"excerpts": [

"bitintr offers portable bit manipulation intrinsics (@github,
@crates.io). The intrinsics are named after their CPU instruction and
organized in modules ..."

]

},

{

"title": "gnzlbg/bitintr: Portable Bitwise Manipulation Intrinsics",

"url": "https://github.com/gnzlbg/bitintr",

"excerpts": [

"This `#![no_std]` library exposes *safe* and *portable* low-level bit
manipulation\ninstruction set architectures.",

"This #![no_std] library exposes safe and portable low-level bit
manipulation instruction set architectures. The Minimum Supported Rust
Version is 1.36.0."

]

},

{

"title": "Bitintr 0.3.0 Documentation and Repository",

"url": "http://docs.rs/bitintr/latest/bitintr",

"excerpts": [

"This `#![no_std]` library exposes *safe* and *portable* low-level bit
manipulation\ninstruction set architectures.",

"The intrinsics are exposed via traits named after their CPU
instruction."

]

},

{

"title": "bitintr 0.3.0 - Docs.rs",

"url": "http://docs.rs/bitintr/0.3.0/bitintr",

"excerpts": [

"This `#![no_std]` library exposes *safe* and *portable* low-level bit
manipulation\ninstruction set architectures."

]

},

{

"title": "Bitintr crate - Rust crates.io",

"url": "https://crates.io/crates/bitintr",

"excerpts": [

"The intrinsics are exposed via traits named after their CPU
instruction."

]

}

],

"reasoning": "The most directly relevant content comes from a source
that defines a no-std library which returns true if the current CPU
implements PDEP and PEXT with fast, non-microcoded hardware. This
directly maps to the concept of minimal CPU feature detection by
determining whether a CPU supports a feature with a lightweight check
and enabling a fast path accordingly. Supporting evidence notes that the
runtime check is performed once and then the result is used with zero
branching, which epitomizes a minimal, efficient detection strategy.
Additional excerpts describe that hardware checks occur at runtime and
that subsequent calls are simple boolean results, reinforcing the idea
of minimal overhead feature detection. Other excerpts discuss portable
bit manipulation intrinsics and no-std libraries, which provide relevant
context around the ecosystem and tooling around low-level feature
support, but they are slightly less focused on the minimal detection
workflow itself. Together, these excerpts support the claim that minimal
CPU feature detection (with fast paths and zero-overhead decisions) is a
viable and practical pattern in Rust ecosystems, as evidenced by crates
that detect specific CPU capabilities and optimize accordingly.",

"confidence": "high"

},

{

"field": "opportunity_summary_table.6.ease_of_success_testing",

"citations": [

{

"title": "has_fast_pdep crate page",

"url": "https://crates.io/crates/has_fast_pdep",

"excerpts": [

"A single-function, `no-std` library that returns `true` if the current
CPU implements PDEP and PEXT with fast, non-microcoded hardware.",

"Implementation Details\n----------------------\n\nThe result of the
hardware check is determined once at runtime. After the initial check,
all future\ncalls to `has_fast_pdep` becomes a simple `true` or `false`
with zero branching or logic.",

"The result of the hardware check is determined once at runtime. After
the initial check, all future\ncalls to `has_fast_pdep` becomes a simple
`true` or `false` with zero branching or logic. On x86 targets, CPUID is
used directly without probing for its existence. This is intentional.",

"Detect fast hardware support for PDEP/PEXT."

]

},

{

"title": "gnzlbg/bitintr: Portable Bitwise Manipulation Intrinsics",

"url": "https://github.com/gnzlbg/bitintr",

"excerpts": [

"This `#![no_std]` library exposes *safe* and *portable* low-level bit
manipulation\ninstruction set architectures.",

"This #![no_std] library exposes safe and portable low-level bit
manipulation instruction set architectures. The Minimum Supported Rust
Version is 1.36.0."

]

},

{

"title": "Bitintr 0.3.0 Documentation and Repository",

"url": "http://docs.rs/bitintr/latest/bitintr",

"excerpts": [

"This `#![no_std]` library exposes *safe* and *portable* low-level bit
manipulation\ninstruction set architectures.",

"The intrinsics are exposed via traits named after their CPU
instruction."

]

},

{

"title": "bitintr 0.3.0 - Docs.rs",

"url": "http://docs.rs/bitintr/0.3.0/bitintr",

"excerpts": [

"This `#![no_std]` library exposes *safe* and *portable* low-level bit
manipulation\ninstruction set architectures."

]

},

{

"title": "bitintr - Rust",

"url": "https://gnzlbg.github.io/bitintr/",

"excerpts": [

"bitintr offers portable bit manipulation intrinsics (@github,
@crates.io). The intrinsics are named after their CPU instruction and
organized in modules ..."

]

},

{

"title": "Bitintr crate - Rust crates.io",

"url": "https://crates.io/crates/bitintr",

"excerpts": [

"The intrinsics are exposed via traits named after their CPU
instruction.",

"The intrinsics are exposed via traits named after their CPU
instruction. These traits are implemented for all integer types except
u128/i128 "

]

}

],

"reasoning": "To support a field about the ease of success testing for
compact Rust CPU-domain libraries, prioritize excerpts describing highly
focused, small-footprint crates and their testing/usage characteristics.
A single-function, no-std crate is by design small, easy to test, and
highly portable across environments, which directly supports a high
ease-of-testing signal. References describing a no_std, portable bit
manipulation suite corroborate that such projects tend to be compact and
verifiable, aligning with the under-300-loc constraint. Additional
excerpts that discuss a focused crate for fast hardware detection and a
no-std bit manipulation crate reinforce the pattern of small, testable,
domain-relevant contributions. Collectively, these support the idea that
concise, well-scoped crates in CPU-related areas have favorable testing
and adoption characteristics. The more explicit mentions of
single-function design and no_std portability are the strongest
indicators of ease of testing and likelihood of meeting the 300 LOC
target; surrounding excerpts reinforce the domain focus on CPU-relevant
bit manipulation and hardware-detection utilities, which are natural fit
for compact libraries.",

"confidence": "medium"

},

{

"field": "opportunity_summary_table.6.reasoning",

"citations": [

{

"title": "has_fast_pdep crate page",

"url": "https://crates.io/crates/has_fast_pdep",

"excerpts": [

"A single-function, `no-std` library that returns `true` if the current
CPU implements PDEP and PEXT with fast, non-microcoded hardware.",

"The result of the hardware check is determined once at runtime. After
the initial check, all future\ncalls to `has_fast_pdep` becomes a simple
`true` or `false` with zero branching or logic. On x86 targets, CPUID is
used directly without probing for its existence. This is intentional.",

"You can view the documentation on docs.rs
[here](https://docs.rs/has_fast_pdep).",

"Implementation Details\n----------------------\n\nThe result of the
hardware check is determined once at runtime. After the initial check,
all future\ncalls to `has_fast_pdep` becomes a simple `true` or `false`
with zero branching or logic."

]

},

{

"title": "Bitintr crate - Rust crates.io",

"url": "https://crates.io/crates/bitintr",

"excerpts": [

"This `#![no_std]` library exposes *safe* and *portable* low-level bit
manipulation\ninstruction set architectures. The Minimum Supported Rust
Version is 1.36.0.",

"The intrinsics are exposed via traits named after their CPU
instruction. These traits are implemented for all integer types except
u128/i128 "

]

},

{

"title": "gnzlbg/bitintr: Portable Bitwise Manipulation Intrinsics",

"url": "https://github.com/gnzlbg/bitintr",

"excerpts": [

"This #![no_std] library exposes safe and portable low-level bit
manipulation instruction set architectures. The Minimum Supported Rust
Version is 1.36.0.",

"This `#![no_std]` library exposes *safe* and *portable* low-level bit
manipulation\ninstruction set architectures."

]

},

{

"title": "Bitintr 0.3.0 Documentation and Repository",

"url": "http://docs.rs/bitintr/latest/bitintr",

"excerpts": [

"This `#![no_std]` library exposes *safe* and *portable* low-level bit
manipulation\ninstruction set architectures."

]

},

{

"title": "bitintr 0.3.0 - Docs.rs",

"url": "http://docs.rs/bitintr/0.3.0/bitintr",

"excerpts": [

"This `#![no_std]` library exposes *safe* and *portable* low-level bit
manipulation\ninstruction set architectures."

]

},

{

"title": "bitintr - Rust",

"url": "https://gnzlbg.github.io/bitintr/",

"excerpts": [

"bitintr offers portable bit manipulation intrinsics (@github,
@crates.io). The intrinsics are named after their CPU instruction and
organized in modules ..."

]

}

],

"reasoning": "The strongest support for a minimalist, no_std-first,
cross-platform CPU feature-detection crate comes from discussions of
no_std, portable low-level capabilities, and cross-ISA intrinsics. One
excerpt directly frames a no_std library that exposes portable
intrinsics, which aligns well with the idea of a tiny crate providing
abstraction over CPU feature flags rather than full-featured CPUID
toolkits. Additional excerpts describe a no_std crate that exposes safe,
portable low-level bit manipulation intrinsics, reinforcing the
feasibility and design pattern of small, cross-platform crates focusing
on small feature areas. Other excerpts discuss runtime-detection
strategies for CPU features (e.g., detecting fast hardware support for
PDEP/PEXT or using CPUID directly) which illustrate practical approaches
a minimalist crate could adopt to expose a handful of common feature
flags without pulling in larger dependencies. Collectively, these
sources support the feasibility and rationale of a tiny, no_std-first
crate that abstracts platform-specific CPU feature detection (CPUID,
auxv, sysctl) and offers a minimal API surface for a few widely useful
flags, serving the described niche. Specifically, the explicit no_std
portability emphasis and the notion of safe, portable low-level
intrinsics underpin the design of such a crate. The runtime
CPUID/auxv/sysctl examples demonstrate how a minimal crate could
implement the abstraction layer while remaining lean and cross-platform.
In summary, there is direct evidence of existing no_std, portable crates
around CPU-related intrinsics and some guidance on runtime feature
checks, which collectively validate the proposed niche and guidance for
a compact library that abstracts CPU feature detection across platforms.
",

"confidence": "high"

},

{

"field": "opportunity_summary_table.6.pmf_probability_score",

"citations": [

{

"title": "gnzlbg/bitintr: Portable Bitwise Manipulation Intrinsics",

"url": "https://github.com/gnzlbg/bitintr",

"excerpts": [

"This #![no_std] library exposes safe and portable low-level bit
manipulation instruction set architectures. The Minimum Supported Rust
Version is 1.36.0.",

"This `#![no_std]` library exposes *safe* and *portable* low-level bit
manipulation\ninstruction set architectures."

]

},

{

"title": "bitintr - Rust",

"url": "https://gnzlbg.github.io/bitintr/",

"excerpts": [

"bitintr offers portable bit manipulation intrinsics (@github,
@crates.io). The intrinsics are named after their CPU instruction and
organized in modules ..."

]

},

{

"title": "Bitintr crate - Rust crates.io",

"url": "https://crates.io/crates/bitintr",

"excerpts": [

"This `#![no_std]` library exposes *safe* and *portable* low-level bit
manipulation\ninstruction set architectures. The Minimum Supported Rust
Version is 1.36.0.",

"The intrinsics are exposed via traits named after their CPU
instruction. These traits are implemented for all integer types except
u128/i128 ",

"#! [no_std] library exposes safe and portable low-level bit
manipulation\ninstruction set architectures.",

"The intrinsics are exposed via traits named after their CPU
instruction."

]

},

{

"title": "Bitintr 0.3.0 Documentation and Repository",

"url": "http://docs.rs/bitintr/latest/bitintr",

"excerpts": [

"The intrinsics are exposed via traits named after their CPU
instruction.",

"This `#![no_std]` library exposes *safe* and *portable* low-level bit
manipulation\ninstruction set architectures."

]

},

{

"title": "bitintr 0.3.0 - Docs.rs",

"url": "http://docs.rs/bitintr/0.3.0/bitintr",

"excerpts": [

"This `#![no_std]` library exposes *safe* and *portable* low-level bit
manipulation\ninstruction set architectures."

]

},

{

"title": "has_fast_pdep crate page",

"url": "https://crates.io/crates/has_fast_pdep",

"excerpts": [

"A single-function, `no-std` library that returns `true` if the current
CPU implements PDEP and PEXT with fast, non-microcoded hardware.",

"Implementation Details\n----------------------\n\nThe result of the
hardware check is determined once at runtime. After the initial check,
all future\ncalls to `has_fast_pdep` becomes a simple `true` or `false`
with zero branching or logic.",

"Detect fast hardware support for PDEP/PEXT."

]

}

],

"reasoning": "The most directly relevant excerpts describe compact,
no_std crates that expose portable bit manipulation intrinsics and
low-level CPU instruction interfaces. A crate that provides portable bit
manipulation intrinsics (excerpts describe it as a no_std library with
safe, portable access to CPU instructions, organized by instruction and
supported by multiple architectures) directly aligns with a small,
high-utility Rust library focused on CPU-domain functionality. It also
highlights a design pattern for minimal, targeted crates that achieve
broad applicability across architectures while remaining lean.
Additional excerpts emphasize that these intrinsics are exposed via
traits named after specific CPU instructions, and that the minimum
supported Rust version is modern but the codebase can be quite small,
reinforcing the feasibility of sub-300 LOC crates addressing real-world
needs in systems programming. This supports the proposed PMF by
illustrating a proven, compact class of libraries that developers use to
achieve high performance with correct abstractions, which is the essence
of a high-potential opportunity in the space described. The mentions of
#![no_std] and safe, portable bit manipulation intrinsics underscore a
strong market signal for lightweight, CPU-focused crates that work in
constrained environments and across architectures, matching the user's
intent for small, highly useful Rust libraries. The presence of
practical, well-scoped crates around PDEP/PEXT detection and fast
hardware capability checks demonstrates an ecosystem appetite for tiny,
purpose-built crates that optimize performance-critical paths and avoid
mispredictions or slow-path fallbacks. The Bit Twiddling Hacks
references provide a validated set of classic bitwise techniques that
can be factored into compact Rust libraries, reinforcing the feasibility
and demand for concise crates implementing proven algorithms. The
combination of these signals—portable intrinsics, no_std safety,
architecture-aware trait exposure, and established reference
materials—collectively supports a high-lidelity justification for 4/5
PMF potential in the given target space, particularly for under-300 LOC
Rust libraries that deliver measurable performance or portability
advantages. In summary, the excerpts collectively indicate a ripe niche
for small, CPU-domain Rust crates that provide safe, portable low-level
functionality with clear testing hooks and cross-architecture
applicability, aligning with the requested PMF objective.",

"confidence": "high"

},

{

"field": "c_cpp_porting_candidates.4.category",

"citations": [

{

"title": "morton-nd/morton-nd: A header-only compile-time ...",

"url": "https://github.com/morton-nd/morton-nd",

"excerpts": [

"A header-only Morton encode/decode library (C++14) capable of encoding
from and decoding to N-dimensional space. All algorithms are generated
at compile-time."

]

}

],

"reasoning": "The provided excerpt describes a C++ header-only library
for Morton encoding/decoding, which involves N-dimensional space
manipulation. Morton encoding is a form of bit interleaving, a technique
fundamental to bit manipulation. This suggests a potential opportunity
to port such a library to Rust, as bit manipulation is a core aspect of
CPU-level operations and data structure optimization, aligning with the
user's interest in the CPU domain and mathematical libraries.",

"confidence": "medium"

},

{

"field": "bit_twiddling_primitives_opportunity",

"citations": [

{

"title": "Bitintr 0.3.0 Documentation and Repository",

"url": "http://docs.rs/bitintr/latest/bitintr",

"excerpts": [

"The following ISAs are implemented:\n\n* x86 (`bitintr::x86`):\n\n +
[`ABM`](https://en.wikipedia.org/wiki/Bit_Manipulation_Instruction_Sets.28Advanced_Bit_Manipulation.29):
Advanced Bit Manipulation instructions
([`bitintr::x86::abm`](https://gnzlbg.github.io/bitintr/bitintr/x86/abm/index.html)).\n
+
[`TBM`](https://en.wikipedia.org/wiki/Bit_Manipulation_Instruction_Sets.28Trailing_Bit_Manipulation.29):
Trailing Bit Manipulation instructions
([`bitintr::x86::tbm`](https://gnzlbg.github.io/bitintr/bitintr/x86/tbm/index.html)).\n
+
[`BMI`](https://en.wikipedia.org/wiki/Bit_Manipulation_Instruction_Sets.28Bit_Manipulation_Instruction_Set_1.29):
Bit Manipulation Instruction Set 1.0
([`bitintr::x86::bmi`](https://gnzlbg.github.io/bitintr/bitintr/x86/bmi/index.html)).\n
+
[`BMI2`](https://en.wikipedia.org/wiki/Bit_Manipulation_Instruction_Sets.28Bit_Manipulation_Instruction_Set_2.29):
Bit Manipulation Instruction Set 2.0
([`bitintr::x86::bmi2`](https://gnzlbg.github.io/bitintr/bitintr/x86/bmi2/index.html)).\n*
ARM (`bitintr::arm`):\n\n +
[`ARMv5`](http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0100i/index.html):
[`bitintr::arm::v5`](https://gnzlbg.github.io/bitintr/bitintr/arm/v5/index.html).\n
+
[`ARMv6`](http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0419c/index.html):
[`bitintr::arm::v6`](https://gnzlbg.github.io/bitintr/bitintr/arm/v6/index.html).\n
+
[`ARMv7`](http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0403e.b/index.html):
[`bitintr::arm::v7`](https://gnzlbg.github.io/bitintr/bitintr/arm/v7/index.html).\n
+
[`ARMv8`](http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0487a.k_10775/index.html):
[`bitintr::arm::v8`](https://gnzlbg.github.io/bitintr/bitintr/arm/v8/index.html).",

"The Minimum Supported Rust Version is 1.36.0.",

"bitintr 0.3.0 - Docs.rs",

"bitintr-0.3.0 doesn't have any documentation.",

"This `#![no_std]` library exposes *safe* and *portable* low-level bit
manipulation\ninstruction set architectures.",

"The intrinsics are exposed via traits named after their CPU
instruction."

]

},

{

"title": "bitintr 0.3.0 - Docs.rs",

"url": "http://docs.rs/bitintr/0.3.0/bitintr",

"excerpts": [

"bitintr-0.3.0 doesn't have any documentation.",

"This `#![no_std]` library exposes *safe* and *portable* low-level bit
manipulation\ninstruction set architectures."

]

},

{

"title": "Bit Twiddling Hacks",

"url": "https://graphics.stanford.edu/~seander/bithacks.html",

"excerpts": [

"Bit Twiddling Hacks",

"\nBy Sean Eron Anderson seander@cs.stanford.edu Individually, the code
snippets here are in the public domain (unless otherwise noted) — feel
free to use them however you please. The aggregate collection and
descriptions are © 1997-2005 Sean Eron Anderson. The code and
descriptions are distributed in the hope that they will be useful,",

"The code and descriptions are distributed in the hope that they will be
useful,\nbut WITHOUT ANY WARRANTY and without even the implied warranty
of\nmerchantability or fitness for a particular purpose.",

"Bit Twiddling Hacks. By Sean Eron Anderson seander@cs.stanford.edu.
Individually, the code snippets here are in the public domain (unless
otherwise noted) ... Bit Twiddling Hack",

"As of May 5, 2005, all the code has been tested thoroughly. Thousands
of\npeople have read it.",

"n and\ncountbetween on April 10, 2005. Compute the lexicographically
next bit permutation Suppose we have a pattern of N bits set to 1 in an
integer and we want the next permutation of N 1 bits in a
lexicographical sense. For example, if N is 3 and the bit pattern is
00010011, the next patterns would be 00010101, 00010110,
00011001,00011010, 00011100, 00100011, and so forth. The following is a
fast way to compute the next permutation. unsigned int v; // current
permutation of bits unsigned int w;",

"unsigned int t = v | (v - 1); // t gets v's least significant 0 bits
set to 1\n// Next set to 1 the most significant bit to change, // set to
0 the least significant ones, and add the necessary 1 bits.",

"What he hasn't tested, I have checked against all\npossible inputs on a
32-bit machine.",

"int y; int r; // the result goes here r = y ^ ((x ^ y) & -(x < y)); //
min(x, y)",

"It works because if x < y, then -(x < y) will be all ones, so r = y ^
(x ^ y) & ~0 = y ^ x ^ y = x. Otherwise, if x >= y, then -(x < y) will
be all zeros, so r = y ^ ((x ^ y) & 0) = y.",

"Bit Twiddling Hacks. By Sean Eron Anderson",

"r = y ^ ((x ^ y) & -(x < y)); // min(x, y)",

"The method first shifts and XORs the eight nibbles of the 32-bit value
together, leaving the result in the lowest nibble of v. Next, the binary
number 0110 ..."

]

},

{

"title": "has_fast_pdep crate page",

"url": "https://crates.io/crates/has_fast_pdep",

"excerpts": [

"A single-function, `no-std` library that returns `true` if the current
CPU implements PDEP and PEXT with fast, non-microcoded hardware.",

"Rationale\n---------\n\nZen, Zen+, Zen 2, and Hygon Dhyana CPUs
implement PDEP and PEXT using microcode in a way that makes them slower
than well-optimized, non-intrinsic fallbacks. In performance-critical
code, checking for BMI2 support isn't enough—you could end up hurting
performance on said CPUs where these instructions exist but are slow.
This crate helps you avoid that by detecting speed, not just support.",

"has_fast_pdep = \"0.1\"",

"The result of the hardware check is determined once at runtime. After
the initial check, all future\ncalls to `has_fast_pdep` becomes a simple
`true` or `false` with zero branching or logic. On x86 targets, CPUID is
used directly without probing for its existence. This is intentional.",

"You can view the documentation on docs.rs
[here](https://docs.rs/has_fast_pdep).",

"Rationale\n---------\n\nZen, Zen+, Zen 2, and Hygon Dhyana CPUs
implement PDEP and PEXT using microcode in a way that makes them slower
than well-optimized, non-intrinsic fallbacks. In performance-critical
code, checking for BMI2 support isn't enough—you could end up hurting
performance on said CPUs where these instructions exist but are slow.
This crate helps you avoid that by detecting speed, not just support",

"Implementation Details\n----------------------\n\nThe result of the
hardware check is determined once at runtime. After the initial check,
all future\ncalls to `has_fast_pdep` becomes a simple `true` or `false`
with zero branching or logic.",

"pkg:cargo/has\\_fast\\_pdep@0.1.3",

"Detect fast hardware support for PDEP/PEXT.",

"3 months ago"

]

},

{

"title": "gnzlbg/bitintr: Portable Bitwise Manipulation Intrinsics",

"url": "https://github.com/gnzlbg/bitintr",

"excerpts": [

"This `#![no_std]` library exposes *safe* and *portable* low-level bit
manipulation\ninstruction set architectures."

]

},

{

"title": "Bitintr crate - Rust crates.io",

"url": "https://crates.io/crates/bitintr",

"excerpts": [

"The intrinsics are exposed via traits named after their CPU
instruction."

]

},

{

"title": "bitintr on docs.rs",

"url": "https://docs.rs/crate/bitintr/latest",

"excerpts": [

"The intrinsics are exposed via traits named after their CPU
instruction. These\ntraits are implemented for all integer types except"

]

},

{

"title": "Bit Twiddling Hacks",

"url": "https://www.cl.cam.ac.uk/~awc32/bithacks.html",

"excerpts": [

"Bit Twiddling Hacks\n===================\n"

]

},

{

"title": "has_fast_pdep - Rust",

"url": "https://docs.rs/has_fast_pdep",

"excerpts": [

"A single-function, no-std library that returns true if the current CPU
implements PDEP and PEXT with fast, non-microcoded hardware.
[dependencies] has_fast_pdep ...See more"

]

},

{

"title": "cpufeatures crate on crates.io",

"url": "https://crates.io/crates/cpufeatures",

"excerpts": [

"aarch64",

"Target features:\n * aes *\n * sha2 *"

]

},

{

"title": "raw-cpuid crates.io description",

"url": "https://crates.io/crates/raw-cpuid",

"excerpts": [

"A library to parse the x86 CPUID instruction, written in rust with no
external\ndependencies. The implementation closely resembles the Intel
CPUID manual\ndescription. The library works in\nno_std environments.",

"A library to parse the x86 CPUID instruction, written in rust with no
external dependencies. The implementation closely resembles the Intel
CPUID manual description. The library does only depend on libcore.",

"raw-cpuid v11.5.0",

"CPUID",

"Library usage\nuse raw_cpuid::CpuId; let cpuid = CpuId:: new ();",

"Metadata\npkg:cargo/raw-cpuid@11.5.0",

"Mar 4, 2025 — A library to parse the x86 CPUID instruction, written in
rust with no external dependencies. The implementation closely resembles
the Intel CPUID manual ..."

]

},

{

"title": "gz/rust-cpuid: cpuid library in rust.",

"url": "https://github.com/gz/rust-cpuid",

"excerpts": [

"A library to parse the x86 CPUID instruction, written in rust with no
external dependencies. The implementation closely resembles the Intel
CPUID manual ...",

"The implementation closely resembles the Intel CPUID manual
description. The library works in no_std environments. Some additional
cargo features require std ( ..."

]

},

{

"title": "cpuid - Keywords - crates.io: Rust Package Registry",

"url": "https://crates.io/keywords/cpuid",

"excerpts": [

"A library to parse the x86 CPUID instruction, written in rust with no
external dependencies. The implementation closely resembles the Intel
CPUID manual ..."

]

},

{

"title": "__cpuid in core::arch::x86_64 - Rust",

"url":
"https://doc.rust-lang.org/beta/core/arch/x86_64/fn.__cpuid.html",

"excerpts": [

"Summary 1.27.0 · Source. pub unsafe fn __cpuid(leaf: u32) ->
CpuidResult. Available on x86-64 and (x86 or x86-64) only. Expand
description. See __cpuid_count ."

]

},

{

"title": "Intel® 64 and IA-32 Architectures Software Developer's ...",

"url":
"https://courses.cs.washington.edu/courses/cse481a/18wi/readings/sdm-3.pdf",

"excerpts": [

"NOTE: The Intel 64 and IA-32 Architectures Software Developer's Manual
consists of four volumes ... CPUID Qualification of Control Register
Flags ..."

]

},

{

"title": "Re: When to use AT_HWCAP or AT_HWCAP2",

"url":
"https://sourceware.org/legacy-ml/libc-help/2017-08/msg00013.html",

"excerpts": [

"Aug 7, 2017 — The getauxval (3) man page discusses both > AT_HWCAP and
AT_HWCAP2. I'm less clear on about when I should use one > or the other?
AT_HWCAP2 ..."

]

},

{

"title": "Manuals for Intel® 64 and IA-32 Architectures",

"url":
"https://www.intel.com/content/www/us/en/developer/articles/technical/intel-sdm.html",

"excerpts": [

"The downloadable PDF of the Intel® 64 and IA-32 Architectures
Optimization Reference Manual Volume 1 is at version 050, and Volume 2
is at ...",

"Mar 5, 2025 — These manuals describe the architecture and programming
environment of the Intel® 64 and IA-32 architectures."

]

},

{

"title": "Discovering CPU features from userspace with ELF_HWCAP",

"url":
"https://www.thegoodpenguin.co.uk/blog/discover-cpu-features-with-elf-hwcap/",

"excerpts": [

"In this post we'll explore the ELF_HWCAP feature in the Linux kernel
and understand how userspace can use it to find out about available
features."

]

},

{

"title": "ID_AA64ISAR0_EL1: AArch64 Instruction Set Attribute ...",

"url":
"https://developer.arm.com/documentation/ddi0601/latest/AArch64-Registers/ID-AA64ISAR0-EL1--AArch64-Instruction-Set-Attribute-Register-0",

"excerpts": [

"Provides information about the instructions implemented in AArch64
state. For general information about the interpretation of the ID
registers, see 'Principles ..."

]

},

{

"title": "ID_AA64ISAR0_EL1: AArch64 Instruction Set Attribute ...",

"url":
"https://developer.arm.com/documentation/ddi0601/2021-06/AArch64-Registers/ID-AA64ISAR0-EL1--AArch64-Instruction-Set-Attribute-Register-0",

"excerpts": [

"This document provides descriptions in HTML format for the Armv9-A
system registers and memory-mapped registers."

]

},

{

"title": "CPUID",

"url": "https://en.wikipedia.org/wiki/CPUID",

"excerpts": [

"EBX and ECX provide feature flags, EDX is reserved. CPUID EAX=14h,ECX=0
... This leaf returns feature flags on the TMUL (tile multiplier) unit.
CPUID ..."

]

},

{

"title": "core::arch::x86_64 - Rust",

"url": "https://doc.rust-lang.org/core/arch/x86_64/index.html",

"excerpts": [

"Transpose the 4x4 matrix formed by 4 rows of __m128 in place. __cpuid
⚠x86 or x86-64: See __cpuid_count . __cpuid_count ⚠x86 or x86-64:
Returns the result ..."

]

},

{

"title": "std_detect - crates.io: Rust Package Registry",

"url": "https://crates.io/crates/std_detect",

"excerpts": [

"Apr 17, 2019 — std_detect v0.1.5 `std::detect` - Rust's standard
library run-time CPU feature detection. Failed to load README file for
std_detect v0.1.5.See more"

]

},

{

"title": "librust-cpufeatures-dev_0.2.16-1_arm64.deb",

"url":
"https://debian.pkgs.org/sid/debian-main-arm64/librust-cpufeatures-dev_0.2.16-1_arm64.deb.html",

"excerpts": [

"Lightweight runtime CPU feature detection for aarch64, loongarch64, and
x86/x86_64 targets, with no_std support and support for mobile targets
including ..."

]

},

{

"title": "core_detect - Rust - Docs.rs",

"url": "https://docs.rs/core_detect",

"excerpts": [

"Macros§. is_x86_feature_detected: A macro to test at runtime whether a
CPU feature is available on x86/x86-64 platforms."

]

},

{

"title": "Intel 64 and IA-32 Architectures Software Developer\ts Manual
- CPUID Reference (Vol. 2A)",

"url":
"https://cdrdv2-public.intel.com/671110/325383-sdm-vol-2abcd.pdf",

"excerpts": [

"CPUID returns processor identification and feature information in the
EAX, EBX, ECX, and EDX registers.1 The\ninstruction’s output is
dependent on the contents of the EAX register upon execution (in some
cases, ECX as well).",

"The ID flag (bit 21) in the EFLAGS register indicates support for the
CPUID instruction.",

"This instruction oper-\nates the same in non-64-bit modes and 64-bit
mode. CPUID returns processor identification and feature information in
the EAX, EBX, ECX, and EDX registers",

"The bit position corresponds to the sub-leaf index (or ResID) that
soft-\nware must use to query QoS monitoring capability available for
that type. See Table 3-",

"When CPUID executes with EAX set to 0BH, the processor returns
information about extended topology enumera-\ntion data. Software must
detect the presence of CPUID leaf 0BH by verifying (a) the highest leaf
index supported\nby CPUID is >= 0BH, and (b) CPUID.0BH:EBX[15:0] reports
a non-zero value. See Table 3-",

"PUT EAX = 07H: Returns Structured Extended Feature Enumeration
Informatio",

"CPUID leaf 1FH is a preferred superset to leaf 0BH. Intel recommends
first checking for the existence of Leaf 1FH\nbefore using leaf 0BH."

]

},

{

"title": "cpufeatures - crates.io: Rust Package Registry",

"url": "https://crates.io/crates/cpufeatures/0.2.5",

"excerpts": [

"Lightweight runtime CPU feature detection for aarch64, loongarch64, and
x86/x86_64 targets, with no_std support and support for mobile ..."

]

},

{

"title": "multiversion - Rust",

"url": "https://docs.rs/multiversion/latest/multiversion/",

"excerpts": [

"There is one cargo feature, std , enabled by default. When enabled,
multiversion will use CPU feature detection at runtime to dispatch the
appropriate function."

]

},

{

"title": "sbbf-rs - crates.io: Rust Package Registry",

"url": "https://crates.io/crates/sbbf-rs",

"excerpts": [

"Feb 29, 2024 — Outputs same byte buffers on different systems.
Completely cross-platform. no_std support; relatively simple and low
amount of code. Caveats."

]

},

{

"title": "cpufeatures 0.2.17",

"url": "https://docs.rs/crate/cpufeatures/latest/source/README.md",

"excerpts": [

"[RustCrypto]: CPU Feature Detection [![crate][crate-image]][crate-link
... no_std` as well as mobile targets including iOS and Android,
providing an ..."

]

},

{

"title": "auxv - crates.io: Rust Package Registry",

"url": "https://crates.io/crates/auxv/0.1.0",

"excerpts": [

"getauxval(3) is a glibc-only function for accessing the Linux auxiliary
vector. Since it is a non-standard extension, if you're not using glibc
(musl, uclibc, ..."

]

},

{

"title": "rust-lang/stdarch: Rust's standard library vendor-specific ...
- GitHub",

"url": "https://github.com/rust-lang/stdarch",

"excerpts": [

"std_detect implements std::detect - Rust's standard library run-time
CPU feature detection. The std::simd component now lives in the
packed_simd_2 crate ..."

]

},

{

"title": "auxv - crates.io: Rust Package Registry",

"url": "https://crates.io/crates/auxv",

"excerpts": [

"Jan 20, 2017 — Access the ELF auxiliary vector (aka auxv or auxval) ...
The Rust community's crate registry. Submit. Change color scheme. light"

]

},

{

"title": "ARM64 ELF hwcaps",

"url": "https://docs.kernel.org/arch/arm64/elf_hwcaps.html",

"excerpts": [

"The kernel exposes the presence of these features to userspace through
a set of flags called hwcaps, exposed in the auxiliary vector. Userspace
software can ...",

"ARM64 ELF hwcaps are flags exposed to userspace to indicate hardware
features not discoverable at EL0, often related to ID registers."

]

},

{

"title": "auxv - Rust - Docs.rs",

"url": "https://docs.rs/auxv/",

"excerpts": [

"The auxiliary vector (aka auxv) is some memory near the start of a
running ELF program's stack. Specifically, it's a sequence of pairs of
either 64 bit or 32 ..."

]

},

{

"title": "Inline Assembly in Rust",

"url": "https://rust-dd.com/post/inline-assembly-in-rust",

"excerpts": [

"Dec 29, 2024 — Compiler Intrinsics: Rust's intrinsics often provide
safe, high-level wrappers for many CPU instructions. In many cases, you
get the same ..."

]

},

{

"title": "Rust and Assembly : r/rust",

"url":
"https://www.reddit.com/r/rust/comments/tifa4v/rust_and_assembly/",

"excerpts": [

"Yeah, you should write your assembly inside an unsafe block and then
write a safe wrapper over the unsafe code. But do you really need
the ..."

]

},

{

"title": "QEMU",

"url": "https://www.qemu.org/",

"excerpts": [

"Features ; Full-system emulation. Run operating systems for any
machine, on any supported architecture ; User-mode emulation. Run
programs for another Linux/BSD ..."

]

},

{

"title": "Emulation — QEMU documentation",

"url": "https://www.qemu.org/docs/master/about/emulation.html",

"excerpts": [

"QEMU's Tiny Code Generator (TCG) provides the ability to emulate a
number of CPU architectures on any supported host platform."

]

},

{

"title": "Intel CPUID and Processor Feature Documentation",

"url":
"https://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-software-developer-vol-3b-part-2-manual.pdf",

"excerpts": [

"The CPUID instruction allows software to discover the presence of HWP
support in an Intel processor.",

"Software can check for the presence of new architectural features and
extensions in either of two ways:",

"The CPUID instruction (added to the IA-32 in the Pentium processor)
indicates\n the presence of new features direct",

"Execute CPUID with EAX=0 to discover the “cpuid_maxLeaf” supported in
the processor;\n2. If cpuid_maxLeaf >= 7, then execute CPUID with EAX=7,
ECX= 0 to verify CPUID"

]

},

{

"title": "is_x86_feature_detected in std",

"url":
"https://doc.rust-lang.org/std/macro.is_x86_feature_detected.html",

"excerpts": [

"A macro to test at runtime whether a CPU feature is available on
x86/x86-64 platforms. This macro is provided in the standard library and
will detect at runtime",

"A macro to test at runtime whether a CPU feature is available on
x86/x86-64 platforms. This macro is provided in the standard library and
will detect at runtime std 1.88.0\n(6b00bc388
2025-06-23)\nis_\nx86_\nfeature_\ndetected\nSections\n * Supported
arguments\n\nIn crate std\nstd\nMacro is_x86_feature_detected\nCopy item
path\n1.27.0 · Source\nmacro_rules!\nis_x86_feature_detected
{\n(\"aes\") => { ... };\n(\"pclmulqdq\") => { ... };\n(\"rdrand\") => {
... };\n(\"rdseed\") => { ... };\n(\"tsc\") => { ... };\n(\"mmx\") => {
... };\n(\"sse\") => { ... };\n(\"sse2\") => { ... };\n(\"sse3\") => {
... };\n(\"ssse3\") => { ... };\n(\"sse4.1\") => { ... };\n(\"sse4.2\")
=> { ... };\n(\"sse4a\") => { ... };\n(\"sha\") => { ... };\n(\"avx\")
=> { ... };\n(\"avx2\") => { ... };\n(\"sha512\") => { ... };\n(\"sm3\")
=> { ... };\n(\"sm4\") => { ... };\n(\"avx512f\") => { ...
};\n(\"avx512cd\") => { ... };\n(\"avx512er\") => { ...
};\n(\"avx512pf\") => { ... };\n(\"avx512bw\") => { ...
};\n(\"avx512dq\") => { ... };\n(\"avx512vl\") => { ...
};\n(\"avx512ifma\") => { ... };\n(\"avx512vbmi\") => { ...
};\n(\"avx512vpopcntdq\") => { ... };\n(\"avx512vbmi2\") => { ...
};\n(\"gfni\") => { ... };\n(\"vaes\") => { ... };\n(\"vpclmulqdq\") =>
{ ... };\n(\"avx512vnni\") => { ... };\n(\"avx512bitalg\") => { ...
};\n(\"avx512bf16\") => { ... };\n(\"avx512vp2intersect\") => { ...
};\n(\"avx512fp16\") => { ... };\n(\"avxifma\") => { ...
};\n(\"avxneconvert\") => { ... };\n(\"avxvnni\") => { ...
};\n(\"avxvnniint16\") => { ... };\n(\"avxvnniint8\") => { ...
};\n(\"amx-tile\") => { ... };\n(\"amx-int8\") => { ...
};\n(\"amx-bf16\") => { ... };\n(\"amx-fp16\") => { ...
};\n(\"amx-complex\") => { ... };\n(\"amx-avx512\") => { ...
};\n(\"amx-fp8\") => { ... };\n(\"amx-movrs\") => { ...
};\n(\"amx-tf32\") => { ... };\n(\"amx-transpose\") => { ...
};\n(\"f16c\") => { ... };\n(\"fma\") => { ... };\n(\"bmi1\") => { ...
};\n(\"bmi2\") => { ... };\n(\"lzcnt\") => { ... };\n(\"tbm\") => { ...
};\n(\"popcnt\") => { ... };\n(\"fxsr\") => { ...\n};\n(\"xsave\") => {
... };\n(\"xsaveopt\") => { ... };\n(\"xsaves\") => { ...
};\n(\"xsavec\") => { ... };\n(\"cmpxchg16b\") => { ... };\n(\"kl\") =>
{ ... };\n(\"widekl\") => { ... };\n(\"adx\") => { ... };\n(\"rtm\") =>
{ ... };\n(\"movbe\") => { ... };\n(\"movrs\") => { ... };\n(\"ermsb\")
=> { ... };\n(\"xop\") => { ... };\n(\"abm\") => { ...
};\n(\"avx512gfni\") => { ... };\n(\"avx512vaes\") => { ...
};\n(\"avx512vpclmulqdq\") => { ... };\n($t:tt,) => { ... };\n($t:tt) =>
{ ... "

]

},

{

"title": "stdarch/crates/std_detect/README.md at master · rust-lang ...
- GitHub",

"url":
"https://github.com/rust-lang/stdarch/blob/master/crates/std_detect/README.md",

"excerpts": [

"If you need run-time feature detection in #[no_std] environments, Rust
core library cannot help you. By design, Rust core is platform
independent, but ...",

"The private std::detect module implements run-time feature detection in
Rust's standard library. This allows detecting whether the CPU the
binary runs on ..."

]

},

{

"title": "core::arch - Rust",

"url": "https://doc.rust-lang.org/core/arch/index.html",

"excerpts": [

"CPU Feature Detection. In order to call these APIs in a safe fashion
there's a number of mechanisms available to ensure that the correct CPU
feature is ..."

]

},

{

"title": "getauxval(3) - Linux manual page",

"url": "https://man7.org/linux/man-pages/man3/getauxval.3.html",

"excerpts": [

"AT_HWCAP An architecture and ABI dependent bit-mask whose settings
indicate detailed processor capabilities. The contents of the bit mask
are hardware ..."

]

},

{

"title": "getauxval(3)",

"url": "https://man.archlinux.org/man/getauxval.3",

"excerpts": [

"The getauxval() function retrieves values from the auxiliary vector, a
mechanism that the kernel's ELF binary loader uses to pass certain
information to user ..."

]

},

{

"title": "ARM64 ELF hwcaps",

"url":
"https://www.kernel.org/doc/html/v6.5/arch/arm64/elf_hwcaps.html",

"excerpts": [

"ARM64 ELF hwcaps are flags exposed by the kernel to userspace,
indicating hardware features not discoverable by userspace code at EL0."

]

},

{

"title": "Is SIGILL an UB?",

"url": "https://users.rust-lang.org/t/is-sigill-an-ub/78265",

"excerpts": [

"Jul 12, 2022 — Let's say you are writing AVX instrinsics wrapper, so
you eventually ask yourself a question: does SIGILL cause undefined
behavior?"

]

},

{

"title": "How do I compile the raw-cpuid crate in rust? - Stack
Overflow",

"url":
"https://stackoverflow.com/questions/42747410/how-do-i-compile-the-raw-cpuid-crate-in-rust",

"excerpts": [

"I am using raw-cpuid crate for a project. It uses raw::Slice structure
in processor_brand_string() function of ExtendedFunctionInfo ..."

]

},

{

"title": "zlim/arm64",

"url": "https://github.com/zlim/arm64",

"excerpts": [

"User application can query CPU features available to it through the
HWCAP mechanism. See documentation at kernel.org (available since
v4.15-rc1) for usage ..."

]

},

{

"title": "2873-inline-asm - The Rust RFC Book",

"url": "https://rust-lang.github.io/rfcs/2873-inline-asm.html",

"excerpts": [

"Rust provides support for inline assembly via the asm! macro. It can be
used to embed handwritten assembly in the assembly output generated by
the compiler."

]

},

{

"title": "Inline assembly - Rust By Example",

"url": "https://doc.rust-lang.org/rust-by-example/unsafe/asm.html",

"excerpts": [

"Rust provides support for inline assembly via the asm! macro. It can be
used to embed handwritten assembly in the assembly output generated by
the compiler."

]

},

{

"title": "2045-target-feature - The Rust RFC Book",

"url": "https://rust-lang.github.io/rfcs/2045-target-feature.html",

"excerpts": [

"A friendly compiler could use run-time feature detection to check
whether calling the function is safe and emit a nice panic! message.
This can be done, for ..."

]

},

{

"title": "Provide an example of querying Intel CPU capabilities ...",

"url":
"https://stackoverflow.com/questions/51851508/provide-an-example-of-querying-intel-cpu-capabilities-using-rusts-inline-assemb",

"excerpts": [

"I am trying to use inline assembly in Rust. The code I'm including is
supposed to query Intel CPU capabilities and right now I just want to
get ..."

]

},

{

"title": "Rust Internals: Better Codegen for CPU feature detection",

"url":
"https://internals.rust-lang.org/t/better-codegen-for-cpu-feature-detection/22083",

"excerpts": [

" 27, 2024, 7:26pm 1\nThe current codegen for feature detection macros
such as\nis_x86_feature_detected can be poor, especially if detection is
done at a fine level of granularity. One particular use case is an
&&-chain for multiple features, in which case it does the atomic load
each time ( Godbolt",

"See also cpufeatures - Rust , which chooses to cache the results it
gets.",

"\nCpufeatures uses atomics to cache the result just
like\nis_*_feature_detected! () . the8472 December 28, 2024, 3:22pm "

]

},

{

"title": "fixed-point - Rust Package Registry",

"url": "https://crates.io/crates/fixed-point",

"excerpts": [

"fixed-point v1.0.2. Fixed point numbers. Readme · 3 Versions ·
Dependencies · Dependents. fixed-point v1.0.2 appears to have no
README.md file ...",

"fixed-point - crates.io: Rust Package Registry",

"4,893\nDownloads all time",

"Repository\n----------\n\n[github.com/qiuchengxuan/fixed-point](https://github.com/qiuchengxuan/fixed-point)",

"Documentation\n-------------\n\n[docs.rs/fixed-point/1.0.2](https://docs.rs/fixed-point/1.0.2)",

"Metadata\n--------\n\npkg:cargo/fixed-point@1.0.2",

"The Rust community’s crate registry",

"fixed-point v1.0.2"

]

},

{

"title": "q_num - Rust - Docs.rs",

"url": "https://docs.rs/q-num",

"excerpts": [

"It uses ARM-style Q notation: Qm.n (signed) or UQm.n (unsigned) ... The
value of a Q number is the ratio of the storage number and a fixed
denominator."

]

},

{

"title": "q-num - crates.io: Rust Package Registry",

"url": "https://crates.io/crates/q-num",

"excerpts": [

"A Q number's value is the ratio of the stored number (having n + m
bits) and a fixed denominator (equal to 2 ^ n). For example, using the
UQ3.2 ..."

]

},

{

"title": "Fixed-Point Representation: The Q Format and Addition
Examples",

"url":
"https://www.allaboutcircuits.com/technical-articles/fixed-point-representation-the-q-format-and-addition-examples/",

"excerpts": [

"This article will first review the Q format to represent fractional
numbers and then give some examples of fixed-point addition."

]

},

{

"title": "CMSIS DSP Library - Arm Development Studio forum",

"url":
"https://community.arm.com/support-forums/f/armds-forum/2376/cmsis-dsp-library",

"excerpts": [

"I am interested in fixed point arithemetic. As per the documentation, i
have understood that Q7, Q15 and Q31 formats are only supported. Is ..."

]

},

{

"title": "Fixed-point arithmetic - Wikipedia",

"url": "https://en.wikipedia.org/wiki/Fixed-point_arithmetic",

"excerpts": [

"In computing, fixed-point is a method of representing fractional
(non-integer) numbers by storing a fixed number of digits of their
fractional part."

]

},

{

"title": "Fixed Point Arithmetic support - language design",

"url":
"https://internals.rust-lang.org/t/fixed-point-arithmetic-support/6110",

"excerpts": [

"Oct 24, 2017 — Fixed point arithmetic is a numeric type for
representing real numbers that has a fixed number of digits before and
after the radix point (ie the decimal)."

]

},

{

"title": "fixed crate - Crates.io",

"url": "https://crates.io/crates/fixed",

"excerpts": [

"* Representation of binary fixed-point numbers up to 128 bits wide. *
Conversions between fixed-point numbers and numeric primitives.",

"The fixed crate requires rustc version 1.83.0 or later.",

"Repository\ngitlab.com/tspiteri/fixed",

"The fixed crate is available on crates.io . To use it in your\ncrate,
add it as a dependency inside Cargo.toml :",

"[dependencies] fixed = \"1.29\"",

"Fixed-point numbers can be parsed from decimal strings using\nFromStr
,\nand from binary, octal and hexadecimal strings using
the\nfrom_str_binary ,\nfrom_str_octal and\nfrom_str_hex method",

"* Conversions between fixed-point numbers and numeric primitives.",

" License\nThis crate is free software: you can redistribute it and/or
modify it under the\nterms of either\n * the Apache License, Version 2.0
or\n",

"Report crate\nStats Overview\n5,702,373 Downloads all time",

"The fixed crate provides fixed-point numbers.",

"The *fixed* crate is available on
[crates.io](https://crates.io/crates/fixed)."

]

},

{

"title": "Docs.rs - fixed",

"url": "https://docs.rs/fixed",

"excerpts": [

"The fixed crate provides fixed-point numbers.",

"FixedI8",

"An eight-bit signed number with",

"Frac fractional bits.",

"FixedI16",

"FixedU16",

"Saturating",

" * Provides saturating arithmetic on fixed-point numbers."

]

},

{

"title": "fix - Rust - Docs.rs",

"url": "https://docs.rs/fix",

"excerpts": [

"Fixed-point is a number representation with a fixed number of digits
before and after the radix point. This means that range is static rather
than dynamic."

]

},

{

"title": "WuBingzheng/primitive_fixed_point_decimal: Primitive
fixed-point ...",

"url": "https://github.com/WuBingzheng/primitive_fixed_point_decimal",

"excerpts": [

"Missing: saturating modes"

]

},

{

"title": "fixnum - Rust - Docs.rs",

"url": "https://docs.rs/fixnum",

"excerpts": [

"Saturating multiplication. This is multiplication without rounding,
hence it's available only when at least one operand is integer.
saturating_rmul, let z: ..."

]

},

{

"title": "Talk:Q (number format)",

"url": "https://en.wikipedia.org/wiki/Talk%3AQ_(number_format)",

"excerpts": [

"Range Error in Article · A common usage is storing a Q15 value in a
16-bit signed integer object, so we have N=16 and Q=15. According to the
article, the range ..."

]

},

{

"title": "How Fixed-Point Math Works - for(embed)",

"url": "http://forembed.com/how-fixed-point-math-works.html",

"excerpts": [

"A Q16. 16 number has twice the 'resolution' as a Q1. 15, because the
number to the right of the decimal has one more bit."

]

},

{

"title": "arm_add_q31.c",

"url":
"https://github.com/ARM-software/CMSIS/blob/master/CMSIS/DSP_Lib/Source/BasicMathFunctions/arm_add_q31.c",

"excerpts": [

"The function uses saturating arithmetic. Results outside of the
allowable Q31 range[0x80000000 0x7FFFFFFF] will be saturated."

]

},

{

"title": "Mathematical functions in the standard library are non- ...",

"url":
"https://www.reddit.com/r/rust/comments/1gek2bb/mathematical_functions_in_the_standard_library/",

"excerpts": [

"You do have to make sure all platforms use the same rounding mode but
as far as I'm aware all major platforms default to
round-to-nearest-even."

]

},

{

"title": "performance of saturating_mul can be improved by ...",

"url": "https://github.com/rust-lang/rust/issues/65309",

"excerpts": [

"Oct 11, 2019 — saturating_mul(b) }. #[inline] const fn
cond_if_else(cond: bool, a: i32, b: i32) -> i32 { // If cond is false:
not_mask is -1 == all ones // If ..."

]

},

{

"title": "CMSIS-DSP Fixed-Point, Q-Format, and Rust Fixed-Point Crates
Overview",

"url":
"https://arm-software.github.io/CMSIS_5/DSP/html/group__BasicAdd.html",

"excerpts": [

"Scaling and Overflow Behavior\n: The function uses saturating
arithmetic. Results outside of the allowable Q31 range [0x80000000
0x7FFFFFFF] are saturat"

]

},

{

"title": "Fixed-point numbers",

"url": "https://crates.io/crates/fixed/1.6.0",

"excerpts": [

"Feb 5, 2021 — The fixed crate provides fixed-point numbers. These types
can have Frac fractional bits, where 0 ≤ Frac ≤ n and n is the total
number of bits.See more"

]

},

{

"title": "irox-fixedmath - crates.io: Rust Package Registry",

"url": "https://crates.io/crates/irox-fixedmath",

"excerpts": [

"IROX-FIXEDMATH. Fixed Precision Math Primitives. Wikipedia's article on
Fixed-point arithmetic. All of the fractional components are scaled ..."

]

},

{

"title": "fixed - crates.io: Rust Package Registry",

"url": "https://crates.io/crates/fixed/0.3.1",

"excerpts": [

"The fixed crate provides fixed-point numbers. ... Using the fixed
crate. The fixed crate is available on crates.io. ...
gitlab.com/tspiteri/fixed. Owners. Trevor ..."

]

},

{

"title": "substrate_fixed - Rust - Docs.rs",

"url": "https://docs.rs/substrate-fixed",

"excerpts": [

"Missing: Q15. Q1. 31"

]

},

{

"title": "[PDF] TMS320C64x+ IQmath Library User's Guide - Texas
Instruments",

"url": "https://www.ti.com/lit/pdf/sprugg9",

"excerpts": [

"Input/output of the IQmath functions are typically 32-bit fixed-point
numbers and the Q format of the fixed-point number can vary from Q0 to
Q31 ..."

]

},

{

"title": "Fixed-point calculation using CMSIS_library or libfixmath",

"url":
"https://devzone.nordicsemi.com/f/nordic-q-a/45309/fixed-point-calculation-using-cmsis_library-or-libfixmath",

"excerpts": [

"The library has Q31 or Q15 format but I'm confused about using it
right. Firstly, although the CMSIS DSP library supports fractional
numbers ..."

]

},

{

"title": "How can we correctly use the CMSIS-DSP functions that ...",

"url":
"https://dsp.stackexchange.com/questions/80690/how-can-we-correctly-use-the-cmsis-dsp-functions-that-have-fixed-point-qx-inpu",

"excerpts": [

"My main question here is about how to interpret the output of CMSIS-DSP
functions that have input/outputs in Q7/Q15/Q31 format."

]

},

{

"title": "Relative merits of fixed point vs floating point
computation?",

"url":
"https://dsp.stackexchange.com/questions/4835/relative-merits-of-fixed-point-vs-floating-point-computation",

"excerpts": [

"Oct 29, 2012 — The numerical accuracy of integers will only be better
than the numerical accuracy of floats if the integer resolution is
better."

]

},

{

"title": "Fun With Saturating Arithmetic",

"url": "https://blog.regehr.org/archives/277",

"excerpts": [

"Oct 5, 2010 — This can be accomplished for unsigned addition by, for
example, repeatedly incrementing one of the arguments and decrementing
the other, ..."

]

},

{

"title": "std::add_sat",

"url": "https://en.cppreference.com/w/cpp/numeric/add_sat.html",

"excerpts": [

"Feb 5, 2024 — Computes the saturating addition x + y. This operation
(unlike built-in arithmetic operations on integers) behaves as-if it is
a mathematical operation with an ..."

]

},

{

"title": "Fixed-point arithmetics uses : r/embedded - Reddit",

"url":
"https://www.reddit.com/r/embedded/comments/1j2axe3/fixedpoint_arithmetics_uses/",

"excerpts": [

"Very likely fixed point is faster if you stay in it. Also note that
many CPUs and DSPs have more fixed point ALUs than floating point, so
even ..."

]

},

{

"title": "Floating-point face-off, part 2: Comparing performance",

"url":
"https://blog.segger.com/floating-point-face-off-part-2-comparing-performance/",

"excerpts": [

"Only 26 cycles on average for a multiplication, 31 cycles for addition
mean that a Cortex-M4 can execute a floating point computation in ..."

]

},

{

"title": "Fixed-Point DSP for Data Scientists | by Sandeep Mistry -
Medium",

"url":
"https://medium.com/data-science/fixed-point-dsp-for-data-scientists-d773a4271f7f",

"excerpts": [

"Introduction to fixed-point math and CMSIS-DSP Arm Cortex-M processors
are faster at integer based calculations than floating-point
operations."

]

},

{

"title": "WebAssembly has 64-bit integers and 32-bit floating points
...",

"url": "https://news.ycombinator.com/item?id=19884367",

"excerpts": [

"WebAssembly has 64-bit integers and 32-bit floating points, which is
difficult to do fast in JavaScript because everything is 64-bit floating
points there."

]

},

{

"title": "Is fixed point math faster than floating point? - Stack
Overflow",

"url":
"https://stackoverflow.com/questions/36392638/is-fixed-point-math-faster-than-floating-point",

"excerpts": [

"Fixed point generally doesn't provide much of an advantage in speed
though, because of its limited representation range: how many bits would
you ..."

]

},

{

"title": "Tonc: Fixed-Point Numbers and LUTs - Coranac",

"url": "https://www.coranac.com/tonc/text/fixed.htm",

"excerpts": [

"Missing: saturating vectors"

]

},

{

"title": "substrate-fixed - crates.io: Rust Package Registry",

"url": "https://crates.io/crates/substrate-fixed/dependencies",

"excerpts": [

"Typenum is a Rust library for type-level numbers evaluated at compile
time. It currently supports bits, unsigned integers, and signed
integers."

]

},

{

"title": "Fixed-point numbers and the fixed crate (tspiteri/fixed) -
GitLab README and docs",

"url": "https://gitlab.com/tspiteri/fixed",

"excerpts": [

"The *fixed* crate is available on
[crates.io](https://crates.io/crates/fixed).",

"[dependencies]\nfixed = \"1.29\"",

"The main features are\n\n* Representation of binary fixed-point numbers
up to 128 bits wide. * Conversions between fixed-point numbers and
numeric primitives. * Comparisons between fixed-point numbers and
numeric primitives. * Parsing from strings in decimal, binary, octal and
hexadecimal. * Display as decimal, binary, octal and hexadecimal. *
Arithmetic and logic operations.",

"The crate now requires rustc version 1.83.0 or later.",

"8 — The cordic crate provides various functions implemented using the
CORDIC algorithm.",

"The second example shows some precision and conversion issues. The low
precision\nof `a` means that `a / 5` is 3⁄16 instead of 1⁄5, leading to
an inaccurate\nresult `ans1` = 3 3⁄16 (~3.2). With a higher precision,
we get `wider_a / 5`\nequal to 819⁄4096, leading to a more accurate
intermediate result `wider_ans` =\n3 1635⁄409",

"The type
[`I20F12`](https://docs.rs/fixed/~1.29/fixed/types/type.I20F12.html) is
a 32-bit fixed-point signed number with 20 integer bits\nand 12
fractional bits. It is an alias to `FixedI32<U12>`."

]

},

{

"title": "substrate-fixed",

"url": "https://crates.io/crates/substrate-fixed",

"excerpts": [

"This crate ist ported from\nfixed = 0.5.4 . It has been adapted to be
usable within substrate runtimes. Additionally, transcendental functions
have been added (log, exp, pow, trigonometry). Please also have a look
at our encointer-js libraries to learn how to parse fixpoint values for
javascript UIs. The [ substrate-fixed crate] provides fixed-point
numbers. * FixedI8 and\nFixedU8 are eight-bit fixed-point numbers. *
FixedI16 and\nFixedU16 are 16-bit fixed-point numbers. * FixedI32
and\nFixedU32 are 32-bit fixed-point numbers. * FixedI64 and\nFixedU64
are 64-bit fixed-point numbers. * FixedI128 and\nFixedU128 are 128-bit
fixed-point numbers. These types can have\nFrac fractional bits,
where\n0 ≤ \nFrac  ≤  n and n is the total number of bits. When\nFrac
 = 0, the fixed-point number behaves like an n -bit\ninteger. When\nFrac
 =  n , the value x lies in the range\n−0.5 ≤  x  < 0.5 for signed
numbers, and in the range\n0 ≤  x  < 1 for unsigned numbers.\nCurrently
the typenum crate is used for the fractional bit count\nFrac ; it is
planned to move to const generics when they are\nsupported by the Rust
compiler. The main features are\n * Representation of fixed-point
numbers up to 128 bits wide. * Conversions between fixed-point numbers
and numeric primitives. * Comparisons between fixed-point numbers and
numeric primitives. * Parsing from strings in decimal, binary, octal and
hexadecimal. * Display as decimal, binary, octal and hexadecimal. *
Arithmetic and logic operations. The conversions supported cover the
following cases. * Infallible lossless conversions between fixed-point
numbers and\nnumeric primitives are provided using\nFrom and\nInto .
These\nnever fail (infallible) and do not lose any bits (lossless). *
Infallible lossy conversions between fixed-point numbers and\nnumeric
primitives are provided using the\nLossyFrom and\nLossyInto traits. The
source can have more fractional bits\nthan the destination. * Checked
conversions between fixed-point numbers and numeric\nprimitives are
provided using the\nFromFixed and\nToFixed traits, or using
the\nfrom_num and\nto_num methods and their checked versions . *
Fixed-point numbers can be parsed from decimal strings using\nFromStr ,
and from binary, octal and hexadecimal strings
using\nthe\nfrom_str_binary ,\nfrom_str_octal and\nfrom_str_hex methods.
The result is rounded to the nearest, with ties rounded\nto even.\n*
Fixed-point numbers can be converted to strings using\nDisplay ,\nBinary
,\nOctal ,\nLowerHex and\nUpperHex . The output\nis rounded to the
nearest, with ties rounded to even. Upstream releases\nDetails on other
releases can be found in RELEASES.md . Quick examples\nuse
substrate_fixed::types::I20F12; // 19/3 = 6 1/3 let six_and_third =
I20F12:: from_num ( 19 ) / 3 ; // four decimal digits for 12 binary
digits assert_eq! (six_and_third. to_string (), \"6.3333\" ); // find
the ceil and convert to i32 assert_eq! (six_and_third. ceil ().to_num::<
i32 >(), 7 ); // we can also compare directly to integers assert_eq!
(six_and_third. ceil (), 7 );\nThe type\nI20F12 is a 32-bit fixed-point
signed number with 20\ninteger bits and 12 fractional bits. It is an
alias to\nFixedI32 < U12 > . The unsigned\ncounterpart would be\nU20F12
. Aliases are provided for all\ncombinations of integer and fractional
bits adding up to a total of\neight, 16, 32, 64 or 128 bits. use
substrate_fixed::types::{I4F4, I4F12}; // −8 ≤ I4F4 < 8 with steps of
1/16 (~0.06) let a = I4F4:: from_num ( 1 ); // multiplication and
division by integers are possible let ans1 = a / 5 * 17 ; // 1 / 5 × 17
= 3 2/5 (3.4), but we get 3 3/16 (~3.2) assert_eq! (ans1, I4F4::
from_bits (( 3 << 4 ) + 3 )); assert_eq! (ans1.\nto_string (), \"3.2\"
); // −8 ≤ I4F12 < 8 with steps of 1/4096 (~0.0002) let wider_a =
I4F12:: from (a); let wider_ans = wider_a / 5 * 17 ; let ans2 = I4F4::
from_num (wider_ans); // now the answer is the much closer 3 6/16 (~3.4)
assert_eq! (ans2, I4F4:: from_bits (( 3 << 4 ) + 6 )); assert_eq! (ans2.
to_string (), \"3.4\" );\nThe second example shows some precision and
conversion issues. The low\nprecision of\na means that\na / 5 is 3⁄16
instead of 1⁄5, leading to\nan inaccurate result\nans1 = 3 3⁄16 (~3.2).
With a higher precision,\nwe get\nwider_a / 5 equal to 819⁄4096, leading
to a more accurate\nintermediate result\nwider_ans = 3 1635⁄4096. When
we convert back to\nfour fractional bits, we get\nans2 = 3 6⁄16 (~3.4).
Note that we can convert from\nI4F4 to\nI4F12 using\nFrom , as\nthe
target type has the same number of integer bits and a larger\nnumber of
fractional bits. Converting from\nI4F12 to\nI4F4 cannot use\nFrom as we
have less fractional bits, so we use\nfrom_num instead. Using the
substrate-fixed crate\nThe substrate-fixed is available on crates.io .
Optional features\nThe fixed crate has four optional feature:\n * az ,
disabled by default. This implements the cast traits\nprovided by the az
crate . * f16 , disabled by default. This provides conversion
to/from\nf16 and\nbf16 . This features requires the half crate . * serde
, disabled by default. This provides serialization support\nfor the
fixed-point types. This feature requires the serde crate . * std ,
disabled by default.\nThis is for features that are not\npossible
under\nno_std : currently the implementation of the\nError trait
for\nParseFixedError . To enable features, you can add the dependency
like this to Cargo.toml :\n[dependencies.fixed] default-features = false
git = \"https://github.com/encointer/substrate-fixed\" package =
\"substrate-fixed\" features = [ \"f16\" , \"serde\" ]\nLicense\nThis
crate is free software: you can redistribute it and/or modify it\nunder
the terms of either\n * the Apache License, Version 2.0 or\n * the MIT
License\n\nat your option. Contribution\nUnless you explicitly state
otherwise, any contribution intentionally\nsubmitted for inclusion in
the work by you, as defined in the Apache\nLicense, Version 2.0, shall
be dual licensed as above, without any\nadditional terms or conditions.
Metadata\npkg:cargo/substrate-fixed@0.6.0 4 months ago 2018 edition MIT
OR Apache-2.0\n112 KiB\nInstall\nRun the following Cargo command in your
project directory:\ncargo add substrate-fixed\nOr add the foll",

"substrate-fixed v0.6.0",

"Fixed-point numbers for substrate",

"64,079 Downloads all time",

"Repository\ngithub.com/encointer/substrate-fixed"

]

},

{

"title": "Crate mat - Rust",

"url": "https://docs.rs/mat",

"excerpts": [

"Statically sized matrices for no_std applications. This library
provides support for creating and performing mathematical operations on
statically sized ..."

]

},

{

"title": "DMat3 in glam::f64 - Rust - Docs.rs",

"url": "https://docs.rs/glam/latest/glam/f64/struct.DMat3.html",

"excerpts": [

"Creates a 3x3 matrix from a [f64; 9] array stored in column major
order. If your data is stored in row major you will need to transpose
the returned matrix."

]

},

{

"title": "bitshifter/mathbench-rs - GitHub",

"url": "https://github.com/bitshifter/mathbench-rs",

"excerpts": [

"Missing: Mat2 Mat3",

"The versions of the libraries tested were:\n * cgmath -\n0.18.0\n *
euclid -\n0.22.6\n * glam -\n0.20.1\n * nalgebra -\n0.29.0\n *
pathfinder_geometry -\n0.5.1\n * static-math -\n0.2.3\n * ultraviolet
-\n0.8.1\n * vek -\n0.15.3 (\nrepr_c types)",

"glam` - `0.20.1",

"nalgebra` - `0.29.0",

"ultraviolet` - `0.8.1",

"Benchmark results\nThe following is a table of benchmarks produced
by\nmathbench comparing\nglam performance to\ncgmath ,\nnalgebra
,\neuclid ,\nvek ,\npathfinder_geometry ,\nstatic-math and\nultraviolet
on\nf32 data.",

"benchmark: matrix2 inverse\n * benchmark: 2.8226 ns\n * benchmark:
8.4418 ns\n * benchmark: 7.6303 ns\n * benchmark: N/A\n * benchmark:
N/A\n * benchmark: 3.3459 ns\n * benchmark: 9.4636 ns\n * benchmark:
5.8796 ns",

"mathbench is a suite of unit tests and benchmarks comparing the output
and\nperformance of a number of different Rust linear algebra libraries
for common\ngame and graphics development tasks.",

"\n\nThe benchmarks are currently focused on\nf32 types as that is
all\nglam currently supports.",

"* benchmark: matrix2 determinant\n * benchmark: 2.0386 ns\n *
benchmark: 2.0999 ns\n * benchmark: 2.1018 ns\n * benchmark: N/A\n *
benchmark: 2.0997 ns\n * ",

"benchmark: matrix2 mul matrix2\n * benchmark: 2.6036 ns\n * benchmark:
5.0007 ns\n * benchmark: 4.8172 ns\n * benchmark: N/A\n * benchmark:
9.3814 ns\n * benchmark: 2.5516 ns\n * benchmark: 4.7274 ns\n *
benchmark: 4.9428 ns",

"benchmark: matrix2 mul vector2 x1\n * benchmark: 2.4904 ns\n *
benchmark: 2.6144 ns\n * benchmark: 2.8714 ns\n * benchmark: N/A\n *
benchmark: 4.2139 ns\n * benchmark: 2.0839 ns\n * benchmark: 2.8873 ns\n
* benchmark: 2.6250 ns"

]

},

{

"title": "Show /r/rust: Optimath, linear algebra with const generics
...",

"url":
"https://www.reddit.com/r/rust/comments/eo4ury/show_rrust_optimath_linear_algebra_with_const/",

"excerpts": [

"I started this library because there was no no_std capable linear
algebra library available. Just a quick note that nalgebra works on
no_std, using generic- ..."

]

},

{

"title": "matrix-rs — Rust math library // Lib.rs",

"url": "https://lib.rs/crates/matrix-rs",

"excerpts": [

"213 lines",

"Library for using matrices in rust. Uses const generics to ensure
compile-time matrix safety. Examples: use matrix_rs::*; fn
matrix_3x3_1to9() - ...",

"Library for using matrices in rust. Uses const generics to ensure
compile-time matrix safety.",

"Examples:",

"matrix-rs",

"matrix-rs",

"=========",

"========="

]

},

{

"title": "glam - Rust - Docs.rs",

"url": "https://docs.rs/glam/latest/glam/",

"excerpts": [

"Some glam types use SIMD for storage meaning they are 16 byte aligned,
these types include Mat2 , Mat3A , Mat4 , Quat , Vec3A , Vec4 , Affine2
an Affine3A ."

]

},

{

"title": "Trick for 2×2 eigenvalues",

"url":
"https://www.johndcook.com/blog/2021/05/07/trick-for-2x2-eigenvalues/",

"excerpts": [

"May 7, 2021 — The most common way to find the eigenvalues of a 2×2
matrix A is working straight from the definition, solving det(A − λI) =
0."

]

},

{

"title": "Chapter 3. Coordinate transformations",

"url":
"https://motion.cs.illinois.edu/RoboticSystems/CoordinateTransformations.html",

"excerpts": [

"Homogeneous coordinates: A way to represent rigid transforms as linear
transforms (matrices). A 3x3 (in 2D) or 4x4 (in 3D) matrix that contains
the rotation ..."

]

},

{

"title": "Mini Matrix Library (crates.io) - crate description and docs",

"url": "https://crates.io/crates/mini-matrix",

"excerpts": [

"cargo add mini_matrix",

"mini-matrix v0.1.6",

"Features",

" * Vector and Matrix Operations",

" * Linear Combination",

" * Linear Interpolation (Lerp)",

" * Dot Product",

" * Norms (1-norm, 2-norm, ∞-norm)",

" * Angle Cosine",

" * Cross Product",

" * Matrix Multiplication",

" * Trace",

" * Transpose",

" * Reduced Row Echelon Form (RREF)",

" * Determinant",

" * Inverse",

" * Rank",

"docs.rs/mini-matrix/0.1.6",

"pkg:cargo/mini-matrix@0.1.6",

"Then import the modules and you're done! use mini_matrix::Matrix; //
Create a 2x2 matrix: let a = Matrix:: from ([",

"Usage",

"The crate is currently on version 0.1.5 . The",

"main function allows you to run different exercises based on a
command-line argument specifying the exercise number.",

"Summary",

"mini_matrix is a lightweight linear algebra library written in Rust,
designed to provide fundamental matrix and vector operations without
heavy external dependencies.",

"mini_matrix is a lightweight linear algebra library written in Rust,
designed to provide fundamental matrix and vector operations without
heavy external dependencies.",

"You can find the documentation for this project docs . Installation",

"The library is most easily used with cargo . Simply include the
following in your",

"Cargo.toml file:",

"[dependencies] num = \"0.4.3\"",

"or use the following command:",

"And then import the library using:",

"#[macro_use] extern crate mini_matrix;",

"[",

" 1.0 , 2.0 ],",

"[ 3.0 , 4.0 ],",

"]); // Create a 2x3 matrix: let b = Matrix:: from ([",

"[ 1.0 , 2.0 ],",

"[ 4.0 , 5.0 ],",

"]); let c = a * b; // Matrix product of a and b let expected = Matrix::
from ([[ 5.0 , 14.0 ], [ 11.0 , 32.0 ]]); assert_eq! (c, expected)",

"2.5 MiB",

"Apache-2.0",

"Documentation"

]

},

{

"title": "tinymatrix — Rust math library // Lib.rs",

"url": "https://lib.rs/crates/tinymatrix",

"excerpts": [

"tiny-matrix. A tiny library to operate with linear algebra in Rust
programming language. No runtime deps."

]

},

{

"title": "mini_matrix - Rust",

"url": "https://docs.rs/mini-matrix",

"excerpts": [

"A generic matrix type with M rows and N columns. Vector: Represents a
vector of N elements of type T . Functions§. angle_cos: Calculates the
cosine of ..."

]

},

{

"title": "mat-rs - crates.io: Rust Package Registry",

"url": "https://crates.io/crates/mat-rs",

"excerpts": [

"Jan 16, 2024 — mat_rs. A no_std implementation of mathematical matrix
types in rust. ⚠️ WIP. This library is functional, but not done."

]

},

{

"title": "Math — list of Rust libraries/crates ...",

"url": "https://lib.rs/science/math",

"excerpts": [

"Operates on matrices with general layout (they can use arbitrary row
and column stride). Detects and uses AVX or SSE2 on x86… v0.3.10 3.8M
no-std ..."

]

},

{

"title": "Floating Point Arithmetic in Constants : r/learnrust -
Reddit",

"url":
"https://www.reddit.com/r/learnrust/comments/v0o0ik/floating_point_arithmetic_in_constants/",

"excerpts": [

"Floating point arithmetic is not currently supported as const. If you
have a const value that you want to have known at compile-time you
should ...",

"I'm attempting to set up constants for a program that are based off of
previous constants combined using multiplication, division, as well as
one square root ..."

]

},

{

"title": "Our floating point semantics were a mess · Issue #237",

"url": "https://github.com/rust-lang/unsafe-code-guidelines/issues/237",

"excerpts": [

"Jun 14, 2020 — Tracking issue for
#![feature(const_fn_floating_point_arithmetic)] rust-lang/rust#57241 ·
RalfJung. mentioned this on Sep 9, 2020 · Tracking ..."

]

},

{

"title": "Stabilizing a const generics MVP - language design - Rust
Internals",

"url":
"https://internals.rust-lang.org/t/stabilizing-a-const-generics-mvp/12727",

"excerpts": [

"There is an MVP of const generics which has a solid implementation and
a strong consensus on its design. We've been using it in std for over
..."

]

},

{

"title": "Inline const has been stabilized! : r/rust - Reddit",

"url":
"https://www.reddit.com/r/rust/comments/1cc9pz0/inline_const_has_been_stabilized/",

"excerpts": [

"Constant propagation and const are almost entirely independent
concepts. The optimization (constant propagation) is much stronger;
expressions ..."

]

},

{

"title": "f64",

"url": "https://doc.rust-lang.org/std/primitive.f64.html",

"excerpts": [

"A 64-bit floating point type (specifically, the “binary64” type defined
in IEEE 754-2008). This type is very similar to f32, but has increased
precision by ..."

]

},

{

"title": "It's not quite as bad as it sounds, because the only
difference is that ...",

"url": "https://news.ycombinator.com/item?id=43445337",

"excerpts": [

"In particular, FP ops in const contexts are currently limited as
follows: \"This RFC specifies the behavior of +, - (unary and binary),
*, /, %, abs, copysign, ..."

]

},

{

"title": "bluss/matrixmultiply: General matrix multiplication of f32
...",

"url": "https://github.com/bluss/matrixmultiply",

"excerpts": [

"General matrix multiplication for f32, f64, and complex matrices.
Operates on matrices with general layout (they can use arbitrary row and
column stride)."

]

},

{

"title": "tinymatrix crate page",

"url": "https://crates.io/crates/tinymatrix",

"excerpts": [

"tinymatrix v0.1.0",

"tiny-matrix. A tiny library to operate with linear algebra in Rust
programming language. Metadata",

"github.com/kaikecarlos/tinymatrix",

" A tiny library to operate with linear algebra in Rust programming
language.",

"pkg:cargo/tinymatrix@0.1.0",

"about 2 years ago 2021 edition MIT",

"Documentation",

"Repository",

"2.96 KiB",

"tinymatrix = \"0.1.0\""

]

},

{

"title": "Docs for small_matrix crate - matrix module",

"url":
"https://docs.rs/small_matrix/latest/small_matrix/matrix/index.html",

"excerpts": [

"This crate provides a `Matrix` structure, with many helpful trait
implementations to perform calculations between matrices, but with
absolutely no allocations."

]

},

{

"title": "static_math - Rust",

"url": "https://docs.rs/static-math/",

"excerpts": [

"Docs.rs. static-math-0.2.3. static-math 0.2.3; Permalink ...
static-math. Safe and fast mathematical operations with static arrays in
Rust programming language ..."

]

},

{

"title": "nalgebra 0.34.0",

"url": "https://docs.rs/crate/nalgebra/latest/source/CHANGELOG.md",

"excerpts": [

"- Added special-cases implementations for the 2x2 and 3x3 SVDs for
better accuracy and performances. ... const fn`, making them usable to
define constant globals."

]

},

{

"title": "Cramer's rule",

"url": "https://en.wikipedia.org/wiki/Cramer%27s_rule",

"excerpts": [

"This gives a formula for the inverse of A, provided det(A) ≠ 0. In
fact, this formula works whenever F is a commutative ring, provided that
det(A) is a unit."

]

},

{

"title": "small_matrix - crates.io: Rust Package Registry",

"url": "https://crates.io/crates/small_matrix/0.5.0",

"excerpts": [

"Install. cargo install small_matrix@0.5.0. Running the above command
will globally install the small_matrix binary. Install as library."

]

},

{

"title": "linear_combination in mini_matrix - Rust",

"url":
"https://docs.rs/mini-matrix/latest/mini_matrix/fn.linear_combination.html",

"excerpts": [

"Computes the linear combination of a set of vectors. A linear
combination is the sum of scalar multiples of vectors."

]

},

{

"title": "matrix in nalgebra - Rust - Docs.rs",

"url": "https://docs.rs/nalgebra/latest/nalgebra/macro.matrix.html",

"excerpts": [

"This macro facilitates easy construction of matrices when the entries
of the matrix are known (either as constants or expressions)."

]

},

{

"title": "glam - crates.io: Rust Package Registry",

"url": "https://crates.io/crates/glam",

"excerpts": [

"A simple and fast 3D math library for games and graphics. Development
status glam is in beta stage. Base functionality has been implemented
and the look and ..."

]

},

{

"title": "Matrix2 in ira::nalgebra - Rust - Docs.rs",

"url": "https://docs.rs/ira/latest/ira/nalgebra/type.Matrix2.html",

"excerpts": [

"For all matrices and vectors, independently from their size, individual
components can be accessed and modified using indexing: vec[20] ,
mat[(20, 19)] . Here ..."

]

},

{

"title": "Matrix2 in nalgebra::base - Rust",

"url": "https://rustdocs.bsx.fi/nalgebra/base/type.Matrix2.html",

"excerpts": [

"A stack-allocated, column-major, 2x2 square matrix. Because this is an
alias, not all its methods are listed here. See the Matrix type too."

]

},

{

"title": "stabilize-const_fn_floating_point_arithmetic.patch",

"url":
"https://searchfox.org/mozilla-central/source/build/build-rust/stabilize-const_fn_floating_point_arithmetic.patch",

"excerpts": [

"+ /// Allows basic arithmetic on floating point types in a `const fn`.
+ (accepted, const_fn_floating_point_arithmetic,
\"CURRENT_RUSTC_VERSION\", Some(57241)),."

]

},

{

"title": "Is float comparison sound in const context?",

"url":
"https://users.rust-lang.org/t/is-float-comparison-sound-in-const-context/108459",

"excerpts": [

"As mentioned in the issue you linked, the problem is that a const fn
can be evaluated both at compile-time and at run-time, and the results
..."

]

},

{

"title": "RFC: make all f32/f64 methods const - libs",

"url":
"https://internals.rust-lang.org/t/rfc-make-all-f32-f64-methods-const/12612",

"excerpts": [

"Jun 22, 2020 — I'm defining some f64 consts as literals, but it would
be nice if I could express intent by writing them as a calculation using
const fns."

]

},

{

"title": "Best practice of extending a no_std crate - help",

"url":
"https://users.rust-lang.org/t/best-practice-of-extending-a-no-std-crate/12281",

"excerpts": [

"Aug 9, 2017 — Implement the set of the functionality working with
no_std in a \"core crate\" and extend the functionality with a new crate
depending on the original crate."

]

},

{

"title": "static-math Crate Documentation",

"url": "https://crates.io/crates/static-math",

"excerpts": [

"static-math\nv0.2.3\n==================\n\nFast mathematical operations
with static arrays, without `unsafe` code",

"* This crate take advantage of the static arrays in Rust for fast
operations in\n stack memory. * We use a tuple to indexing elements:
`m[(i, j)]` allowing nice interface with the `match` feature of Rust",

"* No `unsafe` code :ballot\\_box\\_with\\_che",

"* Could be optimize more with the use of SIMD\n* This crate could be
used in an `no-std` environment. by enabling the feature `no-std`, for
example in your `Cargo.toml`:\n\n ```\n [dependencies.static-math]\n
default-features = false\n version = \"0.2.0\"\n features =
[\"no-std\"]\n\n ```"

]

},

{

"title": "small_matrix",

"url": "https://crates.io/crates/small_matrix",

"excerpts": [

"small_matrix. A simple matrix library made in Rust. Metadata.",

"pkg:cargo/small_matrix@0.5.0",

"almost 4 years ago",

"2018 edition",

"GPL-3.0+",

"3.45 KiB",

"A simple matrix library made in Rust. small\\_matrix - crates.io: Rust
Package Registr"

]

},

{

"title": "wyhash - Rust",

"url": "https://docs.rs/wyhash",

"excerpts": [

"Wyhash is a Rust implementation of the wyhash algorithm, which is fast,
solid, simple, portable, and has no dependencies. It is the fastest in
SMHasher ...",

"Rust implementation of the wyhash algorithm by Wang Yi. The hashing
algorithm passes SMHasher and the random number generator passes
BigCrush and practrand."

]

},

{

"title": "twox-hash - crates.io: Rust Package Registry",

"url": "https://crates.io/crates/twox-hash/dependencies",

"excerpts": [

"A Rust implementation of the XXHash and XXH3 algorithms."

]

},

{

"title": "xxhash - Keywords - crates.io: Rust Package Registry",

"url": "https://crates.io/keywords/xxhash",

"excerpts": [

"All Crates for keyword 'xxhash' · twox-hash v2.1.1. A Rust
implementation of the XXHash and XXH3 algorithms · xxhash-rust v0.8.15.
Implementation of xxhash."

]

},

{

"title": "Releases · wangyi-fudan/wyhash",

"url": "https://github.com/wangyi-fudan/wyhash/releases",

"excerpts": [

"Feb 5, 2023 — wyhash & wyrand release version 1. wyhash test vectors:
wyhash(\"\",0)=f961f936e29c9345 wyhash(\"a\",1)=6dc395f88b363baa
wyhash(\"abc\",2)= ...",

"test\nvectors:\nwyhash(\"\",0)=f961f936e29c9345",

"wyhash(\"abc\",2)=3bc9d7844798ddaa",

"wyhash(\"message digest\",3)=b31238dc2c500cd3",

"wyhash(\"abcdefghijklmnopqrstuvwxyz\",4)=ea0f542c58cddfe4",

"wyhash(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\",5)=1799aca591fe73b4",

"wyhash(\"12345678901234567890123456789012345678901234567890123456789012345678901234567890\",6)=7f0d02f53d64c1f9",

"wyrand code:\ninline unsigned long long wyrand(unsigned long long
*seed){ *seed+=0xa0761d6478bd642full; __uint128_t
t=(__uint128_t)(*seed^0xe7037ed1a0b428dbull)*(*seed); return (t>>64)^t;
}"

]

},

{

"title": "ahash - crates.io: Rust Package Registry",

"url": "https://crates.io/crates/ahash/0.5.6",

"excerpts": [

"Oct 21, 2020 — A non-cryptographic hash function using AES-NI for high
performance. #hash · #aes · #hashmap · #hasher · #no-std · Readme · 95
Versions ..."

]

},

{

"title": "fxhash - crates.io: Rust Package Registry",

"url": "https://crates.io/crates/fxhash/dependencies",

"excerpts": [

"fxhash v0.2.1 A fast, non-secure, hashing algorithm derived from an
internal hasher used in FireFox and Rustc."

]

},

{

"title": "User Guide - Criterion.rs Documentation",

"url":
"https://bheisler.github.io/criterion.rs/book/user_guide/user_guide.html",

"excerpts": [

"User Guide. This chapter covers the output produced by Criterion.rs
benchmarks, both the command-line reports and the charts. It also
details more advanced ...See more"

]

},

{

"title": "std::hash - Rust",

"url": "https://doc.rust-lang.org/std/hash/index.html",

"excerpts": [

"This module provides a generic way to compute the hash of a value.
Hashes are most commonly used with HashMap and HashSet."

]

},

{

"title": "rand performs unaligned memory access (and invalid raw ptr
usage)",

"url": "https://github.com/rust-random/rand/issues/779",

"excerpts": [

"In Rust, all accesses must be aligned on all platforms, no matter what
the CPU says; any unaligned access causes UB (on all platforms)."

]

},

{

"title": "rurban/smhasher: Hash function quality and speed tests -
GitHub",

"url": "https://github.com/rurban/smhasher",

"excerpts": [

"Missing: microbenchmark pitfalls"

]

},

{

"title": "Criterion.rs - Statistics-driven benchmarking library for
Rust",

"url": "https://github.com/bheisler/criterion.rs",

"excerpts": [

"Criterion.rs helps you write fast code by detecting and measuring
performance improvements or regressions, even small ones, quickly and
accurately.See more"

]

},

{

"title": "Hashing and Validation of xxHash in C# Implementation -
MojoAuth",

"url": "https://mojoauth.com/hashing/xxhash-in-c/",

"excerpts": [

"Missing: microbenchmark wyhash"

]

},

{

"title": "criterion - Rust",

"url": "https://docs.rs/criterion",

"excerpts": [

"This crate is a microbenchmarking library which aims to provide strong
statistical confidence in detecting and estimating the size of
performance improvements ...See more"

]

},

{

"title": "hash_hasher - Rust - Docs.rs",

"url": "https://docs.rs/hash_hasher/latest/hash_hasher/",

"excerpts": [

"A std::hash::Hasher which is designed to work with already-hashed or
hash-like data. The provided hasher does minimal work under the
assumption that the input ..."

]

},

{

"title": "How to access unaligned data in rust without copies - Stack
Overflow",

"url":
"https://stackoverflow.com/questions/78490876/how-to-access-unaligned-data-in-rust-without-copies",

"excerpts": [

"I have a code base that loads a huge binary data file in memory and,
without additional allocations, map it to proper data types (u32, f64,
f32."

]

},

{

"title": "wyhash GitHub Repository",

"url": "https://github.com/wangyi-fudan/wyhash",

"excerpts": [

"Rust https://github.com/eldruin/wyhash-rs",

"wyhash is the default hashing algorithm of the great Zig , V , Nim and
Go (since 1.17) language. One milestone is that wyhash has deployed by
Microsoft on [Windows Terminal] ( microsoft/terminal#13686 ",

"wyhash has evolved into rapidhash ! With improved speed, quality and
compatibility.",

"No hash function is perfect, but some are useful. wyhash and wyrand are
the ideal 64-bit hash function and PRNG respectively:\nsolid : wyhash
passed SMHasher, wyrand passed BigCrush, practrand. portable :
64-bit/32-bit system, big/little endian. fastest : Efficient on 64-bit
machines, especially for short keys. simplest : In the sense of code
size. salted : We use dynamic secret to avoid intended attack.",

"Limitations:\nIt is known now that wyhash/wyrand have their
limitations:\nBoth of them are not 64 bit collision resistant, but is
about 62 bits (flyingmutant/Cyan4973/vigna)\nWhen test on longer dataset
(32TB, 23 days), wyrand will fail practrand (vigna)\nAnd there may be
more flaws detected in the future. User should make their own decision
based the advantage and the flaws of wyhash/wyrand as no one is
perfect.",

"C# https://github.com/cocowalla/wyhash-dotnet\nC++
https://github.com/tommyettinger/waterhash\nC++
https://github.com/alainesp/wy\nGO
https://github.com/dgryski/go-wyhash\nGO
https://github.com/orisano/wyhash\nGO
https://github.com/littleli/go-wyhash16\nGO
https://github.com/zeebo/wyhash\nGO
https://github.com/lonewolf3739/wyhash-go\nGO
https://github.com/zhangyunhao116/wyhash (final version 1 && 3)\nJava
https://github.com/OpenHFT/Zero-Allocation-Hashing\nJava
https://github.com/dynatrace-oss/hash4j (final version 3 and 4)\nKotlin
Multiplatform
https://github.com/appmattus/crypto/tree/main/cryptohash\nNim
https://github.com/nim-lang/Nim/blob/devel/lib/pure/hashes.nim\nNim
https://github.com/jackhftang/wyhash.nim\nNim
https://github.com/littleli/nim-wyhash16\nRust
https://github.com/eldruin/wyhash-rs\nSwift
https://github.com/lemire/SwiftWyhash\nSwift
https://github.com/lemire/SwiftWyhashBenchmark\nSwift
https://github.com/jeudesprits/PSWyhash\nV
https://github.com/vlang/v/tree/master/vlib/hash/wyhash (v4)\nZig
https://github.com/ManDeJan/zig-wyhash\nabsl hashmap
https://github.com/abseil/abseil-cpp/blob/master/absl/hash/internal/low_level_hash.h",

"The FASTEST QUALITY hash function, random number generators (PRNG) and
hash map. License. Unlicense license",

"License"

]

},

{

"title": "fxhash - Rust Package Registry",

"url": "https://crates.io/crates/fxhash",

"excerpts": [

"Fx Hash. This hashing algorithm was extracted from the Rustc compiler.
This is the same hashing algoirthm used for some internal operations ...
A fast, non-secure, hashing algorithm derived from an internal hasher
used in FireFox and Rustc.",

"It is **not a cryptographically secure** hash, so it is strongly
recommended that you do not use this hash for cryptographic purproses.",

"Furthermore, this hashing algorithm was not designed to prevent any
attacks for determining collisions which could be used to potentially
cause quadratic behavior in `HashMap`s. So it is not recommended to
expose this hash in places where collissions or DDOS attacks may be a
concern.",

"Generally `fxhash` is than `fnv` on `u32`, `u64`, or any byte sequence
with length >= 5. However, keep in mind that hashing speed is not the
only characteristic worth considering. That being said, Rustc had an
observable increase in speed when switching from `fnv` backed hashmaps
to `fx` based hashmaps.",

"[Apache-2.0](https://choosealicense.com/licenses/apache-2.0)\nOR\n[MIT](https://choosealicense.com/licenses/mit)",

"Install\n-------\n\n\n\nRun the following Cargo command\nin your
project directory:\n\ncargo add fxha",

"[docs.rs/fxhash/0.2.1](https://docs.rs/fxhash/0.2.1)",

"[github.com/cbreeden/fxhash](https://github.com/cbreeden/fxhash)"

]

},

{

"title": "twox-hash - crates.io: Rust Package Registry",

"url": "https://crates.io/crates/twox-hash",

"excerpts": [

"A Rust implementation of the XXHash and XXH3 algorithms",

"A Rust implementation of the
[xxHash](https://github.com/Cyan4973/xxHash) algorithm.",

"xxhash32 | Include the `XxHash32` algorithm",

"When the data is streaming\n\n```\nuse std::hash::Hasher as _;\nuse
twox_hash::XxHash64;\n\nlet seed = 1234;\nlet mut hasher =
XxHash64::with_seed(seed);\nhasher.write(b\"some\");\nhasher.write(b\"
\");\nhasher.write(b\"bytes\");\nlet hash = hasher.finish();\nassert_eq!
(0xeab5_5659_a496_d78b, hash);\n\n```",

"When all the data is available at once\n\n```\nuse
twox_hash::XxHash64;\n\nlet seed = 1234;\nlet hash =
XxHash64::oneshot(seed, b\"some bytes\");\nassert_eq!
(0xeab5_5659_a496_d78b, hash);\n\n```",

"Use the Rust standard library. Enable this if you want SIMD support in
`XxHash3_64`",

"See benchmarks in the
[comparison](https://github.com/shepmaster/twox-hash/tree/main/comparison)
README."

]

},

{

"title": "xxhash-rust - crates.io: Rust Package Registry",

"url": "https://crates.io/crates/xxhash-rust",

"excerpts": [

"Implementation of [xxHash](https://github.com/Cyan4973/xxHash) in
Rust",

"Each algorithm is implemented via feature, allowing precise control
over code size.",

"HW acceleration\n---------------\n\nSimilar to reference
implementation, crate implements various SIMDs in `xxh3` depending on
provided flags. All checks are performed only at compile time, hence
user is encouraged to enable these accelerations (for example via `-C
target_cpu=native`)",

"Implementation of xxHash",

"xxhash-rust - crates.io: Rust Package Registry",

"Features:\n---------\n\nBy default all features are off. * `std` -
Enables `std::io::Write` trait implementation\n* `xxh32` - Enables 32bit
algorithm. Suitable for x86 targets\n* `const_xxh32` - `const fn`
version of `xxh32` algorithm",

"Streaming vs One-shot\n---------------------\n\nFor performance reasons
one-shot version of algorithm does not re-use streaming version. Unless
needed, user is advised to use one-shot version which tends to be more
optimal.",

"`const fn` version\n------------------\n\nWhile `const fn` provides
compile time implementation, it does so at performance cost. Hence you
should only use it at *compile* time. To guarantee that something is
computed at compile time make sure to initialize hash output\nas `const`
or `static` variable, otherwise it is possible function is executed at
runtime, which\nwould be worse than regular algorithm. `const fn` is
implemented in best possible way while conforming to limitations of Rust
`const fn`, but these limitations are quite strict making any high
performance code impossible.",

"Version note\n------------\n\n* `0.8. *` corresponds to C's `0.8.
*`\n\nIn order to keep up with original implementation version I'm not
planning to bump major/minor until C implementation does so.",

"Repository\n----------\n\n[github.com/DoumanAsh/xxhash-rust](https://github.com/DoumanAsh/xxhash-rust)",

"Categories\n----------\n\n* [Algorithms](/categories/algorithms)\n* [No
dynamic allocation](/categories/no-std::no-alloc)"

]

},

{

"title": "Criterion.rs Documentation",

"url": "https://bheisler.github.io/criterion.rs/book/",

"excerpts": [

"Criterion.rs is a statistics-driven micro-benchmarking tool.",

"Criterion.rs benchmarks collect and store ...",

"Criterion.rs - Criterion.rs Documentation"

]

},

{

"title": "wyhash-devel",

"url":
"https://packages.fedoraproject.org/pkgs/wyhash/wyhash-devel/index.html",

"excerpts": [

"Upstream: https://github.com/wangyi-fudan/wyhash; License(s):
Unlicense; Maintainer: orphan. Related Packages. wyhash-doc. You can
contact the maintainers of ..."

]

},

{

"title": "Source Files",

"url": "https://stdlib.fortran-lang.org/lists/files.html",

"excerpts": [

"Jul 17, 2025 — wyhash is available at the URL:
https://github.com/wangyi-fudan ...
wangyi-fudan/wyhash/blob/master/LICENSE . Original Author: Wang Yi ..."

]

},

{

"title": "wyhash - crates.io: Rust Package Registry",

"url": "https://crates.io/crates/wyhash",

"excerpts": [

"Rust implementation of the wyhash algorithm by Wang Yi. The hashing
algorithm passes SMHasher and the random number generator passes
BigCrush and practrand."

]

},

{

"title": "wyhash fast portable non-cryptographic hashing algorithm ...",

"url": "https://github.com/eldruin/wyhash-rs",

"excerpts": [

"Rust implementation of the wyhash algorithm by Wang Yi. The hashing
algorithm passes SMHasher and the random number generator passes
BigCrush and practrand.",

"License. Licensed under either of. Apache License, Version 2.0
(LICENSE-APACHE or http://www.apache.org/licenses/LICENSE-2.0); MIT
license (LICENSE-MIT or http ..."

]

},

{

"title": "wyhash fast non-cryptographic string hash",

"url": "https://github.com/dgryski/go-wyhash",

"excerpts": [

"The MIT License (MIT) Copyright (c) 2019 Damian Gryski
<damian@gryski.com> Permission is hereby granted, free of charge, to any
person obtaining a copy of ...",

"wyhash fast non-cryptographic string hash. Contribute to
dgryski/go-wyhash development by creating an account on GitHub."

]

},

{

"title": "wyhash-doc",

"url":
"https://packages.fedoraproject.org/pkgs/wyhash/wyhash-doc/index.html",

"excerpts": [

"Upstream: https://github.com/wangyi-fudan/wyhash; License(s):
Unlicense; Maintainer: orphan. Related Packages. wyhash-devel. You can
contact the maintainers of ..."

]

},

{

"title": "wyhash package - github.com/orisano ...",

"url": "https://pkg.go.dev/github.com/orisano/wyhash",

"excerpts": [

"Package wyhash implements the wyhash hash algorithm as defined in
github.com/wangyi-fudan/wyhash"

]

},

{

"title": "wyhash/wyhash32.h at master - GitHub",

"url": "https://github.com/wangyi-fudan/wyhash/blob/master/wyhash32.h",

"excerpts": [

"The FASTEST QUALITY hash function, random number generators (PRNG) and
hash map. - wyhash/wyhash32.h at master · wangyi-fudan/wyhash."

]

},

{

"title": "mingw-w64-x86_64-xxhash - MSYS2 Packages",

"url": "https://packages.msys2.org/package/mingw-w64-x86_64-xxhash",

"excerpts": [

"https://github.com/Cyan4973/xxHash; License(s):: BSD-2-Clause OR
GPL-2.0-or-later; Version: 0.8.3-1; External: Anitya: xxhash; Arch
Linux: 0.8.3; Cygwin: 0.8.3 ..."

]

},

{

"title": "include/llvm/Support/xxhash.h Source File",

"url": "https://llvm.org/doxygen/xxhash_8h_source.html",

"excerpts": [

"xxHash - Extremely Fast Hash algorithm. 3 Header File 4 Copyright (C)
2012-2016, Yann Collet. 5 6 BSD 2-Clause License
(http://www.opensource.org/licenses/bsd- ..."

]

},

{

"title": "xxHash - Extremely fast non-cryptographic hash algorithm",

"url": "https://xxhash.com/",

"excerpts": [

"xxHash is an extremely fast non-cryptographic hash algorithm, working
at RAM speed limit. It is proposed in four flavors (XXH32, XXH64,
XXH3_64bits and XXH3_ ..."

]

},

{

"title": "Can I use xxHash in an MIT-licensed project?",

"url": "https://groups.google.com/g/lz4c/c/WqdigZQLA0g",

"excerpts": [

"Since each license requires to be reproduced, you'll have to include
both license texts somewhere. Or state that the license is \"per file\"
and must be checked ..."

]

},

{

"title": "xxhash",

"url": "https://pypi.org/project/xxhash/",

"excerpts": [

"License: BSD License (BSD); Author: Yue Du; Requires: Python >=3.7.
Classifiers ... xxhash is a Python binding for the xxHash library by
Yann Collet."

]

},

{

"title": "XXHash Copyright and License Statement - Maple Help",

"url":
"https://www.maplesoft.com/support/help/Maple/view.aspx?path=License%2FxxHash",

"excerpts": [

"THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED ..."

]

},

{

"title": "[go] runtime: using wyhash for memhashFallback on 32bit ...",

"url": "https://groups.google.com/g/golang-codereviews/c/bXL0t-2DIDg",

"excerpts": [

"The mix function cames from
https://github.com/wangyi-fudan/wyhash/blob/master/wyhash32.h […] I see,
the wyhash 32 and 64 bit implementations are already ..."

]

},

{

"title": "makefile - wangyi-fudan/wyhash",

"url": "https://github.com/wangyi-fudan/wyhash/blob/master/makefile",

"excerpts": [

"The FASTEST QUALITY hash function, random number generators (PRNG) and
hash map. - wyhash/makefile at master · wangyi-fudan/wyhash."

]

},

{

"title": "Wyhash repository and wyhash.h (Source Document)",

"url": "https://github.com/wangyi-fudan/wyhash/blob/master/wyhash.h",

"excerpts": [

"\n294 lines (270 loc) · 11.4 KB",

"wyhash.h\n========\n",

"\n// author: 王一 Wang Yi <godspeed\\_china@yeah.net>",

"// This is free and unencumbered software released into the public
domain under The Unlicense (http://unlicense.org/)",

"// main repo: https://github.com/wangyi-fudan/wyhash",

"/\\* The Unlicens",

"This is free and unencumbered software released into the public domain.
Anyone is free to copy, modify, publish, use, compile, sell, or",

"distribute this software, either in source code form or as a compiled",

"binary, for any purpose, commercial or non-commercial, and by any",

"means. In jurisdictions that recognize copyright laws, the author or
authors",

"of this software dedicate any and all copyright interest in the",

"software to the public domain. We make this dedication for the
benefit",

"of the public at large and to the detriment of our heirs and",

"successors. We intend this dedication to be an overt act of",

"relinquishment in perpetuity of all present and future rights to this",

"software under copyright law. THE SOFTWARE IS PROVIDED \"AS IS\",
WITHOUT WARRANTY OF ANY KIND,",

"EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF",

"MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR",

"OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,",

"ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR",

"OTHER DEALINGS IN THE SOFTWARE."

]

},

{

"title": "xxHash Repository and License",

"url": "https://github.com/Cyan4973/xxHash",

"excerpts": [

"xxHash is an Extremely fast Hash algorithm, processing at RAM speed
limits. Code is highly portable, and produces hashes identical across
all platforms (little / big endian). The library includes the following
algorithms :",

"xxHash is an Extremely fast Hash algorithm",

"* XXH3 (since\nv0.8.0 ): generates 64 or 128-bit hashes, using
vectorized arithmetic. The 128-bit variant is called XXH128. All
variants successfully complete the SMHasher test suite\nwhich evaluates
the quality of hash functions (collision, dispersion and randomness).",

"The library files xxhash.c and xxhash.h are BSD licensed.",

"* XXH32 : generates 32-bit hashes, using 32-bit arithmetic",

"* XXH64 : generates 64-bit hashes, using 64-bit arithmetic",

"License"

]

},

{

"title": "xxHash License Details",

"url":
"https://chromium.googlesource.com/external/github.com/Cyan4973/xxHash/+/98459bb56b3b5e3409fbd95a07f1fa29565a3c22/LICENSE",

"excerpts": [

"xxHash Library",

"Copyright (c) 2012-present, Yann Collet",

"All rights reserved.",

"BSD 2-Clause License
(https://www.opensource.org/licenses/bsd-license.php).",

"THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
\"AS IS\" AND",

"ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED",

"WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE",

"DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
LIABLE FOR",

"ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES"

]

},

{

"title": "xxHash License Text",

"url":
"https://chromium.googlesource.com/external/github.com/Cyan4973/xxHash/+/refs/tags/v0.7.2/xxhash.h",

"excerpts": [

"xxHash - Extremely Fast Hash algorithm. Header File. Copyright (C)
2012-2016, Yann Collet. BSD 2-Clause License
(http://www.opensource.org/licenses/bsd-license. xxhash.h -
external/github.com/Cyan4973/xxHash - Git at Google",

"BSD 2-Clause License
(http://www.opensource.org/licenses/bsd-license.php)",

"SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS |\n| |
\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT |\n|
| LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
|\n| | A PARTICULAR PURPOSE"

]

},

{

"title": "Cyan4973/xxHash - xxhsum.c (GPL v2) and related metadata",

"url": "https://github.com/Cyan4973/xxHash/blob/dev/cli/xxhsum.c",

"excerpts": [

"\\* xxhsum - Command line interface for xxhash algorithms",

"Copyright (C) 2013-2023 Yann Collet",

"GPL v2 License",

"This program is free software; you can redistribute it and/or modify",

"the GNU General Public License as published by\n\\* the Free Software
Foundation; either version 2 of the License,",

"(at your option) any later version.",

"You can contact the author at:",

"- xxHash homepage: https://www.xxhash.com",

"- xxHash source repository: https://github.com/Cyan4973/xxHash"

]

},

{

"title": "wyhash: test_vector.cpp",

"url":
"https://github.com/wangyi-fudan/wyhash/blob/master/test_vector.cpp",

"excerpts": [

"\n\n26 lines (25 loc) · 738 Bytes",

"#include <stdint.h>\n#include <iostream>\n#include <vector>\n#define
WYTRNG\n#include \"wyhash.h\"\nusing namespace std;\nint main(void)
{\nvector<string> msgs\\_v = {\n\"\",\n\"a\",\n\"abc\",\n\"message
digest\",\n\"abcdefghijklmnopqrstuvwxyz\",\n\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\",\n\"1234567890123456789012345678901234567890123456789012345678901234567890\"\n\"1234567890\"\n};\nuint64\\_t
hash;\ncout << \"# wyhash message, seed\" << \"\\n\";\nfor (size\\_t i =
0; i < msgs\\_v.size(); i++) {\nhash = wyhash(msgs\\_v[i].c\\_str(),
msgs\\_v[i].size(), i, \\_wyp);\ncout << hex << hash << \" \\\"\" <<
msgs\\_v[i] << \"\\\", \" << i << \"\\n\";\n}\nret",

"vector<string> msgs_v = {",

"\"\",",

"\"a\",",

"\"abc\",",

"\"message digest\",",

"\"abcdefghijklmnopqrstuvwxyz\",",

"\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\",",

"\"1234567890123456789012345678901234567890123456789012345678901234567890\"",

"\"1234567890\"",

"uint64_t hash;",

"hash =",

"wyhash(msgs_v[i].c_str(), msgs_v[i].size(), i, _wyp);",

"};"

]

},

{

"title": "refs/tags/v0.8.0 - external/github.com/Cyan4973/xxHash - ...",

"url":
"https://chromium.googlesource.com/external/github.com/Cyan4973/xxHash/+/refs/tags/v0.8.0",

"excerpts": [

"xxHash is an Extremely fast Hash algorithm, running at RAM speed
limits. It successfully completes the SMHasher test suite which
evaluates collision, dispersion ..."

]

},

{

"title": "twox-hash - crates.io: Rust Package Registry",

"url": "https://crates.io/crates/twox-hash/1.6.3",

"excerpts": [

"TwoX-Hash. A Rust implementation of the XXHash algorithm. Build Status
Current Version · Documentation. Examples. With a fixed seed."

]

},

{

"title": "ahash",

"url": "https://crates.io/crates/ahash/reverse_dependencies",

"excerpts": [

"A non-cryptographic hash function using AES-NI for high performance.
... no-std · Readme · 95 Versions · Dependencies · Dependents.
Displaying 1-10 of 1043 ..."

]

},

{

"title": "fx-hash - crates.io: Rust Package Registry",

"url": "https://crates.io/crates/fx-hash",

"excerpts": [

"Spending more CPU cycles on a higher quality hash does not reduce hash
collisions enough to make the compiler faster on real-world benchmarks."

]

},

{

"title": "Simple source code to integrate · Issue #550",

"url": "https://github.com/Cyan4973/xxHash/issues/550",

"excerpts": [

"If someone is only interested in XXH32() or XXH64() , they could
integrate, or even copy/paste, just this code. A good example of this
strategy ..."

]

},

{

"title": "rapidhash/README.md at master",

"url": "https://github.com/hoxxep/rapidhash/blob/master/README.md",

"excerpts": [

"A rust implementation of the rapidhash function, the official successor
to wyhash. High quality, the fastest hash passing all tests in the
SMHasher and ..."

]

},

{

"title": "Benchmarking non-cryptographic hash functions in Rust -
Medium",

"url":
"https://medium.com/@tprodanov/benchmarking-non-cryptographic-hash-functions-in-rust-2e6091077d11",

"excerpts": [

"There are two types of hash algorithms: cryptographic and
non-cryptographic. Cryptographic hash functions are used for secure
purposes, such as ..."

]

},

{

"title": "Hashing - The Rust Performance Book",

"url": "https://nnethercote.github.io/perf-book/hashing.html",

"excerpts": [

"Its hashing algorithm is low-quality but very fast, especially for
integer keys, and has been found to out-perform all other hash
algorithms within rustc."

]

},

{

"title": "Is it possible to write Quake's fast InvSqrt() function in
Rust?",

"url":
"https://stackoverflow.com/questions/59081890/is-it-possible-to-write-quakes-fast-invsqrt-function-in-rust",

"excerpts": [

"This function compiles to the following assembly on
x86-64:\n\n```\n.LCPI0_0:\n .long 3204448256 ; f32 -0.5\n.LCPI0_1:\n
.long 1069547520 ; f32 1.5\nexample::inv_sqrt:\n movd eax, xmm0\n shr
eax ; i << 1\n mov ecx, 1597463007 ; 0x5f3759df\n sub ecx, eax ;
0x5f3759df - ...\n movd xmm1, ecx\n mulss xmm0, dword ptr [rip +
.LCPI0_0] ; x *= 0.5\n mulss xmm0, xmm1 ; x *= y\n mulss xmm0, xmm1 ; x
*= y\n addss xmm0, dword ptr [rip + .LCPI0_1] ; x += 1.5\n mulss xmm0,
xmm1 ; x *= y\n ret\n\n``",

"Surprisingly Rust's own sqrt().recip() is the fastest. But of course,
any micro benchmark result should be taken with a grain of salt. inv
sqrt ...",

"fn inv_sqrt(x: f32) -> f32 {\n let i = x.to_bits();\n let i =
0x5f3759df - (i >> 1);\n let y = f32::from_bits(i);\n\n y * (1.5 - 0.5 *
x * y * y)\n}",

"the original C code is UB (due to TBAA) but the Rust code is not :)",

"With that, here is the implementation of\nInvSqrt :",

"0x5f3759df",

"0x5f375a86",

"modern x86 CPUs have a specialized instruction for this function which
is faster and more accurate than this hack.",

"movd eax, xmm0",

"shr eax ; i << 1 mov ecx, 1597463007 ; 0x5f3759df sub ecx, eax ;
0x5f3759df - ..."

]

},

{

"title": "A rust implementation of Q_rsqrt - GitHub",

"url": "https://github.com/ThatNerdUKnow/Q_rsqrt",

"excerpts": [

"This is a implementation of the fast inverse square root function from
quake 3. It can be up to three times as fast as using the .sqrt() method
on a float32"

]

},

{

"title": "fast_inv_sqrt - crates.io: Rust Package Registry",

"url": "https://crates.io/crates/fast_inv_sqrt/dependencies",

"excerpts": [

"fast_inv_sqrt v1.0.1 ... Fast inverse square root algorithm
implementation. #root · #square · #sqrt · Readme · 2 Versions ·
Dependencies ..."

]

},

{

"title": "TIL about the Fast Inverse Square Root, an ingenious set of
...",

"url":
"https://www.reddit.com/r/todayilearned/comments/ln0bng/til_about_the_fast_inverse_square_root_an/",

"excerpts": [

"An ingenious set of code that quickly calculated accurate square roots
in Quake 3 using floating points and Newton's method."

]

},

{

"title": "I implemented the famous Quake inverse sqrt function in Rust!
- Reddit",

"url":
"https://www.reddit.com/r/rust/comments/vdroh6/i_implemented_the_famous_quake_inverse_sqrt/",

"excerpts": [

"I implemented the infamous, bit-hacking, most-memory-unsafe Quake
inverse square root function, with a few variations for speed and
accuracy! I have eliminated 2 of the variable allocations, saving a few
instructions, as well as reducing the revisions to only one in the
process. It is also using the derived, more-accurate \"0x5F375A86\"
constant instead of the original \"0x5F3759DF\". Because of this, even
with only one iterative revision, the resulting answer is within about
0.1% of the correct answer! If anyone would like a better explanation
for the how the algorithm works, here is a link to a video from Nemean
on YouTube. He gives a great explanation of the whole thing.
<https://www.youtube.com/watch?v=p8u_k2LIZyo>",

" let mut i: i32 = number.to_bits() as i32;",

" i = 0x5F375A86_i32.wrapping_sub(i >> 1);",

" let y = f32::from_bits(i as u32);",

" y * (1.5 - (number * 0.5 * y * y))",

"fn quake_rsqrt(number: f32) -> f32 {",

"fn quake_rsqrt(number: f32) -> f32 {",

" let mut y: f32 = number;",

" unsafe {",

" let mut i: i32 = std::mem::transmute::<f32, i32>(y);",

" i = 0x5F375A86 - (i >> 1);",

" y = std::mem::transmute::<i32, f32>(i);",

" } ",

" y * (1.5 - (number * 0.5 * y * y)) ",

"I implemented the famous Quake inverse sqrt function in Rust!",

"ing the derived, more-accurate \"0x5F375A86\" constant instead of the
original \"0x5F3759DF\".",

"ost unsafe memory hacks with the most type-safe, memory-safe language I
could think of!",

"}",

"}"

]

},

{

"title": "Regarding safe float <=> int transmutes - Rust Users Forum",

"url":
"https://users.rust-lang.org/t/regarding-safe-float-int-transmutes/10444",

"excerpts": [

"Nice functions to safely transmute float <=> int have being added
recently: https://github.com/rust-lang/rust/pull/39271 You can use them
like this:"

]

},

{

"title": "q_rsqrt - Rust - Docs.rs",

"url": "https://docs.rs/q_rsqrt",

"excerpts": [

"API documentation for the Rust `q_rsqrt` crate ... square root function
from quake 3."

]

},

{

"title": "FAST INVERSE SQUARE ROOT - Chris Lomont",

"url": "https://matrix67.com/data/InvSqrt.pdf",

"excerpts": [

"FAST INVERSE SQUARE ROOT. CHRIS LOMONT.",

"by C LOMONT · Cited by 162 — A quick test shows the relative error to
be around 0.0342128 for the initial approximation, and 0.0017758 after 1
Newton iteration. A final question is to ..."

]

},

{

"title": "Quake inverse square root: analysis and implementation",

"url": "https://0x5f37642f.com/documents/McEniryMathematicsBehind.pdf",

"excerpts": [

"float InvSqrt (float x){",

"x){\n    float xhalf = 0.5f*x;     int i = *(int*)&x;\n    i =
0x5f3759df - (i>>1);     x = *(float*)&i;\n    x = x*(1.5f - xhalf*x*x);
    return x;",

"int i = *(int*)&x;",

"\n    i = 0x5f3759df - (i>>1);     x = *(float*)&i;\n   ",

"x = *(float*)&i;",

")&i;\n    x = x*(1.5f - xhalf*x*x);     return x;",

"return x;",

"}\n\nFor those who have not wandered upon this topic before, the
function code implements a fast\nevaluation of the inverse or reciprocal
of the square root of the input value for floating-point\nnumbers based
upon the IEEE standard for 32-bit binary floating-point numbers, in
short, by\nusing the Newton-Raphson method with an initial guess
determined from the input value.",

". For\ngraphics programming, especially twenty years ago, this code
provided a significant advantage in\nperformance over using the nominal
method of calling the square root function and
performing\nfloating-point division, but at a loss of precision.",

"by C McEniry · 2007 · Cited by 16 — Ideally, the constant used in the
function is such that the maximum relative error for all possible input
values is reduced to a minimum and within application ...",

"Today, most graphical processing units and many of the additional 
instruction sets for processors
implement similar, but more complex, methods in the hardware",

"}"

]

},

{

"title": "Understanding Quake's Fast Inverse Square Root",

"url":
"https://betterexplained.com/articles/understanding-quakes-fast-inverse-square-root/",

"excerpts": [

"This incredible hack estimates the inverse root using Newton's method
of approximation, and starts with a great initial guess.",

"An article and research paper describe a fast, seemingly magical way to
compute the inverse square root ( 1 / x ), used in the game Quake."

]

},

{

"title": "InvSqrt.pdf",

"url":
"https://www.kechuang.org/reader/pdf/web/viewer?file=%2Fr%2F117037?time%3D1746247290082",

"excerpts": [

"FAST INVERSE SQUARE ROOTCHRIS LOMONTAbstract.Computing reciprocal
square roots is necessary in manyapplications, such as vector
normalization in video games ..."

]

},

{

"title": "quake-inverse-sqrt - crates.io: Rust Package Registry",

"url": "https://crates.io/crates/quake-inverse-sqrt",

"excerpts": [

"A simple rust implementation of the Quake III reverse square root
alghorithm. Safety. The main trait implementations are not marked as
..."

]

},

{

"title": "Benchmarking With Inputs - Criterion.rs Documentation",

"url":
"https://bheisler.github.io/criterion.rs/book/user_guide/benchmarking_with_inputs.html",

"excerpts": [

"Criterion.rs can run benchmarks with one or more different input values
to investigate how the performance behavior changes with different
inputs."

]

},

{

"title": "\"f::from_bits\" Search",

"url":
"https://doc.rust-lang.org/std/index.html?search=f%3A%3Afrom_bits",

"excerpts": [

"f16::from_bits. Raw transmutation from u16 . method. f32::from_bits.
Raw transmutation from u32 . method. f64::from_bits. Raw transmutation
from u64 . trait ..."

]

},

{

"title": "Fast inverse square root",

"url": "https://en.wikipedia.org/wiki/Fast_inverse_square_root",

"excerpts": [

". Fast inverse square root , sometimes referred to as\nFast InvSqrt()
or by the hexadecimal constant\n0x5F3759DF , is an algorithm that
estimates 1\nx\n{\\textstyle {\\frac {1}{\\sqrt {x}}}} , the reciprocal
(or multiplicative inverse) of the square root of a 32- bit
floating-point number x\n{\\displaystyle x} in IEEE 754 floating-point
format .",

"The algorithm is best known for its implementation in 1999 in Quake III
Arena , a first-person shooter video game heavily based on 3D graphics
.",

"With subsequent hardware advancements, especially the x86 SSE
instruction\nrsqrtss , this algorithm is not generally the best choice
for modern computers, [ 1 ] though it remains an interesting historical
example. [ 2 ]",

"The following C code is the fast inverse square root implementation
from Quake III Arena , stripped of C preprocessor directives, but
including the exact original comment text: [ 15 ]",

"The key of the fast inverse square root was to directly compute an
approximation by utilizing the structure of floating-point numbers,
proving faster than table lookups.",

"One iteration of Newton's method is performed to gain some accuracy,
and the code is finished.",

"The advantages in speed offered by the fast inverse square root trick
came from treating the 32-bit floating-point word [ note 1 ] as an
integer , then subtracting it from a \" magic \" constant, 0x 5F3759DF
.",

"This integer subtraction and bit shift results in a bit pattern which,
when re-defined as a floating-point number, is a rough approximation for
the inverse square root of the number.",

"hod\nRelative error between direct calculation and fast inverse square
root carrying out 0, 1, 2, 3, and 4 iterations of Newton's root-finding
method."

]

},

{

"title": "Rust Inverse Square Root Discussion",

"url":
"https://internals.rust-lang.org/t/do-the-square-root-intrinsics-work-on-all-platforms/19665",

"excerpts": [

"micromath crate provides an implementation which trades ~5% precision
for additional performance: F32 in micromath - Rust"

]

},

{

"title": "q_rsqrt Crate Page and Description",

"url": "https://crates.io/crates/q_rsqrt",

"excerpts": [

"Jun 26, 2022 — This is a implementation of the fast inverse square root
function from quake 3. It can be up to three times as fast as using the
.sqrt() ... ",

"q\\_rsqrt - crates.io: Rust Package Registr",

"This is a implementation of the fast inverse square root function from
quake 3. It can be up to three times as fast as using the `.sqrt()`
method on a float32",

"Keep in mind that fast inverse square root is only accurate within a
one percent margin of error",

"It can be up to three times as fast as using the\n.sqrt() method on a
float32",

"ation:\n\n```\nfloat Q_rsqrt( float number )\n{\n\tlong i;\n\tfloat x2,
y;\n\tconst float threehalfs = 1.5F;\n\n\tx2 = number * 0.5F;\n\ty =
number;\n\ti = * ( long * ) &y; // evil floating point bit level
hacking\n\ti = 0x5f3759df - ( i >> 1 ); // what the fuck?\ny = * ( float
* ) &i;\n\ty = y * ( threehalfs - ( x2 * y * y ) ); // 1st
iteration\n//\ty = y",

"q_rsqrt v0.1.1"

]

},

{

"title": "fast_inv_sqrt crate on crates.io",

"url": "https://crates.io/crates/fast_inv_sqrt",

"excerpts": [

"fast_inv_sqrt v1.0.1",

"Fast inverse square root algorithm implementation. * # root",

"fast_inv_sqrt =\n\"1.0.1\"",

"InvSqrt32 trait provide inv_sqrt32() function for primitive numeric
types. InvSqrt64 provides inv_sqrt64().",

"Code:\nextern crate fast_inv_sqrt; use fast_inv_sqrt::InvSqrt32; use
fast_inv_sqrt::InvSqrt64; fn main () { let f : f32 = 1.234 ; println! (
\"{}\" , f. inv_sqrt32 ());",

"Benchmarks\nBenchmarks require nightly compiler.",

"Documentation\ndocs.rs/fast_inv_sqrt/1.0.1",

"Repository\ngithub.com/emkw/rust-fast_inv_sqrt",

"3.04 KiB"

]

},

{

"title": "emkw/rust-fast_inv_sqrt: Rust fast inverse square root ... -
GitHub",

"url": "https://github.com/emkw/rust-fast_inv_sqrt",

"excerpts": [

"This was made purely for fun and testing crates.io publishing, but may
actually be usable. InvSqrt32 trait provide inv_sqrt32() function for
primitive numeric ..."

]

},

{

"title": "sqrt - Keywords - crates.io: Rust Package Registry",

"url": "https://crates.io/keywords/sqrt",

"excerpts": [

"Fast inverse square root algorithm implementation. All-Time: 8,091.
Recent: 753. Updated: about 9 years ago. Repository · quake-inverse-sqrt
v0.1.3. A rust ..."

]

},

{

"title": "Fast sqrt for f64? - help - The Rust Programming Language
Forum",

"url": "https://users.rust-lang.org/t/fast-sqrt-for-f64/58391",

"excerpts": [

"You could use the fast inverse square root algorithm from Quake III
Arena, implemented in the crate fast_inv_sqrt."

]

},

{

"title": "Is it still worth using the Quake fast inverse square root
...",

"url":
"https://stackoverflow.com/questions/71608126/is-it-still-worth-using-the-quake-fast-inverse-square-root-algorithm-nowadays-on",

"excerpts": [

"It's apparently better and more efficient or precise than the original
Quake III algorithm (slightly different magic constant), but it's been
more than 2 ..."

]

},

{

"title": "f32 - Rust",

"url":
"https://stdrs.dev/nightly/x86_64-unknown-linux-gnu/std/primitive.f32.html",

"excerpts": [

"Create a floating point value from its representation as a byte array
in little endian. See from_bits for some discussion of the portability
of this operation ( ..."

]

},

{

"title": "The nomicon is lying about transmutes? : r/rust",

"url":
"https://www.reddit.com/r/rust/comments/14iskmn/the_nomicon_is_lying_about_transmutes/",

"excerpts": [

"The language semantics are what matters here, and they clearly state
that transmuting &T to &mut T is insta-UB. More precisely,
immutable ..."

]

},

{

"title": "How to derive the magic number 0x5f375a86 : r/math",

"url":
"https://www.reddit.com/r/math/comments/cuq2pa/how_to_derive_the_magic_number_0x5f375a86/",

"excerpts": [

"This constant is used in the inverse square root floating point hack.
Does anyone know how it is derived (preferably an analytic rather than
numerical approach ..."

]

},

{

"title": "Search Results for 'fast inverse square root'",

"url":
"https://crates.io/search?per_page=2&q=fast%20inverse%20square%20root&sort=relevance",

"excerpts": [

"Newly Added · q_rsqrt v0.1.1. An implementation of the fast inverse
square root function from quake 3. All-Time: 2,244. Recent: 361.
Updated: about 3 years ago."

]

},

{

"title": "[ANN] micromath 2.0.0: approximation-based embedded ...",

"url":
"https://www.reddit.com/r/rust/comments/nekdbc/ann_micromath_200_approximationbased_embedded/",

"excerpts": [

"Announcing the v2.0.0 release of micromath : an embedded-oriented math
library which trades accuracy for higher performance and lower code
size."

]

},

{

"title": "arXiv: Fast inverse square root (Mathematically Rigorous
Description)",

"url": "https://arxiv.org/pdf/1603.04483",

"excerpts": [

"We present first mathematically rigorous description of the fast
algorithm for computing inverse square root for single-precision IEEE
Standard",

"float\nInvSqrt(float x){"

]

},

{

"title": "Improving the fast inverse square root - Řrřlog -
Webzdarma.cz",

"url": "http://rrrola.wz.cz/inv_sqrt.html",

"excerpts": [

"Charles McEniry has a really nice analysis and the optimal constant for
doubles. 3-D optimization. Can we do any better without making it
slower? Let's forget ..."

]

},

{

"title": "Should Julia have rsqrt? And e.g. support RSQRTSS",

"url":
"https://discourse.julialang.org/t/should-julia-have-rsqrt-and-e-g-support-rsqrtss/125969",

"excerpts": [

"Or top of that, the RSQRTSS only gives “about 11 significant bits of
precision”, and it depends on Intel or AMD."

]

},

{

"title": "Math function micro-optimization...",

"url":
"http://omcfadde.blogspot.com/2011/02/math-function-micro-optimization.html",

"excerpts": [

"For x86 (SSE), fast inverse square-root approximation can be calculated
using RSQRTSS instruction. For ARM (NEON), this is achieved using ..."

]

},

{

"title": "John Carmack's Unusual Fast Inverse Square Root (Quake ...",

"url":
"https://stackoverflow.com/questions/1349542/john-carmacks-unusual-fast-inverse-square-root-quake-iii",

"excerpts": [

"John Carmack has a special function in the Quake III source code which
calculates the inverse square root of a float, 4x faster than regular
(float)(1.0/sqrt(x ..."

]

},

{

"title": "Fast Inverse Square Root - CoffeeScript Cookbook",

"url":
"https://coffeescript-cookbook.github.io/chapters/math/fast-inv-square",

"excerpts": [

"This strange algorithm uses integer operations along with a 'magic
number' to calculate floating point approximation values of inverse
square roots."

]

},

{

"title": "\"f::to_bits\" Search",

"url": "https://doc.rust-lang.org/std/index.html?search=f%3A%3Ato_bits",

"excerpts": [

"Raw transmutation to u16 . method. f32::to_bits. Raw transmutation to
u32 ... The Rust Book for introductions to language features and the
language itself."

]

},

{

"title": "How can I cast between f32 and u32 without changing the ...",

"url":
"https://stackoverflow.com/questions/78730833/how-can-i-cast-between-f32-and-u32-without-changing-the-bits",

"excerpts": [

"To get the underlying bits of an f32 value as a u32, use f32::to_bits.
To do the reverse, use f32::from_bits(_)."

]

},

{

"title": "transmute in std::mem",

"url": "https://doc.rust-lang.org/std/mem/fn.transmute.html",

"excerpts": [

"Reinterprets the bits of a value of one type as another type. Both
types must have the same size. Compilation will fail if this is not
guaranteed. transmute ..."

]

},

{

"title": "Finding the square root in embedded with #![no_std]",

"url":
"https://users.rust-lang.org/t/finding-the-square-root-in-embedded-with-no-std/45268",

"excerpts": [

"I am making a project in which I am using the stm32f3discovery board
and need to know the square root of aa decimal number."

]

},

{

"title": "Fast Inverse Square Root",

"url": "https://news.ycombinator.com/item?id=24959157",

"excerpts": [

"All the major platforms, CPUs and GPUs, implement the fast reciprocal
square root to decent amounts of accuracy, without any need of
bit-twiddling anymore."

]

},

{

"title": "Approximating the square root by polynomials and rational
...",

"url": "https://www.chebfun.org/examples/approx/MinimaxSqrt.html",

"excerpts": [

"We compute the best polynomial and rational approximants using minimax
. a = 0.8; x = chebfun('x',[a 1]); f = sqrt(x); ns = 2:2:8; perrs = [];
rerrs ..."

]

},

{

"title": "An Approximation for the Inverse Square Root Function",

"url": "https://www.geometrictools.com/Documentation/ApproxInvSqrt.pdf",

"excerpts": [

"This document is about minimax approximation for computing the inverse
square root of a floating-point number. The algorithm uses Newton's ..."

]

},

{

"title": "Newton's method to find square root, inverse",

"url":
"https://dsplog.com/2011/12/25/newtons-method-square-root-inverse/",

"excerpts": [

"In this post, we will describe Newton's method and apply it to find the
square root and the inverse of a number."

]

},

{

"title": "Modified Fast Inverse Square Root and ...",

"url": "https://www.mdpi.com/2079-3197/9/2/21",

"excerpts": [

"by LV Moroz · 2021 · Cited by 18 — This article proposes a simple
modification of the fast inverse square root method that has high
accuracy and relatively low latency."

]

},

{

"title": "Error and error bound for the inverse square root",

"url":
"https://www.researchgate.net/figure/Error-and-error-bound-for-the-inverse-square-root_fig1_221025579",

"excerpts": [

"In this paper we consider the case that A is Hermitian and that f is a
rational function. We assume that the Lanczos method is used to compute
approximations ..."

]

},

{

"title": "Improving the Accuracy of the Fast Inverse Square Root by
...",

"url": "https://pmc.ncbi.nlm.nih.gov/articles/PMC7827340/",

"excerpts": [

"by CJ Walczyk · 2021 · Cited by 25 — In this paper, we consider
approximation and fast computation of the inverse square root function,
which has numerous applications (see [8,10,14,15,16,17]) ..."

]

},

{

"title": "subtle crate on Docs.rs",

"url": "https://docs.rs/subtle",

"excerpts": [

"**Pure-Rust traits and utilities for constant-time cryptographic
implementations.\n*",

"\nThis crate represents a “best-effort” attempt, since
side-channels\nare ultimately a property of a deployed cryptographic
system\nincluding the hardware it runs on, not just of software.",

"The traits are implemented using bitwise operations, and should execute
in\nconstant time provided that a) the bitwise operations are
constant-time and\nb) the bitwise operations are not recognized as a
conditional assignment and\noptimized back into a branch.",

"This library aims to be the Rust equivalent of Go’s `crypto/subtle`
module.",

"the crate tries to hide the value of a `Choice`’s\ninner `u8` by
passing it through a volatile read.",

"Note: the `subtle` crate contains `debug_assert`s to check invariants
during\ndebug builds.",

"Rust versions from 1.51 or higher have const generics support."

]

},

{

"title": "ArgMinMax (argminmax) Documentation",

"url": "https://docs.rs/argminmax/",

"excerpts": [

"The SIMD implementation is enabled for the following
architectures:\n\n* `x86` / `x86_64`:
[`SSE`](https://en.wikipedia.org/wiki/Streaming_SIMD_Extensions),
[`AVX2`](https://en.wikipedia.org/wiki/Advanced_Vector_Extensions),
[`AVX512`](https://en.wikipedia.org/wiki/Advanced_Vector_Extensions)\n*
`arm` / `aarch64`:
[`NEON`](https://en.wikipedia.org/wiki/ARM_architecture(Neon))",

"This crate provides two traits: [`ArgMinMax`](trait.ArgMinMax.html) and
[`NaNArgMinMax`](trait.NaNArgMinMax.html). These traits are implemented
for [`slice`](https://doc.rust-lang.org/std/primitive.slice.html) and
[`Vec`](https://doc.rust-lang.org/std/vec/struct.Vec.html).",

"* For [`ArgMinMax`](trait.ArgMinMax.html) the supported data types
are\n + ints: `i8`, `i16`, `i32`, `i64`\n + uints: `u8`, `u16`, `u32`,
`u64`\n + floats: `f16`, `f32`, `f64` (see [Features]())",

"Both traits differ in how they handle NaNs:\n\n*
[`ArgMinMax`](trait.ArgMinMax.html) ignores NaNs and returns the index
of the minimum and maximum values in an array. *
[`NaNArgMinMax`](trait.NaNArgMinMax.html) returns the index of the first
NaN in an array if there is one, otherwise it returns the index of the
minimum and maximum values in an array.",

"Summary[Source](../src/argminmax/lib.rs.html)\n\nExpand
description\n\nA crate for finding the index of the minimum and maximum
values in an array. These operations are optimized for speed using
[SIMD](https://en.wikipedia.org/wiki/Single_instruction,_multiple_data)
instructions (when available). The SIMD implementation is branchless,
ensuring that there is no best case / worst case. Furthermore, runtime
CPU feature detection is used to choose the fastest implementation for
the current CPU (with a scalar fallback).",

"Modules[§]()\n--------------------\n\n[dtype\\_strategy](dtype_strategy/index.html
\"mod argminmax::dtype_strategy\")\n: The strategy that is used to
handle the data type. [scalar](scalar/index.html \"mod
argminmax::scalar\")\n: Scalar implementation of the argminmax
functions. [simd](simd/index.html \"mod argminmax::simd\")\n: SIMD
implementations of the argminmax functions.",

"Two examples are provided below. ### [§]()Example with
integers\n\n```\nuse argminmax::ArgMinMax;\n\nlet a: Vec<i32> = vec! [0,
1, 2, 3, 4, 5];\nlet (imin, imax) = a.argminmax();\nassert_eq! (imin,
0);\nassert_eq!\n(imax, 5);\n```\n"

]

},

{

"title": "crypto/internal.h - boringssl - Git at Google",

"url":
"https://boringssl.googlesource.com/boringssl/+/e18d821dfcc32532caeeb1a2d15090672f592ce3/crypto/internal.h",

"excerpts": [

"/* constant_time_select returns (mask & a) | (~mask & b). When |mask|
is all 1s. * or all 0s (as returned by the methods above), the select
methods return."

]

},

{

"title": "Why isn't minmax branchless? - Internals & Design - Julia
Discourse",

"url":
"https://discourse.julialang.org/t/why-isnt-minmax-branchless/64854",

"excerpts": [

"minmax with or without branch are almost the same. Compiler can replace
the branch with a select (then lower to a conditional move)."

]

},

{

"title": "Branchless programming — Why your CPU will thank you",

"url":
"https://sdremthix.medium.com/branchless-programming-why-your-cpu-will-thank-you-5f405d97b0c8",

"excerpts": [

"Branchless programming can help ensure constant-time execution by
eliminating branches, which may introduce variable execution times.
The ..."

]

},

{

"title": "Branchless Equivalents of Simple Functions",

"url":
"https://hbfs.wordpress.com/2008/08/05/branchless-equivalents-of-simple-functions/",

"excerpts": [

"Aug 5, 2008 — One can use a branchless equivalent, that is, a code
transformed to remove the if-then-elses and therefore jump prediction
uncertainties.",

"Two's-complement arithmetic is based on modular arithmetic. On n bits,
-1 is not 0x800…0, buf 0xff…ff. so, any number + 0xff…fff (modulo 2^n)
is ..."

]

},

{

"title": "Branchless MIN/MAX functions - TalkChess.com",

"url": "https://talkchess.com/viewtopic.php?t=17822",

"excerpts": [

"Integer Selection A branchless, lookup-free, alternative to code like
if (a<b) x=c; else x=d; is ((((a-b) >> (WORDBITS-1)) & (c^d)) ^ d).",

"Branchless MIN/MAX functions",

"Does anyone have any idea if it is possible to do a MIN or MAX function
without a branch? Thanks!",

"int max(int a, int b) {return a - ifLessZero(a-b);}",

"int min(int a, int b) {return a + ifLessZero(b-a);} But likely with the
traditional macro",

"```\n#define max(a,b) (((a) > (b)) ? (a) : (b))\n\n```",

"Hacker's Delight book (http://www. Branchless MIN/MAX functions -
TalkChess.com",

"int ifLessZero(int a) {return a & minusMask(a);}",

"This code assumes that the shift is signed, which, of course, C does
not promise"

]

},

{

"title": "argminmax crate on crates.io",

"url": "https://crates.io/crates/argminmax",

"excerpts": [

"Efficient argmin & argmax (in 1 function) with SIMD (SSE, AVX(2),
AVX512 1 , NEON 1 )",

"Runtime CPU feature detection** is used to select the most efficient
implementation for the current CPU. This means that the same binary can
be used on different CPUs without recompilatio",

"The SIMD implementation contains **no if checks**, ensuring that the
runtime of the function is independent of the input data its order
(best-case = worst-case = average-ca",

"ArgMinMax (argmin & argmax in 1 function) with SIMD for floats and
integers"

]

},

{

"title": "min-max Crate - Crates.io",

"url": "https://crates.io/crates/min-max",

"excerpts": [

"min-max = \"0.1.8\"",

"Well, `max! (x1, x2, x3)` expands to:\n\n```\nstd::cmp::max(x1,
std::cmp::max(x2, std::cmp::max(x3)))\n\n```\n\nand so on. `min!` works
similarly, but with `std::cmp::min`. `min_partial!` and `max_partial`
uses the `min` and `max` functions from the [`partial-min-max`
crate](https://crates.io/crates/partial-min-max).
Metadata\n--------\n\npkg:cargo/min-max@0.1.8\n\nalmost 5 years
ago\n\n2018 edit",

"min-max - crates.io: Rust Package Registry",

"max! and min! macros",

"What's going on under the hood? -------------------------------"

]

},

{

"title": "Reinforcement learned branchless sorting functions for sort3,
sort4 ...",

"url":
"https://www.reddit.com/r/rust/comments/10tvyi9/reinforcement_learned_branchless_sorting/",

"excerpts": [

"For integer types core:cmp::min and max are compiled to machine code
using conditional moves, if available for the platform. E.g. for x86-64
...",

"Assume for a moment that you have branchless min and max functions,
which you can find online. I'm on mobile so it's hard to write code, but
here goes:",

"function branchless_sort2(&a, &b)",

" let x = min(a, b);",

" let y = max(a, b);",

" a := x;",

" b := y;",

"```",

"```"

]

},

{

"title": "Ziggurat RNG Background and Rust Integration",

"url": "https://github.com/jameslao/zignor-python",

"excerpts": [

"```",

"}",

"}"

]

},

{

"title": "Compute the minimum or maximum of two integers without ...",

"url":
"https://www.geeksforgeeks.org/compute-the-minimum-or-maximum-max-of-two-integers-without-branching/",

"excerpts": [

"Below are the methods to get minimum(or maximum) without using
branching. Typically, the obvious approach is best, though."

]

},

{

"title": "Avoiding Branches - Chessprogramming wiki",

"url": "https://www.chessprogramming.org/Avoiding_Branches",

"excerpts": [

"While processors become smarter to predict branches with several
heuristics, branches on random data should be avoided."

]

},

{

"title": "Two's complement - Wikipedia",

"url": "https://en.wikipedia.org/wiki/Two%27s_complement",

"excerpts": [

"Two's complement is the most common method of representing signed
(positive, negative, and zero) integers on computers"

]

},

{

"title": "Branchless code that maps zero, negative, and positive to
...",

"url":
"https://stackoverflow.com/questions/1610836/branchless-code-that-maps-zero-negative-and-positive-to-0-1-2",

"excerpts": [

"Write a branchless function that returns 0, 1, or 2 if the difference
between two signed integers is zero, negative, or positive."

]

},

{

"title": "Bit Twiddling Hacks (2005)",

"url": "https://news.ycombinator.com/item?id=12026879",

"excerpts": [

"Jul 3, 2016 — A branchless algorithm that's 50% slower can pay for
itself if you can process four elements at a time. Agreed that
performance testing is ...",

"One place the branchless techniques can come in handy is with SIMD (or
simulated SIMD by packing several small ints into longer ones.) A ..."

]

},

{

"title": "Binary search performance regressed in 1.25 · Issue #53823",

"url": "https://github.com/rust-lang/rust/issues/53823",

"excerpts": [

"The x86 backend should now respect __builtin_unpredicate for cmov
conversion, so if we can expose that in rustc in some way, we can use
that."

]

},

{

"title": "Constant-time comparison correctness : r/rust",

"url":
"https://www.reddit.com/r/rust/comments/wnkwd5/constanttime_comparison_correctness/",

"excerpts": [

"I recently learned about constant-time comparison algorithms and
attempted to implement one in Rust, using volatile methods to ensure
that N reads / writes are ..."

]

},

{

"title": "min in core::cmp - Rust",

"url": "https://doc.rust-lang.org/core/cmp/fn.min.html",

"excerpts": [

"Missing: implementation branchless"

]

},

{

"title": "aligned-cmov - crates.io: Rust Package Registry",

"url": "https://crates.io/crates/aligned-cmov",

"excerpts": [

"Mar 24, 2023 — Constant-time code and side-channel resistance: Intel's
Guidelines for mitigating timing side-channels against cryptographic
implementations ..."

]

},

{

"title": "Is there a branchless method to quickly find the min/max of
two double-precision values? - Stack Overflow",

"url":
"https://stackoverflow.com/questions/55109204/is-there-a-branchless-method-to-quickly-find-the-min-max-of-two-double-precision",

"excerpts": [

"Yes, there is a way to calculate the maximum or minimum of two
`double`s without any branches. The C++ code to do so looks like
this:\n\n```\n#include <algorithm>\n\ndouble FindMinimum(double a,
double b)\n{\n return std::min(a, b);\n}\n\ndouble FindMaximum(double a,
double b)\n{\n return std::max(a, b);\n}\n\n```",

"The SSE2 instruction set is used, specifically the `minsd`/`maxsd`
instructions, which branchlessly evaluate the minimum/maximum value of
two double-precision floating-point values. All 64-bit x86 processors
support [SSE2](https://en.wikipedia.org/wiki/SSE2); it is required by
the AMD64 extensions. Even most x86 processors without 64-bit support
SSE2. It was released in 2000."

]

},

{

"title": "InformIT Article on Branch-Free Min/Max and Doz",

"url":
"https://www.informit.com/articles/article.aspx?p=1959565&seqNum=19",

"excerpts": [

"For example, on the full RISC, ***z*** ← doz(***x, y***) can be
calculated as follows (r0 is a permanent zero registe",

"```\nsub z,x,y Set z = x - y.\r\ncmplt t,x,y Set t = 1 if x < y, else
0.\r\nmovne z,t,r0 Set z = 0 if x < y. ```",

"\n\nAlso on the full RISC, ***x* ←** max(***x, y***) can be calculated
as follows:\n\n```\ncmplt t,x,y Set t = 1 if x < y, else 0.\r\nmovne
x,t,y Set x = y if x < y. ```",

". The difference or zero instructions can be implemented without these
paths because it is the output of the adder (or 0) that is fed back to
the register file.",

"In the signed case, the result of the difference or zero instruction
can be negative.",

"If your machine has the conditional move instructions, it can get doz(
x, y ) in three instructions, and destructive 4 max( x, y ) and min( x,
y ) in two instructions."

]

},

{

"title": "Constant-time cryptography and compiler optimizations
(synthetic study excerpt)",

"url": "https://eprint.iacr.org/2025/435.pdf",

"excerpts": [

"n practice, even\nwithout this flag, the listed “constant-time” instructions are still constant-time by themselves,\neven in newer CPUs (as of early 2025); however, setting the DOIT flag will also disable some\nother in-CPU optimizations that can exhibit data-dependent timing differences, e.g.
data-\ndependent prefetching.",

"The main conclusion here is that trying to achieve constant-time processing through soft-\nware constructions that hide the true nature of performed operations from the compiler is\na fool’s errand and doomed to fai"

]

},

{

"title": "Bit Twiddling Hacks - HackMD",

"url": "https://hackmd.io/@derailment/bit-twiddling-hacks",

"excerpts": [

"Jun 4, 2019 — Compute the integer absolute value (abs) without
branching; Compute the minimum (min) or maximum (max) of two integers
without branching ..."

]

},

{

"title": "CMOV (Terje Mathisen)",

"url": "https://yarchive.net/comp/cmov.html",

"excerpts": [

"May 8, 2007 — The fastest way to handle min()/max() can often turn out
to be the naive CMP/JA/MOV sequence, as long as the branch pattern
predicts well."

]

},

{

"title": "Bit manipulation - Algorithms for Competitive Programming",

"url": "https://cp-algorithms.com/algebra/bit-manipulation.html",

"excerpts": [

"Missing: selection twiddling"

]

},

{

"title": "What are some of your favorite \"bit twiddling\" tricks? :
r/algorithms",

"url":
"https://www.reddit.com/r/algorithms/comments/14p1age/what_are_some_of_your_favorite_bit_twiddling/",

"excerpts": [

"I'm familiar with the basic/common \"bit twiddling\" hacks, such as
shifting to multiply/divide by 2. There must be so much more you can do
on the bit level.",

"Missing: min max"

]

},

{

"title": "On Modern Hardware the Min-Max Heap beats a Binary ...",

"url":
"https://probablydance.com/2020/08/31/on-modern-hardware-the-min-max-heap-beats-a-binary-heap/",

"excerpts": [

"Aug 31, 2020 — Here the min-max heap has pretty much the same speed as
the binary heap, mainly because the binary heap is already really fast.
(if you're ..."

]

},

{

"title": "Is it possible to find min/max of a number in x86 without
using shifts or xor?",

"url":
"https://stackoverflow.com/questions/30004525/is-it-possible-to-find-min-max-of-a-number-in-x86-without-using-shifts-or-xor",

"excerpts": [

"I'm trying to write min/max functions in x86. I've been able to do this
with the use of shifts and with the use of xor, but I need to find a way
to write it without these uses. Can someone lead me in the right
direction for this?",

"Example max function:",

"```\nint max(int *arr,int n){\n int max=arr[0];\n for(int
i=0;i<n;i++)max=(arr[i]>max)?arr[i]:max;\n return max;\n }\n\n``",

"This will take an array of integers (`arr`) and it's size (`n`) as
argument and return the maximum value containing in the array. To find
min change `max=(arr[i]>max)?arr[i]:max;` to
`max=(arr[i]<max)?arr[i]:max;`"

]

},

{

"title": "Templatized branchless int max/min function - c++",

"url":
"https://stackoverflow.com/questions/514435/templatized-branchless-int-max-min-function",

"excerpts": [

"I'm trying to write a branchless function to return the MAX or MIN of
two integers without resorting to if (or ?:)."

]

},

{

"title": "Fastest branchless binary search - Hacker News",

"url": "https://news.ycombinator.com/item?id=37086796",

"excerpts": [

"Furthermore, most code with branches can seemingly be replaced with
branchless code (ex: cmov instructions, min instruction, max
instruction, ..."

]

},

{

"title": "\"Side channel safe\" practices",

"url":
"https://users.rust-lang.org/t/side-channel-safe-practices/22024",

"excerpts": [

"Nov 6, 2018 — It appears they do have features for mitigating side
channel attacks using speculative execution: Using Intel® Compilers to
Mitigate Speculative ..."

]

},

{

"title": "Crate subtle - Rust",

"url": "https://doc.dalek.rs/subtle/",

"excerpts": [

"It consists of a Choice type, and a collection of traits using Choice
instead of bool which are intended to execute in constant-time. The
Choice type is a ..."

]

},

{

"title": "Require compiler to emit branchless/constant-time code",

"url":
"https://stackoverflow.com/questions/68327985/require-compiler-to-emit-branchless-constant-time-code",

"excerpts": [

"Making this into a question: if a certain piece of code must be emitted
in constant-time (or not at all), is there a compiler flag or pragma
..."

]

},

{

"title": "EABitTricks.h",

"url": "https://news.ycombinator.com/item?id=34043314",

"excerpts": [

"Dec 19, 2022 — One could also use a conditional move like CMOV on x86
if available ... bit twiddling hacks' collection:
https://graphics.stanford.edu ...",

"Modified BSD License (3-Clause BSD license), so it is permissive. Not
apparent from header file only. AdmiralAsshat on Dec 19, 2022 | parent
..."

]

},

{

"title": "oss-sec: Re: Data operand dependent timing on Intel and Arm
CPUs",

"url": "https://seclists.org/oss-sec/2023/q1/52",

"excerpts": [

"Missing: ctgrind LFENCE Rust"

]

},

{

"title": "branchless - Rust Package Registry",

"url": "https://crates.io/crates/branchless",

"excerpts": [

"Jan 2, 2024 — branchless v0.1.1 Algorithms and data structures designed
to maximize performance on superscalar processors."

]

},

{

"title": "constant_time_eq - Rust - Docs.rs",

"url": "https://docs.rs/constant_time_eq",

"excerpts": [

"Crate constant_time_eq Compares two equal-sized byte strings in
constant time. The time of the comparison does not depend on: The
contents of the inputs;"

]

},

{

"title": "Rust Internals: Optimization barriers suitable for
cryptographic use",

"url":
"https://internals.rust-lang.org/t/optimization-barriers-suitable-for-cryptographic-use/21047",

"excerpts": [

"gAJ\nWhat would be really handy here, short of full-blown secret types
which hint to LLVM that they shouldn't be branched upon , is literally
any kind of optimization barrier considered \"approved\" for
cryptographic use.",

"it\nPrograms cannot rely on\nblack_box for correctness , beyond it
behaving as the identity function. As such, it must not be relied upon
to control critical program behavior.",

"2\nThere are people writing cryptographic code targeting\nstable who
need solutions that work everywhere today.",

" 12\nThere are people writing cryptographic code targeting\nstable who
need solutions that work everywhere today. It seems like the best
portable solution currently available is\n{core, std}::hint::black_box
but the docs in their current form are scaring people away from using
it."

]

},

{

"title": "Data Operand Independent Timing ISA Guidance",

"url":
"https://www.intel.com/content/www/us/en/developer/articles/technical/software-security-guidance/best-practices/data-operand-independent-timing-isa-guidance.html",

"excerpts": [

"Data Operand Independent Timing Instruction Set Architecture (ISA)
Guidance",

"ID 768873",

"Updated 2/13/2023",

"Version Latest",

"Public",

"This document describes a new feature supported by some recent Intel
processors, adding a data operand independent timing mode which can be
used to ensure “constant time” execution for a specific subset of
instructions. Although not relevant for the majority of code, data
operand independent timing (DOIT) is a useful property for code which
has specifically been written to execute in constant time such as
cryptographic algorithms. This mode allows constant time code to inform
the processor that data operand independent timing is needed. DOIT
requires disabling hardware optimizations and/or performance features on
some processors; for example, enabling data operand independent timing
might disable data-dependent prefetching. This means that the DOIT mode
may have a performance impact, and Intel expects the performance impact
of this mode may be significantly higher on future processors."

]

},

{

"title": "Branchless selections – realtimecollisiondetection.net – the
blog",

"url": "https://realtimecollisiondetection.net/blog/?p=90",

"excerpts": [

"Nov 10, 2008 — Given 2 unsigned 32 bit integers a and b, how would you
compute a branchless version of max(a,b), without using a conditional
move instruction?"

]

},

{

"title": "The Entire World of Bit Twiddling Hacks",

"url":
"https://homolog.us/blogs/bioinfo/2014/12/04/the-entire-world-of-bit-twiddling-hacks/",

"excerpts": [

"Dec 4, 2014 — Compute the integer absolute value (abs) without
branching. Compute the minimum (min) or maximum (max) of two integers
without branching."

]

},

{

"title": "Bithacks - SnesLab",

"url": "https://sneslab.net/wiki/Bithacks",

"excerpts": [

"Bithacks are optimization tricks that utilize information in bits and
bit manipulation to accomplish their tasks. Usually they work in a
slightly non-obvious ..."

]

},

{

"title": "Branchless programming in c++ : r/cpp",

"url":
"https://www.reddit.com/r/cpp/comments/ul5p03/branchless_programming_in_c/",

"excerpts": [

"Using bithacks to do \"branchless programming\": pretty much only ...
bit if flag is set\" // initialize int other_val somehow int val ..."

]

},

{

"title": "ringbuf - Rust",

"url": "https://docs.rs/ringbuf",

"excerpts": [

"Storage is a place where ring buffer items are actually stored. It must
span a single contiguous memory area (e.g. we can obtain a slice or
subslice of it)."

]

},

{

"title": "bounded-spsc-queue - crates.io: Rust Package Registry",

"url": "https://crates.io/crates/bounded_spsc_queue",

"excerpts": [

"Jul 12, 2018 — This crate provides a very simple bounded,
Single-producer Single-consumer (SPSC) queue for Rust. It provides a
data structure for two threads ..."

]

},

{

"title": "Crate heapless - Rust",

"url": "https://docs.rs/heapless/latest/heapless/",

"excerpts": [

"The heapless crate provides static data structures with fixed capacity,
backed by static memory allocation, and doesn't use dynamic memory
allocation."

]

},

{

"title": "unbounded-spsc - crates.io: Rust Package Registry",

"url": "https://crates.io/crates/unbounded-spsc",

"excerpts": [

"This crate provides an unbounded SPSC queue with asynchronous sends,
using bounded_spsc_queue for the internal queue. This provides better
..."

]

},

{

"title": "heapless::spsc - Rust",

"url": "https://rudihorn.github.io/light-cli/heapless/spsc/index.html",

"excerpts": [

"API documentation for the Rust `spsc` mod in crate `heapless`."

]

},

{

"title": "Making Sense of Acquire-Release Semantics",

"url": "https://davekilian.com/acquire-release.html",

"excerpts": [

"Since the acquire and release operations must be serialized, they need
to operate on the same variable, and they need to both be atomic; that's
what allows us ..."

]

},

{

"title": "Criticism request: Single-producer, single-consumer queue",

"url":
"https://ziggit.dev/t/criticism-request-single-producer-single-consumer-queue/3534",

"excerpts": [

"Mar 11, 2024 — Hello there, I want a thread-safe queue for a project of
mine. In general, I expect there to be a significant delay in between
pushes."

]

},

{

"title": "tokio-rs/loom: Concurrency permutation testing tool for Rust.
- GitHub",

"url": "https://github.com/tokio-rs/loom",

"excerpts": [

"Missing: SPSC queue",

"iew all files\n\n\n\nRepository files navigation\n * README\n * MIT
license\n\nLoom\nLoom is a testing tool for concurrent Rust code. It
runs a test many\ntimes, permuting the possible concurrent executions of
that test under\nthe C11 memory model . It uses state
reduction\ntechniques to avoid combinatorial explosion. Quickstart\nThe
loom documentation has significantly more documentation on\nhow to use
loom. But if you just want a jump-start, first add this
to\nyour\nCargo.toml . [ target . 'cfg(loom)' .\ndependencies ] loom =
\" 0.7 \"\nNext, create a test file and add a test:\nuse loom :: sync ::
Arc ; use loom :: sync :: atomic :: AtomicUsize ; use loom :: sync ::
atomic :: Ordering :: { Acquire , Release , Relaxed } ; use loom ::
thread ; # [ test ] # [ should_panic ] fn buggy_concurrent_inc ( ) {
loom :: model ( || { let num = Arc :: new ( AtomicUsize :: new ( 0 ) ) ;
let ths : Vec < _ > = ( 0 .. 2 ) . map ( |_| { let num = num . clone ( )
; thread :: spawn ( move || { let curr = num . load ( Acquire ) ; num .
store ( curr + 1 , Release ) ; } ) } ) . collect ( ) ; for th in ths {
th . join ( ) . unwrap ( ) ; } assert_eq ! ( 2 , num . load ( Relaxed )
) ; } ) ; }\nThen, run the test with\nRUSTFLAGS=\"--cfg loom\" cargo
test --test buggy_concurrent_inc --release\nUnsupported features\nLoom
currently does not implement the full C11 memory model. Here is the
(incomplete) list of unsupported features. * SeqCst accesses (e.g. load
,\nstore , ..):\nThey are regarded as\nAcqRel . That is, they impose
weaker\nsynchronization, causing Loom to generate false alarms (not
complete). See #180 for example. On the other\nhand,\nfence(SeqCst) is
supported. * Load buffering behavior:\nLoom does not explore some
executions that are possible in the C11 memory\nmodel. That is, there
can be a bug in the checked code even if Loom says\nthere is no bug (not
sound). See the\nload_buffering test case in\ntests/litmus.rs .
License\nThis project is licensed under the MIT license ."

]

},

{

"title": "Rust Atomics and Locks — Chapter 3. Memory Ordering - Mara",

"url": "https://marabos.nl/atomics/memory-ordering.html",

"excerpts": [

"Missing: SPSC circular"

]

},

{

"title": "How to distinguish empty from full on a lock-free SPSC ring
...",

"url":
"https://stackoverflow.com/questions/71441528/how-to-distinguish-empty-from-full-on-a-lock-free-spsc-ring-buffer-that-overwrit",

"excerpts": [

"Use LDREX and STREX operations in the writer to atomically adjust the
read pointer to discard the oldest byte if the buffer was already full."

]

},

{

"title": "Circular lock-free buffer - c++",

"url":
"https://stackoverflow.com/questions/871234/circular-lock-free-buffer",

"excerpts": [

"A semi-lock-free circular buffer where the producer thread put data in
the buffer as fast as it can, let's call the head of the buffer A,
without blocking ..."

]

},

{

"title": "concurrent-queue - Lib.rs",

"url": "https://lib.rs/crates/concurrent-queue",

"excerpts": [

"A concurrent multi-producer multi-consumer queue. There are two kinds
of queues: Bounded queue with limited capacity. Unbounded queue with
unlimited capacity."

]

},

{

"title": "Rust release and acquire memory ordering by example",

"url":
"https://medium.com/@omid.jn/rust-release-and-acquire-memory-ordering-by-example-d8de58ef4e36",

"excerpts": [

"Test Concurrent Code With loom. Loom is a crate in Rust that provides a
framework for writing concurrent code. It is designed to make it ..."

]

},

{

"title": "spsc-ringbuf-core Crate Documentation",

"url": "https://crates.io/crates/spsc-ringbuf-core",

"excerpts": [

"This is a heapless single producer single consumer (SPSC) ring buffer
that depends only on the Rust Core library.",

"\nspsc-ringbuf-core - crates.io: Rust Package
Registry\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",

"Introduction\n============\n\nThis is a heapless single producer single
consumer (SPSC) ring buffer that\ndepends only on the Rust Core
library.",

"The top level\nRingBuf structure provides the final protection of
unintended\ndirect usage of the inner ring buffer. This wrapper provides
a one-time call\nreturning a pair of (mutable) handles that can be moved
to producer and\nconsumer entities.",

"Metadata\n--------\n\npkg:cargo/spsc-ringbuf-core@0.1.0\n\nabout 2
years ago\n\n2021 edition\n\nnon-standard\n\n12.2
KiB\n\nInstall\n-------\n\n",

"The inner ring buffer is designed to be easily instantiable as
global\nstatic encapsulating any need of using\nunsafe to access the
structure in user\ncode.",

"In order to achieve the goal of allocating these queues statically
while avoid\nrequiring all code that uses the structure to be wrapped
in\nunsafe , the\nimplementation employs the following methods:\n * Cell
wrapped read and write indices for providing interior mutability
of\nindices\n * limited internal\nunsafe code to return mutable
references of the inner\nbuffer. This is considered safe due to the
single producer and single\nconsumer premise",

"This crate also provides a separate cheaper implementation for the
special case\nof single item ring buffer"

]

},

{

"title": "heapless::spsc - Rust",

"url": "https://docs.rs/heapless/latest/heapless/spsc/index.html",

"excerpts": [

"fixed capacity Single Producer Single Consumer (SPSC) queue",

"Implementation based on
<https://www.codeproject.com/Articles/43510/Lock-Free-Single-Producer-Single-Consumer-Circular>",

"This module requires CAS atomic instructions which are not available on
all architectures"

]

},

{

"title": "0018-9340/79/0900-0690$00.75 C) 1979 IEEE",

"url":
"https://www.microsoft.com/en-us/research/wp-content/uploads/2016/12/How-to-Make-a-Multiprocessor-Computer-That-Correctly-Executes-Multiprocess-Programs.pdf",

"excerpts": [

"by L LAMPORT · 1979 · Cited by 3830 — Requirement R2: Memory requests
from all processors issued to an individual memory module are serviced
from a single FIFO queue. Issuing a memory request ..."

]

},

{

"title": "Writing a Fast and Versatile SPSC Ring Buffer – Performance
...",

"url":
"https://www.daugaard.org/blog/writing-a-fast-and-versatile-spsc-ring-buffer--performance-results/",

"excerpts": [

"Aug 13, 2018 — Changing the other ring buffer's memory order makes it
run in about 30 seconds. I haven't looked closely at whether it's safe,
but it worked ..."

]

},

{

"title": "Why is `ringbuf` crate so fast? : r/rust - Reddit",

"url":
"https://www.reddit.com/r/rust/comments/1h3bqv0/why_is_ringbuf_crate_so_fast/",

"excerpts": [

"If I change the ordering of load() from Acquire to Relaxed (which I
think is OK), my ring buffer becomes much faster. If I change the
ordering ..."

]

},

{

"title": "How To Make Your SPSC Ring Buffer Do Nothing, More ...",

"url":
"https://www.daugaard.org/blog/how-to-make-your-spsc-ring-buffer-do-nothing-more-efficiently/",

"excerpts": [

"The idea is that we are going to check the bool every time we finish
writing something or reading something:\n\n```\nvoid
RingBuffer::FinishWrite()\n{\n m_WriterShared.pos.store(m_Writer.base +
m_Writer.pos, std::memory_order_release);\n if
(m_WriterShared.shouldSignal.exchange(false))\n
m_ReaderShared.semaphore.signal();\n}\n\n```\n",

"Sep 5, 2018 — I said earlier that the positions are written and read
using release/acquire ordering, which only guarantees that they are
consistent with the ... ```\n",

" struct alignas(CACHE_LINE_SIZE) SharedState",

" {\n std::atomic<size_t> pos;\n std::atomic<bool> shouldSignal;\n
Semaphore semaphore;\n };\n\n```",

"The call to `exchange` returns the existing value of `shouldSignal`
while also resetting it to `false`.",

"#### Picking up the pieces",

"Fortunately, there is a solution. It involves checking the position
again after requesting a signal and before going to sleep:\n\n```\n for
(;;)\n {\n size_t writerPos =
m_WriterShared.pos.load(std::memory_order_acquire);\n size_t available =
writerPos - m_Reader.base;\n // Signed comparison (available can be
negative)\n if (static_cast<ptrdiff_t>(available) >=
static_cast<ptrdiff_t>(end))\n {\n m_Reader.end = std::min(available,
m_Reader.size);\n break;\n }\n
m_WriterShared.shouldSignal.store(true);\n if (writerPos !=
m_WriterShared.pos.load(std::memory_order_relaxed))\n {\n // Position
changed after we requested signal, try to cancel\n if
(m_WriterShared.shouldSignal.exchange(false))\n continue; // Request
successfully cancelled\n }\n m_ReaderShared.semaphore.wait();\n
}\n\n```\n",

" solution. It involves checking the position again after requesting a
signal and before going to sleep:\n\n```\n for (;;)\n {\n size_t
writerPos = m_WriterShared.pos.load(std::memory_order_acquire);\n size_t
available = writerPos - m_Reader.base;\n // Signed comparison (available
can be negative)\n if (static_cast<ptrdiff_t>(available) >=
static_cast<ptrdiff_t>(end))\n {\n m_Reader.end = std::min(available,
m_Reader.size);\n break;\n }\n
m_WriterShared.shouldSignal.store(true);\n if (writerPos !=
m_WriterShared.pos.load(std::memory_order_relaxed))\n {\n // Position
changed after we requested signal, try to cancel\n if
(m_WriterShared.shouldSignal.exchange(false))\n continue; // Request
successfully cancelled\n }\n m_ReaderShared.semaphore.wait();\n }\n\n`"

]

},

{

"title": "Lock-Free Single-Producer - Single Consumer Circular Queue",

"url":
"https://www.codeproject.com/Articles/43510/Lock-Free-Single-Producer-Single-Consumer-Circular",

"excerpts": [

"Memory model: sequential or relaxed/acquire/release? Two versions of
the wait and lock-free circular FIFO are presented. The first, most
intuitive, use C++11 ..."

]

},

{

"title": "ring_buffer_no_std - crates.io: Rust Package Registry",

"url": "https://crates.io/crates/ring_buffer_no_std/0.1.0",

"excerpts": [

"Browse All Crates; Log in with GitHub. ring_buffer_no_std v0.1.0. A
ring buffer supporting no_std. #no_std · Readme · 2 Versions ·
Dependencies ..."

]

},

{

"title": "heapless::spsc - Rust",

"url": "https://rtic.rs/1/api/heapless/spsc/index.html",

"excerpts": [

"use heapless::spsc::Queue; let mut rb: Queue<u8, 4> = Queue::new();
assert!(rb.enqueue(0).is_ok()); assert!(rb.enqueue(1).is_ok());
assert!(rb.enqueue(2).is_ok() ..."

]

},

{

"title": "make in bounded_spsc_queue - Rust",

"url":
"https://docs.rs/bounded-spsc-queue/latest/bounded_spsc_queue/fn.make.html",

"excerpts": [

"Creates a new SPSC Queue, returning a Producer and Consumer handle.
Capacity specifies the size of the bounded queue to create. Actual
memory usage will be ..."

]

},

{

"title": "Queue in heapless::spsc - Rust",

"url":
"https://docs.rs/heapless/latest/heapless/spsc/struct.Queue.html",

"excerpts": [

"A statically allocated single producer single consumer queue with a
capacity of N - 1 elements. IMPORTANT: To get better performance use a
value for N that is ..."

]

},

{

"title": "Circ_buffer - A no_std circular buffer with optional serde
...",

"url":
"https://users.rust-lang.org/t/circ-buffer-a-no-std-circular-buffer-with-optional-serde-support/114804",

"excerpts": [

"A statically-sized circular buffer with (de)-serialization support.
Upon closer inspection, I saw that there was no crate which is no_std
and supports (de)- ..."

]

},

{

"title": "loom - Rust",

"url": "https://docs.rs/loom/latest/loom/",

"excerpts": [

"Loom is a tool for testing concurrent programs. At a high level, it
runs tests many times, permuting the possible concurrent executions of
each test."

]

},

{

"title": "Properly Testing Concurrent Data Structures - Media",

"url":
"https://ziggit.dev/t/properly-testing-concurrent-data-structures/5005",

"excerpts": [

"Jul 6, 2024 — There's a fascinating Rust library, loom, which can be
used to thoroughly test lock-free data structures. I always wanted to
learn how it works ..."

]

},

{

"title": "1024cores",

"url": "https://www.1024cores.net/",

"excerpts": [

"My name is Dmitry Vyukov, and I'm going to share here various
information about lockfree, waitfree, obstructionfree synchronization
algorithms and data ..."

]

},

{

"title": "A lock-free ring-buffer with contiguous reservations (2019)",

"url": "https://news.ycombinator.com/item?id=39550124",

"excerpts": [

"... (Relaxed, Release, Acquire, AcqRel, and SeqCst). I'm very sure
there ... spsc-bip-buffer, some of the orderings are relaxed for
performance."

]

},

{

"title": "I've incidentally created one of the fastest bounded MPSC
queue",

"url":
"https://www.reddit.com/r/rust/comments/14jasc6/ive_incidentally_created_one_of_the_fastest/",

"excerpts": [

"This is a IO-oriented bounded MPSC queue, whose algorithm allows
dequeuing slice by slice – that's convenient for zero-allocation IO
buffering."

]

},

{

"title": "tokio::sync - Rust",

"url": "https://docs.rs/tokio/latest/tokio/sync/index.html",

"excerpts": [

"There is no dedicated spsc channel. Example: using an mpsc to
incrementally stream the results of a series of computations. use
tokio::sync::mpsc; async fn ..."

]

},

{

"title": "sparking_lot_core - Rust - Docs.rs",

"url": "https://docs.rs/sparking-lot-core",

"excerpts": [

"For example, when implementing a SPSC channel, the sender could park on
<address of inner state> and the receiver on <address of inner
state>.cast::<u8> ..."

]

},

{

"title": "Unbounded single-producer/single-consumer queue",

"url":
"https://www.1024cores.net/home/lock-free-algorithms/queues/unbounded-spsc-queue",

"excerpts": [

"The unbounded SPSC queue is a single-producer/single-consumer queue
with a non-reducible cache, wait-free dequeue, and can be used for
hardware device ... Hardware platform: x86-32/64",

"template<typename T>\nT load_consume(T const* addr)\n{\n// hardware
fence is implicit on x86\nT v = *const_cast<T const
volatile*>(addr);\n__memory_barrier(); // compiler fence\nreturn v;\n}",

"// store with 'release' memory ordering\ntemplate<typename T>\nvoid
store_release(T* addr, T v)\n{\n// hardware fence is implicit on
x86\n__memory_barrier(); // compiler fence\n*const_cast<T
volatile*>(addr) = v;\n}",

"void store\\_release(T\\* addr, T ",

"spsc\\_queu",

"class spsc\\_queu",

" Queue\nUnbounded single-producer/single-consumer",

"enqueue(T v)",

"node* n = alloc_node();",

"n->next_ = 0;",

"n->value_ = v;",

"store_release(&head_->next_, n);",

"head_ = n;",

"bool dequeue(T& v)",

"if (load_consume(&tail_->next_))",

"v = tail_->next_->value_;",

"store_release(&tail_, tail_->next_);",

"return true;",

"else",

"return false;",

"}",

"}",

"}",

"}",

"private:",

"struct node",

"{",

"{",

"{",

"{",

"{",

"node* next_;",

"};",

"// consumer part",

"// accessed mainly by consumer, infrequently be producer",

"node* tail_; // tail of the queue",

"// delimiter between consumer part and producer part,",

"// so that they situated on different cache lines",

"char cache_line_pad_",

"class spsc_queue\n{\npublic:\nspsc_queue()\n{\nnode* n = new
node;\nn->next_ = 0;\ntail_ = head_ = first_= tail_copy_ =
n;\n}\n~spsc_queue()\n{\nnode* n = first_;\ndo\n{\nnode* next =
n->next_;\ndelete n;\nn = next;\n}\nwhile (n);\n}\nvoid enqueue(T
v)\n{\nnode* n = alloc_node();\nn->next_ = 0;\nn->value_ =
v;\nstore_release(&head_->next_, n);\nhead_ = n;\n}\n// returns 'false'
if queue is empty\nbool dequeue(T& v)\n{\nif
(load_consume(&tail_->next_))\n{\nv =
tail_->next_->value_;\nstore_release(&tail_, tail_->next_);\nretu"

]

},

{

"title": "exponential.rs - rand_xoshiro-0.4.0",

"url":
"https://git.tu-berlin.de/felixmoebius/rand/-/blob/rand_xoshiro-0.4.0/rand_distr/src/exponential.rs",

"excerpts": [

"}",

"}"

]

},

{

"title": "PAUSE in Rust - Rust Forum",

"url": "https://users.rust-lang.org/t/pause-instruction/32262",

"excerpts": [

"}",

"}"

]

},

{

"title": "Intel spin-wait loops and _mm_pause",

"url":
"https://www.intel.com/content/www/us/en/developer/articles/technical/a-common-construct-to-avoid-the-contention-of-threads-architecture-agnostic-spin-wait-loops.html",

"excerpts": [

"}",

"}",

"}",

"}",

"{",

"{",

"{",

"{"

]

},

{

"title": "Romu/SplitMix C code excerpts from ROMU random paper",

"url": "https://www.romu-random.org/romupaper.pdf",

"excerpts": [

"}",

"}"

]

},

{

"title": "Time, Clocks, and the Ordering of Events in a Distributed
System",

"url": "https://lamport.azurewebsites.net/pubs/time-clocks.pdf",

"excerpts": [

"by L Lamport · 1978 · Cited by 14544 — In this paper, we discuss the
partial ordering defined by the \"happened before\" relation, and give a
distributed algorithm for extending it to a consistent ..."

]

},

{

"title": "rtrb - crates.io: Rust Package Registry",

"url": "https://crates.io/crates/rtrb",

"excerpts": [

"A wait-free single-producer single-consumer (SPSC) ring buffer for
Rust. This crate can be used without the standard library ( #![no_std] )
by disabling the ..."

]

},

{

"title": "rtrb - crates.io: Rust Package Registry",

"url": "https://crates.io/crates/rtrb/0.3.0",

"excerpts": [

"A wait-free single-producer single-consumer (SPSC) ring buffer for
Rust. ... This crate can be used without the standard library (
#![no_std] ) by ..."

]

},

{

"title": "rigtorp/SPSCQueue: A bounded single-producer ...",

"url": "https://github.com/rigtorp/SPSCQueue",

"excerpts": [

"A single producer single consumer wait-free and lock-free fixed size
queue written in C++11. This implementation is faster than both
boost::lockfree::spsc and ...",

"This project was created by Erik Rigtorp <erik@rigtorp.se>. About. A
bounded single-producer single-consumer wait-free and lock-free queue
written in C++11 ..."

]

},

{

"title": "SpscLinkedQueue.java - JCTools/JCTools",

"url":
"https://github.com/JCTools/JCTools/blob/master/jctools-core/src/main/java/org/jctools/queues/SpscLinkedQueue.java",

"excerpts": [

"1024 Cores</a> by D. Vyukov. The original has been adapted to Java and
it's quirks with regards to memory. * model and layout:."

]

},

{

"title": "bounded-spsc-queue - Rust Package Registry",

"url": "https://crates.io/crates/bounded_spsc_queue/dependencies",

"excerpts": [

"Dependencies. This version of the \"bounded-spsc-queue\" crate has no
dependencies. Dev-Dependencies. ^0.2.3. ^0.2.3 criterion.
Statistics-driven micro ..."

]

},

{

"title": "Need help understand how `loom` scheduler handles atomics
...",

"url":
"https://users.rust-lang.org/t/need-help-understand-how-loom-scheduler-handles-atomics-especially-for-spin-loops/127906",

"excerpts": [

"I've been playing with loom recently. it helps test concurrent code by
running them with all possible permutations of concurrent execution ..."

]

},

{

"title": "ringbuf - crates.io: Rust Package Registry",

"url": "https://crates.io/crates/ringbuf/0.2.8",

"excerpts": [

"Lock-free SPSC FIFO ring buffer with direct access to inner data. ...
Also the crate could be used with no_std (but alloc is still required)."

]

},

{

"title": "rtrb: Real-Time Ring Buffer",

"url": "https://github.com/mgeier/rtrb",

"excerpts": [

"A wait-free single-producer single-consumer (SPSC) ring buffer for
Rust. This crate can be used without the standard library ( #![no_std] )
by disabling the ...",

"This crate can be used without the standard library (\n#! [no_std]
)\nby disabling the\nstd feature (which is enabled by default),\nbut the
alloc crate is needed nevertheless",

"Alternatives",

"There are many varieties of ring buffers available, here we limit the
selection\nto wait-free SPSC implementations:",

"* ach-spsc (using const generics)\n* heapless (for embedded systems,
see\nheapless::spsc )\n* ringbuf (supports const generics and heap
allocation)\n* ringbuffer-spsc (using const generics)\n",

"There are also implementations in other languages:",

"* atomic_queues (C++)\n* boost::lockfree::spsc_queue (C++)\n*
folly::ProducerConsumerQueue (C++)\n* lockfree::spsc::RingBuf (C++)\n*
readerwriterqueue (C++)\n* ringbuf.js (JavaScript,
using\nSharedArrayBuffer )\n* spsc_queue (C++)\n* SPSC-Queue (C++)\n*
SPSCQueue (C++)\n",

"If you know more alternatives for this list,\nplease open an issue .",

"License",

"Licensed under either of",

"* Apache License, Version 2.0 ( LICENSE-APACHE or
http://www.apache.org/licenses/LICENSE-2.0 )\n* MIT license (
LICENSE-MIT or http://opensource.org/licenses/MIT )\n",

"at your option. Note that this crate contains a copy of the
file\ncache_padded.rs from https://github.com/crossbeam-rs/crossbeam ."

]

},

{

"title": "Are memory orders for each atomic correct in this lock-free
...",

"url":
"https://stackoverflow.com/questions/70512371/are-memory-orders-for-each-atomic-correct-in-this-lock-free-spsc-ring-buffer-que",

"excerpts": [

"Are memory orders for each atomic correct in this lock-free SPSC ring
buffer queue? ... ordering between release/acquire. – user17732522."

]

},

{

"title": "Producer-Consumer Queues - 1024cores",

"url": "https://www.1024cores.net/home/lock-free-algorithms/queues",

"excerpts": [

"Producer-consumer queues are one of the most fundamental components in
concurrent systems, they represent means to transfer
data/messages/tasks/transactions ..."

]

},

{

"title": "ringbuf - crates.io: Rust Package Registry",

"url": "https://crates.io/crates/ringbuf/0.4.0-rc.0",

"excerpts": [

"Jun 13, 2023 — ringbuf. Crates.io Docs.rs Github Actions License.
Lock-free SPSC FIFO ring buffer with direct access to inner data."

]

},

{

"title": "Blog Post: Properly Testing Concurrent Data Structures",

"url":
"https://www.reddit.com/r/rust/comments/1dwm0c9/blog_post_properly_testing_concurrent_data/",

"excerpts": [

"Another good technique is to use Miri & the --many-seeds flag. For
example: cargo miri test --many-seeds=0..128 Miri has pretty decent weak
memory emulation."

]

},

{

"title": "Concurrent Lock Free SPSC Queue - by Youwei Zhuo",

"url":
"https://medium.com/@youweizhuo/concurrent-lock-free-queue-c9abd8bf700d",

"excerpts": [

"A lock-free, cache-efficient multi-core synchronization mechanism for
line-rate network traffic monitoring."

]

},

{

"title": "Can anyone explain feedback of a HFT firm regarding ...",

"url":
"https://www.reddit.com/r/highfreqtrading/comments/14xhczw/can_anyone_explain_feedback_of_a_hft_firm/",

"excerpts": [

"Can anyone explain feedback of a HFT firm regarding implementation of
SPSC lock-free ring-buffer queue? During an interview at a HFT
company ..."

]

},

{

"title": "Rust Concurrency: Fearless Concurrency - DEV Community",

"url":
"https://dev.to/leapcell/rust-concurrency-fearless-concurrency-24h",

"excerpts": [

"Rust's ownership system and type safety system are powerful tools for
solving memory safety and concurrency issues. Through ownership and type
..."

]

},

{

"title": "ringbuffer-spsc crates.io page",

"url": "https://crates.io/crates/ringbuffer-spsc",

"excerpts": [

"ringbuffer-spsc\nv0.1.13\n=======================\n\nA fast thread-safe
single producer-single consumer ring buffer",

"use ringbuffer_spsc::RingBuffer;\n\nfn main() {\n const N: usize =
1_000_000;\n let (mut tx, mut rx) = RingBuffer::<usize, 16>::new();\n\n
let p = std::thread::spawn(move || {\n let mut current: usize = 0;\n
while current < N {\n if tx.push(current).is_none() {\n current =
current.wrapping_add(1);\n } else {\n std::thread::yield_now();\n }\n
}\n });\n\n let c = std::thread::spawn(move || {\n let mut current:
usize = 0;\n while current < N {\n if let Some(c) = rx.pull() {\n
assert_eq! (c, current);\n current = current.wrapping_add(1);\n } else
{\n std::thread::yield_now();\n }\n }\n });\n\n p.join().unwrap();\n
c.join().unwrap();"

]

},

{

"title": "Properly Testing Concurrent Data Structures",

"url":
"https://matklad.github.io/2024/07/05/properly-testing-concurrent-data-structures.html",

"excerpts": [

"s a fascinating Rust library, loom , which can be used to thoroughly
test lock-free data\nstructures. I always wanted to learn how it works.
I still do! But\nrecently I accidentally implemented a small toy which,
I think,\ncontains some of the loom’s ideas, and it seems worthwhile to
write"

]

},

{

"title": "History for rfc4648",

"url": "https://datatracker.ietf.org/doc/rfc4648/history/",

"excerpts": [

"The Base16, Base32, and Base64 Data Encodings RFC 4648 Revision
differences From revision RFC 4648 (2006-10-16)"

]

},

{

"title": "Base32Encoding Class - CryptSharp Documentation",

"url":
"https://documentation.help/CryptSharp/2930831a-6a2f-7bc4-d047-97d411251b46.htm",

"excerpts": [

"Crockford base-32 is somewhat traditional, but still better than the
RFC 4648 standard. It is specified at
http://www.crockford.com/wrmg/base32.html. Public ..."

]

},

{

"title": "data_encoding - Rust - Docs.rs",

"url": "https://docs.rs/data-encoding/",

"excerpts": [

"Efficient and customizable data-encoding functions like base64, base32,
and hex. This crate provides little-endian ASCII base-conversion
encodings for bases ..."

]

},

{

"title": "base32 - Keywords - crates.io: Rust Package Registry",

"url": "https://crates.io/keywords/base32",

"excerpts": [

"All Crates for keyword 'base32' ; data-encoding v2.9.0. Efficient and
customizable data-encoding functions like base64, base32, and hex ;
data-encoding-macro v0."

]

},

{

"title": "BibTeX",

"url": "https://datatracker.ietf.org/doc/rfc4648/bibtex/",

"excerpts": [

"... {RFC 4648}, publisher = {RFC Editor}, doi = {10.17487/RFC4648}, url
= {https://www.rfc-editor.org/info/rfc4648}, author = {Simon Josefsson},
title = {{The ..."

]

},

{

"title": "Information on RFC 4648 - » RFC Editor",

"url": "https://www.rfc-editor.org/info/rfc4648",

"excerpts": [

"This document describes the commonly used base 64, base 32, and base 16
encoding schemes. It also discusses the use of line-feeds in encoded
data."

]

},

{

"title": "RFC 3548 - The Base16, Base32, and Base64 Data Encodings",

"url": "https://datatracker.ietf.org/doc/html/rfc3548",

"excerpts": [

"This document describes the commonly used base 64, base 32, and base 16
encoding schemes. It also discusses the use of line-feeds in encoded
data."

]

},

{

"title": "Diff: draft-josefsson-rfc3548bis-04.txt - rfc4648.txt",

"url":
"https://josefsson.org/base-encoding/rfc4648-from-draft-josefsson-rfc3548bis-04.diff.html",

"excerpts": [

"This encoding may be referred to as \"base32\". The Base 32 encoding is
designed to represent arbitrary sequences of, The Base 32 encoding is
designed to ..."

]

},

{

"title": "Fast decoding of base32 strings",

"url":
"https://lemire.me/blog/2023/07/20/fast-decoding-of-base32-strings/",

"excerpts": [

"Base32 works in the following manner: you use 8 ASCII characters to
encode 5 bytes. Each ASCII characters carries 5 bits of information: it
can be one of 32 characters.",

"There are different variations, but we can consider Base 32 Encoding
with Extended Hex Alphabet which uses the letters 0 to 9 for the values
0 to 9 and the letters A to V for the numbers from 10 to 31.",

"A conventional decoder might use branchy code:\nif ( ch > = '0' & & ch
< = '9' ) d = ch - '0' ; else if ( ch > = 'A' & & ch < = 'V' ) d = ch -
'A' + 10 ; else if ( ch > = 'a' & & ch < = 'v' ) d = ch - 'a' + 10 ;
else ret",

"You can also program a version using SIMD instructions. I am not going
to present the code, it is similar to the code described in a base64
pape r",

"Daniel Lemire, \"Fast decoding of base32 strings,\" in Daniel Lemire's
blog , July 20, 2023,
https://lemire.me/blog/2023/07/20/fast-decoding-of-base32-strings/ .",

"Base32 can be case invariant. There are different variations, but we
can consider Base 32 Encoding with Extended Hex Alphabet which uses the
letters 0 to 9 for the values 0 to 9 and the letters A to V for the
numbers from 10 to 31."

]

},

{

"title": "hexhex - crates.io: Rust Package Registry",

"url": "https://crates.io/crates/hexhex",

"excerpts": [

"Sep 29, 2023 — hexhex 🪄 hexadecimal conversion. Features: Display bytes
as hex with no (heap) allocations; Convert bytes to hex String; Convert
hex &str or ..."

]

},

{

"title": "hex - Keywords - crates.io: Rust Package Registry",

"url": "https://crates.io/keywords/hex",

"excerpts": [

"A hex encoding and decoding crate with a conservative MSRV and
dependency policy. All-Time: 9,470,404."

]

},

{

"title": "data-encoding - crates.io: Rust Package Registry",

"url": "https://crates.io/crates/data_encoding/dependencies",

"excerpts": [

"Efficient and customizable data-encoding functions like base64, base32,
and hex. #base32 · #base64 · #hex · #no_std · Readme · 23 Versions ·
Dependencies ..."

]

},

{

"title": "data-encoding-v3 - crates.io: Rust Package Registry",

"url": "https://crates.io/crates/data-encoding-v3",

"excerpts": [

"Only the final version will be published to data-encoding. In
particular, the data-encoding crate won't have any 3.0.0 pre-release
version. This ..."

]

},

{

"title": "RFC 4648 Base-N Encodings",

"url": "https://datatracker.ietf.org/doc/html/rfc4648",

"excerpts": [

"BASE16(\"foobar\") = \"666F6F626172\"",

"RFC 4648 Base-N Encodings October 2006",

"BASE32(\"foobar\") = \"MZXW6YTBOI======\"",

"BASE32(\"foo\") = \"MZXW6===\""

]

},

{

"title": "Base32 Encoding and RFC4648 Reference",

"url": "https://ptrchm.com/posts/base32-explained/",

"excerpts": [

"In Base32, each character can encode 5 bits of data (2^5 = 32 character
combinations of 5 bits). The [RFC
4648](https://datatracker.ietf.org/doc/html/rfc4648) defines the
following set of characters:",

"Base32 implementation (RFC 4648)",

"Value Encoding Value Encoding Value Encoding Value Encoding",

" 0 A 9 J 18 S 27 3",

" 1 B 10 K 19 T 28 4",

" 2 C 11 L 20 U 29 5",

" 3 D 12 M 21 V 30 6",

" 4 E 13 N 22 W 31 7",

" 5 F 14 O 23 X",

"Dec 17, 2023 — Decoding · Remove the = padding characters from the
input string. · Split the string into an array of characters. · Turn
each character into its ...",

" 7 H 16 Q 25 Z",

" 8 I 17 R 26 2"

]

},

{

"title": "Base encodings and Rust crates (RFC4648, Crockford, and
related tooling)",

"url": "https://crates.io/crates/koibumi-base32",

"excerpts": [

"koibumi-base32 - crates.io: Rust Package Registry"

]

},

{

"title": "crockford - crates.io: Rust Package Registry",

"url": "https://crates.io/crates/crockford",

"excerpts": [

"Base32 encoding for 64-bit values. Crockford Base32 Encoding is most
commonly used to make numeric identifiers slightly more
user-resistant.",

"Missing: hex base16"

]

},

{

"title": "nervosnetwork/faster-hex: fast hex - GitHub",

"url": "https://github.com/nervosnetwork/faster-hex",

"excerpts": [

"This program implements hex encoding a slice into a predetermined
destination using various different instruction sets."

]

},

{

"title": "base16",

"url": "https://crates.io/crates/base16/versions",

"excerpts": [

"The Rust community's crate registry. Submit. Change color scheme.
light; dark ... base16. base16 (hex) encoding and decoding. #hex ·
#base16 · #decode · #encode ..."

]

},

{

"title": "base16ct - crates.io: Rust Package Registry",

"url": "https://crates.io/crates/base16ct",

"excerpts": [

"Pure Rust implementation of Base16 a.k.a hexadecimal (RFC 4648) which
avoids any usages of data-dependent branches/LUTs and thereby provides
..."

]

},

{

"title": "data-encoding - crates.io: Rust Package Registry",

"url": "https://crates.io/crates/data-encoding",

"excerpts": [

"Missing: most used base16"

]

},

{

"title": "Vectorize base16 (hex) decoding #26 - NLnetLabs/simdzone -
GitHub",

"url": "https://github.com/NLnetLabs/simdzone/issues/26",

"excerpts": [

"An AVX2 port of the base32hex style decoder would require 4 shuffles
per 32-bytes of input. The linked solution by Geoff Langdale uses 2
shuffles, has only 1 ..."

]

},

{

"title": "How to convert a binary integer number to a hex string?",

"url":
"https://stackoverflow.com/questions/53823756/how-to-convert-a-binary-integer-number-to-a-hex-string",

"excerpts": [

"Then use a pshufb to map those nibbles to hex digits. That leaves us
with the ASCII digits an XMM register with the least significant digit
..."

]

},

{

"title": "Using SSE to convert from hexadecimal ASCII to number",

"url":
"http://0x80.pl/notesen/2014-10-22-sse-convert-hex-to-ascii.html",

"excerpts": [

"In SSSE3 it can be done with pshufb, but in the earlier versions of SSE
this is quite hard. When byte shuffling is not available then ..."

]

},

{

"title": "tplgy/cppcodec: Header-only C++11 library to encode ...",

"url": "https://github.com/tplgy/cppcodec",

"excerpts": [

"Header-only C++11 library to encode/decode base64, base64url, base32,
base32hex and hex (aka base16) as specified in RFC 4648, plus
Crockford's base32."

]

},

{

"title": "Daniel Lemire's blogFast decoding of base32 stringsTelegraph
...",

"url": "https://channel.eastonman.com/posts/30522",

"excerpts": [

"We often need to encode binary data into ASCII strings. The standards
(e.g., email) to do so include base16, base32 and base64. There are some
research papers ..."

]

},

{

"title": "Understanding Base32 and Base64 Encoding | by 1kg",

"url":
"https://medium.com/@1kg/understanding-base32-and-base64-encoding-90e8ce5510f4",

"excerpts": [

"Implementing Base32 and Base64. While understanding these encodings is
fascinating, it's rarely necessary to implement them from scratch.",

"Base32 is more complex, encoding 5 bits of data per character. It's
commonly used for more readable and URL-friendly representations."

]

},

{

"title": "Lib .rs std",

"url": "https://lib.rs/std",

"excerpts": [

"Efficient and customizable data-encoding functions like base64, base32,
and hex ...",

"Lib .rs › Categories › Most popular Rust libraries",

"If Rust had a huge standard library, it would be like this. *
Categories",

"The list is curated to remove duplicate, deprecated, internal crates,
etc."

]

},

{

"title": "base32 crate documentation",

"url": "https://crates.io/crates/base32",

"excerpts": [

"use base32::Alphabet; // Crockford's Base32",

"system\n Browse All Crates |\nLog in with GitHub\nChange color scheme\n
* light\n * dark\n * system\n\nMenu * Browse All Crates\n * Log in with
GitHub\n\nbase32 v0.5.1\nBase32 encoder/decoder for Rust\n * # base32\n
* # decode\n * # encode\n * # no_std\n\n * Readme\n * 10 Versions\n *
Dependencies\n * Dependents\n\nbase32\nThis library lets you encode and
decode various Base32 variants. #[no_std] compatible but requires a
global allocator with the\nalloc crate. Usage",

"base32 v0.5.1",

"Base32 encoder/decoder for Rust",

"\nThis library lets you encode and decode various Base32 variants.
#[no_std] compatible but requires a global allocator with the\nalloc
crate. Usage\nuse base32::Alphabet; // Crockford's Base32 assert_eq!
(base32:: encode (Alphabet::Crockford, &[ 0xF8 , 0x3E , 0x0F , 0x83 ,
0xE0 ]), \"Z0Z0Z0Z0\" ); assert_eq! (base32:: decode
(Alphabet::Crockford, \"Z0Z0Z0Z0\" ). unwrap (), vec! [ 0xF8 , 0x3E ,
0x0F , 0x83 , 0xE0 ]); // RFC4648 assert_eq! (base32:: encode
(Alphabet::Rfc4648 { padding: true }, &[ 0xF8 , 0x3E , 0x7F , 0x83 ,
0xE7 ]), \"7A7H7A7H\" ); assert_eq! (base32:: decode (Alphabet::Rfc4648
{ padding: true }, \"7A7H7A7H\" ). unwrap (), vec! [ 0xF8 , 0x3E , 0x7F
, 0x83 , 0xE7 ]); // RFC4648 base32hex assert_eq! (base32:: encode
(Alphabet::Rfc4648Hex { padding: true }, &[ 0xF8 , 0x3E , 0x7F , 0x83 ,
0xE7 ]), \"V0V7V0V7\" ); assert_eq! (base32:: decode
(Alphabet::Rfc4648Hex { padding: true }, \"V0V7V0V7\" ). unwrap (), vec!
[ 0xF8 , 0x3E , 0x7F , 0x83 , 0xE7 ]); // z-base-32
assert_eq!\n(base32:: encode (Alphabet::Z, &[ 0xF8 , 0x3E , 0x7F , 0x83
, 0xE7 ]), \"9y989y98\" ); assert_eq! (base32:: decode (Alphabet::Z,
\"9y989y98\" ). unwrap (), vec! [ 0xF8 , 0x3E , 0x7F , 0x83 , 0xE7 ]);",

"License\nLicensed under either of\n * Apache License, Version 2.0, (
LICENSE-APACHE or http://www.apache.org/licenses/LICENSE-2.0 )\n * MIT
license ( LICENSE-MIT or http://opensource.org/licenses/MIT )\n\nat your
option. Contribution\nUnless you explicitly state otherwise, any
contribution intentionally\nsubmitted for inclusion in the work by you,
as defined in the Apache-2.0\nlicense, shall be dual licensed as above,
without any additional terms or\nconditions.
Metadata\npkg:cargo/base32@0.5.1 about 1 year ago MIT OR
Apache-2.0\n9.02 KiB\nInstall\nRun the following Cargo command in your
project directory:\ncargo add base32\nOr add the following line to your
Cargo.toml:\nbase32 = \"0.5.1\""

]

},

{

"title": "base16ct - Rust - Docs.rs",

"url": "https://docs.rs/base16ct",

"excerpts": [

"Pure Rust implementation of Base16 (RFC 4648, aka hex). Implements
lower and upper case Base16 variants without data-dependent branches or
lookup tables."

]

},

{

"title": "crockford - Rust - Docs.rs",

"url": "https://docs.rs/crockford",

"excerpts": [

"Missing: hex base16",

"This library is intended to provide an easy way to encode and decode
identifiers (large integers) as Crockford-encoded strings.",

"Use the encode function to encode `u64` values into Crockford
Base32-encoded strings.",

"This `encode_into` method also accepts `&mut String`, if you prefer.",

"Use the decode function to decode Crockford Base32-encoded strings.
This operation can fail;\nif it does, you’ll get a reasonably useful
error instead of a number."

]

},

{

"title": "RFC Errata Report » RFC Editor",

"url": "https://www.rfc-editor.org/errata/rfc4648",

"excerpts": [

"The input to a Base 64/-32/-16 encoding operation is sequence of
_octets_. However, the test vector expressions use sequences of
_characters_ to represent input ..."

]

},

{

"title": "Base32",

"url": "https://en.wikipedia.org/wiki/Base32",

"excerpts": [

"Base32 is an encoding method based on the base-32 numeral system. It
uses an alphabet of 32 digits, each of which represents a different
combination of 5 bits."

]

},

{

"title": "Base32 Crockford Encoder and Decoder",

"url": "https://github.com/dflydev/dflydev-base32-crockford",

"excerpts": [

"Base32 Crockford Encoder and Decoder. A Base32 Crockford implementation
for PHP. Example use Dflydev\\Base32\\Crockford\\Crockford;"

]

},

{

"title": "Crockford's Base32 | Baeldung on Computer Science",

"url": "https://www.baeldung.com/cs/crockfords-base32-encoding",

"excerpts": [

"Jul 4, 2024 — Base32 is an encoding and decoding scheme that uses an
alphabet consisting of 32 symbols. Therefore, each symbol in the
alphabet consists of 5 bits."

]

},

{

"title": "google-deepmind/chex",

"url": "https://github.com/google-deepmind/chex",

"excerpts": [

"Chex is a library of utilities for helping to write reliable JAX code.
This includes utils to help: Instrument your code (e.g. assertions,
warnings) ...See more"

]

},

{

"title": "Faster Base64 Encoding and Decoding using AVX2 ...",

"url": "https://lemire.me/en/publication/arxiv1704/",

"excerpts": [

"Faster Base64 Encoding and Decoding using AVX2 Instructions. Wojciech
Muła, Daniel Lemire. Abstract. Web developers use base64 formats to
include images, fonts ..."

]

},

{

"title": "stedonet/chex: elegant C/C++ functions to decode/encode hex
string ...",

"url": "https://github.com/stedonet/chex",

"excerpts": [

"A fast, trivial implementation to encode a nibble to a hex character
exists by indexing a 16-character look-up table."

]

},

{

"title": "Encoding binary as hex using SIMD instructions -
richardlupton.com",

"url": "https://richardlupton.com/posts/simd-hex/",

"excerpts": [

"The corresponding instruction is pshufb . _mm_shuffle_epi8(t, l)
essentially does a parallel set of table lookups using the lower nibbles
l ..."

]

},

{

"title": "KokaKiwi/rust-hex",

"url": "https://github.com/KokaKiwi/rust-hex",

"excerpts": [

"A basic crate to encode values to hexadecimal representation.
Originally extracted from rustc-serialize. crates.io/crates/hex.
License. Apache-2.0, MIT ...See more"

]

},

{

"title": "const-hex - crates.io: Rust Package Registry",

"url": "https://crates.io/crates/const-hex",

"excerpts": [

"May 15, 2025 — This crate provides a fast conversion of byte arrays to
hexadecimal strings, both at compile time, and at run time. It aims to
be a drop-in ...See more"

]

},

{

"title": "Crockford base32 encoding for large number - Java ...",

"url":
"https://stackoverflow.com/questions/22385467/crockford-base32-encoding-for-large-number-java-implementation",

"excerpts": [

"I'm looking for a Java implementation of Crockford Base32 that will
work with very large numbers. Here is an example of the types of numbers
I'm working with."

]

},

{

"title": "Hex encoding Rust crate (hex v0.4.3) - Crates.io",

"url": "https://crates.io/crates/hex",

"excerpts": [

"hex v0.4.3",

"Encoding and decoding data into/from hexadecimal representation.",

"No standard library",

"features",

"* std :\nEnabled by default. Add support for Rust's libstd types.",

"* serde :\nDisabled by default. Add support for\nserde de/serializing
library."

]

},

{

"title": "How is a CRC32 checksum calculated?",

"url":
"https://stackoverflow.com/questions/2587766/how-is-a-crc32-checksum-calculated",

"excerpts": [

"The polynomial for CRC32 is: x32 + x26 + x23 + x22 + x16 + x12 + x11 +
x10 + x8 + x7 + x5 + x4 + x2 + x + 1. Wikipedia · CRC calculation.See
more"

]

},

{

"title": "Computation of cyclic redundancy checks",

"url":
"https://en.wikipedia.org/wiki/Computation_of_cyclic_redundancy_checks",

"excerpts": [

"Computation of a cyclic redundancy check is derived from the
mathematics of polynomial division, modulo two."

]

},

{

"title": "CRC-32 - Rosetta Code",

"url": "https://rosettacode.org/wiki/CRC-32",

"excerpts": [

"Task. The result should be in accordance with ISO 3309, ITU-T V.42,
Gzip and PNG. Algorithms are described on Computation of CRC in
Wikipedia."

]

},

{

"title": "qemu/util/crc32c.c at master - GitHub",

"url": "https://github.com/qemu/qemu/blob/master/util/crc32c.c",

"excerpts": [

"This is the CRC-32C table. Generated with: width = 32 bits, poly =
0x1EDC6F41, reflect input bytes = true, reflect output bytes = true."

]

},

{

"title": "Use Boost to compute ECMA-128 64bit CRC",

"url":
"https://stackoverflow.com/questions/50765230/use-boost-to-compute-ecma-128-64bit-crc",

"excerpts": [

"I created the 64 bit hashes with the normal polynomial representation
of 0x42F0E1EBA9EA3693 for the ECMA-128 64bit crc. I get the following
...",

"I'm trying to compute a 64bit CRC as per the ECMA-128 standard. The
test data is \"123456789\" and I'm trying to match the same data
provided here."

]

},

{

"title": "crc32fast - Rust - Docs.rs",

"url": "https://docs.rs/crc32fast",

"excerpts": [

"This crate contains multiple CRC32 implementations: A fast baseline
implementation which processes up to 16 bytes per iteration; An
optimized implementation for ..."

]

},

{

"title": "crc-fast - crates.io: Rust Package Registry",

"url": "https://crates.io/crates/crc-fast",

"excerpts": [

"5 days ago — World's fastest generic CRC32 and CRC64 calculator using
SIMD. Supplies a C-compatible shared library for use in other
languages.",

"crc-fast = \"1.4.0\"",

"est/digest/trait.DynDigest.html)\ntrait for easier integration with
existing Rust code. Creates a `Digest` which can be updated over time,
for stream processing, intermittent workloads, etc, enabling\nfinalizing
the checksum once processing is complete.",

"Supports acceleration on\naarch64 ,\nx86_64 , and\nx86 architectures,
plus has a safe non-accelerated table-based\nsoftware fallback for
others.",

"Supplies a C-compatible shared library for use in other languages.",

"The crc crate is ~0.5GiB/s by default, so this is up to >220X faster .
This is unique, not just because of the performance, but also because I
couldn't find a single generic SIMD-accelerated\nimplementation (in any
language) which worked for all known variants, using the Rocksoft model
, especially the \"non-reflected\" variants.",

"Build & Install",

"cargo build will obviously build the library, including\nthe
C-compatible shared library ."

]

},

{

"title": "crc - Rust",

"url": "https://docs.rs/crc",

"excerpts": [

"The `crc` crate is a Rust implementation of CRC, using well-known or
custom algorithms. It includes structs like `Algorithm`, `Crc`, and
`Digest`."

]

},

{

"title": "crc-any - crates.io: Rust Package Registry",

"url": "https://crates.io/crates/crc-any",

"excerpts": [

"May 1, 2024 — To compute CRC values by providing the length of bits,
expression, reflection, an initial value and a final xor value. It has
many built-in CRC ..."

]

},

{

"title": "lordmulder/CRC-64: Cross-platform command-line tool ...",

"url": "https://github.com/lordmulder/CRC-64",

"excerpts": [

"Simple cross-platform command-line tool for computing CRC-64 (ECMA-182)
checksums. ... The generator polynomial use for CRC-64 computations is:
0x42F0E1EBA9EA3693 ..."

]

},

{

"title": "Who invented the slicing-by-N CRC32 algorithm?",

"url": "https://toroid.org/crc32-slicing-by-N-paper",

"excerpts": [

"Jan 20, 2017 — So using this Slicing by-8 algorithm, it can read 64
bits at a time and it triples the performance of existing implementation
of Sarwate ..."

]

},

{

"title": "CRC-32C (Castagnoli) for C++ and .NET",

"url": "https://crc32c.machinezoo.com/",

"excerpts": [

"This is a hardware-accelerated implementation of CRC-32C (Castagnoli,
polynomial 0x1EDC6F41 / 0x82F63B78) for Windows (C++ and .NET),
opensourced under zlib ..."

]

},

{

"title": "CRC-32 - Just Solve the File Format Problem",

"url": "http://justsolve.archiveteam.org/wiki/CRC-32",

"excerpts": [

"CRC-32 is a family of 32-bit hash functions used to detect accidental
data corruption. The term CRC-32 by itself usually means the
CRC-32/ISO-HDLC (IEEE) ..."

]

},

{

"title": "Fast CRC algorithm?",

"url":
"https://stackoverflow.com/questions/27939882/fast-crc-algorithm",

"excerpts": [

"... (crc & 1))); is ~33% faster when compiled for x86 with
GCC/ICC/CLANG (104 MB/s vs. 134 MB/s). On the same system the slice-8 is
2040 MB/s and ..."

]

},

{

"title": "Full text of \"A PAINLESS GUIDE TO CRC ERROR ...",

"url": "https://archive.org/stream/PainlessCRC/crc_v3.txt",

"excerpts": [

"This document explains CRCs (Cyclic Redundancy Codes) and their
table-driven implementations in full, precise detail.See more"

]

},

{

"title": "Revisiting Fletcher and Adler Checksums",

"url": "https://zlib.net/maxino06_fletcher-adler.pdf",

"excerpts": [

"by T Maxino · Cited by 18 — This paper examines two of the most
commonly used checksum approaches, the Fletcher checksum and the Adler
checksum, and evaluates their comparative error ..."

]

},

{

"title": "crc32fast - Rust Package Registry - Crates.io",

"url": "https://crates.io/crates/crc32fast/1.0.3/dependencies",

"excerpts": [

"A port of the libtest (unstable Rust) benchmark runner to Rust stable
releases. Supports running benchmarks and filtering based on the name."

]

},

{

"title": "How crc32() increased the performance of my database queries
200x",

"url":
"https://www.reddit.com/r/laravel/comments/16jbqdu/how_crc32_increased_the_performance_of_my/",

"excerpts": [

"On the local machine and environment, everything was flawless, but in
production, this query was slower every day. It was related to the
number ..."

]

},

{

"title": "Adler-32",

"url": "https://en.wikipedia.org/wiki/Adler-32",

"excerpts": [

"Adler-32 is a checksum algorithm written by Mark Adler in 1995,
modifying Fletcher's checksum. Compared to a cyclic redundancy check of
the same length, ..."

]

},

{

"title": "How reliable is the adler32 checksum?",

"url":
"https://stackoverflow.com/questions/6043708/how-reliable-is-the-adler32-checksum",

"excerpts": [

"Adler32 is a checksum. MD5 is a secure message digest. Adler32 is for
quick hashes, has a small bit space, and simple algorithm. Its collision
rate is low."

]

},

{

"title": "Wikipedia: Cyclic redundancy check",

"url": "https://en.wikipedia.org/wiki/Cyclic_redundancy_check",

"excerpts": [

"* Name: 0x04C11DB7",

"* Name: 0xEDB88320",

"* Name: 0xDB710641",

"A cyclic redundancy check (CRC) is an error-detecting code commonly
used in digital networks and storage devices to detect accidental
changes to digital data.",

"The most commonly used polynomial lengths are 9 bits (CRC-8), 17 bits
(CRC-16), 33 bits (CRC-32), and 65 bits (CRC-64).",

"* Name: CRC-32",

"* Name: ISO 3309 ( HDLC ), ANSI X3.66 ( ADCCP ), FIPS PUB 71,
FED-STD-1003, ITU-T V.42 , ISO/IEC/IEEE 802-3 ( Ethernet ), ISO/IEC/IEEE
802-11 ( Wi-Fi ), SATA , NVMe , [ 52 ] MPEG-2 , PKZIP , Gzip , Bzip2 ,
PCI Express , HDMI , POSIX cksum , [ 53 ] PNG , [ 54 ] ZMODEM , many
others",

"* Name: 0x82608EDB [ 14 ]",

"* Name: odd",

"CRCs are popular because they are simple to implement in binary
hardware , easy to analyze mathematically, and particularly good at
detecting common errors caused by noise in transmission channels."

]

},

{

"title": "CRC-32 Generation (IEEE 802.3)",

"url":
"https://www.intel.com/content/www/us/en/docs/programmable/813669/24-1-4-0-0/crc-32-generation.html",

"excerpts": [

"The following equation shows the CRC polynomial, as specified in the
IEEE 802.3 standard:\n\nFCS(X) = X 32 +X 26 +X 23 +X 22 +X 16 +X 12 +X
11 +X 10 +X 8 +X 7 +X 5 +X 4 +X 2 +X 1 +",

"The 32-bit CRC value occupies the FCS field with `X`31 in the least
significant bit of the first byte. The CRC bits are thus transmitted in
the following order: `X`31, `X`30, ..., `X`1, `X`0."

]

},

{

"title": "Exhaustive Search for 32-bit CRC Polynomials and Tableless CRC
Concepts (Koopman & colleagues)",

"url":
"https://users.ece.cmu.edu/~koopman/networks/dsn02/dsn02_koopman.pdf",

"excerpts": [

"The IEEE 802.3 standard adopts the CRC polynomial:
x32+x26+x23+x22+x16+x12+x11+x10+x8+x7+x5+x4+x2+x+1",

"
The leading “8” of this number corresponds to the top four\n(x32 through x29) polynomial coefficients, with lower order\nbits corresponding to lower order coefficients, down to the\ntrailing",

"B,” which refers to the terms (x4+x2+x).\n "

]

},

{

"title": "Chorba: A novel CRC32 implementation",

"url": "https://arxiv.org/html/2412.16398v1",

"excerpts": [

"This paper describes a novel method for efficiently calculating CRC
checksums without lookup tables or hardware support for polynomial
multiplication.",

"The folding approach [ 4 ] extends this by taking the CRC32 of large
single-term polynomials and making a similar substitution, however
instead of shifting by a single bit at a time, we are able to shift by
an arbitrary length.",

"CRC32 checksums can be efficiently calculated in software without
needing to rely on lookup tables.",

"zero polynomials",

"braiding",

"folding",

"By using larger zero polynomials we can take advantage of the speed
improvements of 8-bit and 64-bit arithmetic and memory accesses.",

"The algorithms in the figures are as follows:"

]

},

{

"title": "Stephan Brumme CRC32 - Tableless CRC32 Implementations",

"url": "https://create.stephan-brumme.com/crc32/",

"excerpts": [

"`const uint32_t Polynomial = 0xEDB88320;`",

"The lower latency of these two binary operations is the reason why the
improved branch-free algorithm is the fastest (about 70 MByte/s) for
bit- ...",

"Performance is more than doubled in comparison to the popular Sarwate
algorithm (840 or 1050 MByte/s instead of 375 MByte/s) at the cost of a
4k ...",

"**Tableless Full-Byte Algorithm (based on book \"Hacker's Delight\" by
Henry S. Warren)**"

]

},

{

"title": "crc crate - crates.io",

"url": "https://crates.io/crates/crc",

"excerpts": [

"NoTable` doesn't use a lookup table, and thus minimizes binary size and
memory usage",

"This crate has several pluggable implementations:\n\n1. `NoTable`
doesn't use a lookup table, and thus minimizes binary size and memory
usage. 2. `Table<1>` uses a lookup table with 256 entries (e.g. for u32
thats 256 \\* 4 bytes). 3. `Table<16>` uses a lookup table with 16 \\*
256 entries (e.g. for u32 thats 16 \\* 256 \\* 4 bytes). `Table<1>` is
the default implementation, but this can be overridden by specifying `I`
in `Crc<W, I>`. E.g. : `Crc<u32, NoTable>`, `Crc<u64, Table<16>>`",

" entries (e.g. for u32 thats 16 * 256 * 4 bytes). Table<1> is the
default implementation, but this can be overridden by specifying\nI
in\nCrc<W, I> . E.g. :\nCrc<u32, NoTable> ,\nCrc<u64, Table<16>> , ...
NOTE: Lookup tables will increase binary size if they're generated at
compile-time. Wrapping\nCrc initialization in a\nstd::cell::OnceCell may
be preferable if binary size is a concern.",

"13.6 KiB",

")\n\nThis crate's MSRV is 1.65. At a minimum, the MSRV will be <= the
oldest stable release in the last 12 months."

]

},

{

"title": "Catalogue of parametrised CRC algorithms with 16 bits",

"url": "https://reveng.sourceforge.io/crc-catalogue/16.htm",

"excerpts": [

"I Definition: Width, Poly, Init, XorOut (Section 7.2.1, p.40); I
Definition: RefIn, RefOut (Section 6.1.1, p.20; Section 7.2.1.1, p.40).
PVL Team (25 October ..."

]

},

{

"title": "Specification of CRC Routines",

"url":
"https://www.autosar.org/fileadmin/standards/R22-11/CP/AUTOSAR_SWS_CRCLibrary.pdf",

"excerpts": [

"This section gives a rough overview on the standard parameters that are
commonly used for 8-bit, 16-bit and 32-bit CRC calculation. • CRC result
width: Defines ..."

]

},

{

"title": "CRC Checksum",

"url":
"https://sensirion.com/media/documents/1E3CD1FF/6165AFE4/Sensirion_GF_AN_SFM-04_CRC_Checksum_D1.pdf",

"excerpts": [

"CRC (Cyclic Redundancy Check) is an error detection scheme used by the
sensor after every 16-bit data transmission, calculated over both data
bytes."

]

},

{

"title": "hardware instruction based crc32c, a better alternative to the
tcp",

"url":
"https://oaktrust.library.tamu.edu/bitstream/handle/1969.1/186558/SAHU-THESIS-2019.pdf?sequence=1",

"excerpts": [

"In each of these algorithms, we have used CRC32C (Castagnoli
Polynomial. 0x1EDC6F41) and the “reflected bit order” for both the input
and the resultant CRC.",

"Intel's CRC32 and PCLMULQDQ instructions and ARM's CRC32C instruction
were also used as part of testing hardware instruction implementations.
A comparative."

]

},

{

"title": "hash - CRC32 vs CRC32C?",

"url": "https://stackoverflow.com/questions/26429360/crc32-vs-crc32c",

"excerpts": [

"CRC32C uses a different polynomial (0x1EDC6F41, reversed 0x82F63B78)
but otherwise the computation is the same. The results are different,
naturally."

]

},

{

"title": "Fast CRC Computation for Generic Polynomials Using ...",

"url": "https://kib.kiev.ua/x86docs/Intel/WhitePapers/323102-XXX.pdf",

"excerpts": [

"by W Feghali · 2009 — This method enables good performance on a range
of IA cores that will support the PCLMULQDQ instruction. Using
PCLMULQDQ, we can compute CRC for any polynomial ..."

]

},

{

"title": "[Implemented] Faster CRC32 method for SFV computation.",

"url": "https://www.ghisler.ch/board/viewtopic.php?t=84116",

"excerpts": [

"But every method based on Intel Slicing-by-8 gives ~ 1000 Mbyte/s. Any
Slicing-by-N method with Stephan Brumme's optimizations is available
here ..."

]

},

{

"title": "I do not understand some details in sections 9 and 10 of \"A
Painless ...",

"url":
"https://stackoverflow.com/questions/71940245/i-do-not-understand-some-details-in-sections-9-and-10-of-a-painless-guide-to-cr",

"excerpts": [

"I do not understand some details in sections 9 and 10 of \"A Painless
Guide to CRC Error detection algorithms\" The guide mentioned in the
title ..."

]

},

{

"title": "[PDF] a painless guide to crc error detection algorithms",

"url":
"https://ceng2.ktu.edu.tr/~cevhers/ders_materyal/bil311_bilgisayar_mimarisi/supplementary_docs/crc_algorithms.pdf",

"excerpts": [

"CRC error detection uses a checksum, a function of the message, to help
receivers determine if a message has been corrupted during
transmission."

]

},

{

"title": "Fast Software-based Table-less Algorithm for CRC ...",

"url": "https://ieeexplore.ieee.org/iel7/8703706/8712851/08713103.pdf",

"excerpts": [

"This algorithm is successfully applied to Ethernets CRC-32 calculation.
A software-based CRC algorithm is proposed in this paper, which improves
the performance ..."

]

},

{

"title": "Fast CRC32 implementations - corsix ...",

"url": "https://github.com/corsix/fast-crc32",

"excerpts": [

"Contains benchmarking apparatus for CRC32 implementations, along with a
range of benchmark results. ... pclmulqdq on x86_64 or pmull on aarch64.
Three-way ..."

]

},

{

"title": "crc64fast - crates.io: Rust Package Registry",

"url": "https://crates.io/crates/crc64fast/1.0.0/dependencies",

"excerpts": [

"Statistics-driven micro-benchmarking library. ^0.9. ^0.9 proptest.
Hypothesis-like property-based testing and shrinking. ^0.7. ^0.7 rand.
Random number ..."

]

},

{

"title": "calculating a CRC like ARM Cortex cores. Could this be a crate
...",

"url":
"https://www.reddit.com/r/rust/comments/cgg23v/looking_for_feedback_on_calculating_a_crc_like/",

"excerpts": [

"Looking for feedback on: calculating a CRC like ARM Cortex cores. Could
this be a crate eventually?"

]

},

{

"title": "Why is this CRC32 implementation in C# so slow?",

"url":
"https://stackoverflow.com/questions/945641/why-is-this-crc32-implementation-in-c-sharp-so-slow",

"excerpts": [

"I have run some benchmarks comparing this to the
MD5CryptoServiceProvider and SHA1CryptoServiceProvider ComputeHash
functions and they are much faster."

]

},

{

"title": "Python binascii.crc32 seems not working properly",

"url":
"https://stackoverflow.com/questions/32960363/python-binascii-crc32-seems-not-working-properly",

"excerpts": [

"I am trying to CRC16/32 checksum with binascii.crc32 ,
binacsii.crc_hqx. This is the values I used as an example."

]

},

{

"title": "My weekend project: a SIMD CRC algorithm generator : r/rust -
Reddit",

"url":
"https://www.reddit.com/r/rust/comments/1g82uqt/my_weekend_project_a_simd_crc_algorithm_generator/",

"excerpts": [

"It consists of a proc-macro for code generation, and some boilerplate
template/script to generate new CRC crates based on the CRC parameters."

]

},

{

"title": "CRC-32/CRC-32C Specification (zlib CRC v3)",

"url": "https://zlib.net/crc_v3.txt",

"excerpts": [

"Name : \"CRC-32\"\nWidth : 32\nPoly : 04C11DB7\nInit : FFFFFFFF\nRefIn
: True\nRefOut : True\nXorOut : FFFFFFFF\nCheck : CBF43926"

]

},

{

"title": "CRC32 Rust tableless microcrate research cue (CRC32/CRC64)",

"url": "https://github.com/stbrumme/crc32",

"excerpts": [

"This is a mirror of my CRC32 library hosted at
https://create.stephan-brumme.com/crc32/.",

"Fast CRC32",

"Fast
CRC32\n\n[create.stephan-brumme.com/crc32/](https://create.stephan-brumme.com/crc32/
\"https://create.stephan-brumme.com/crc32/\")",

"\n\n### Topics\n\n[crc32](/topics/crc32 \"Topic: crc32\")\n\n### ",

"Algorithms:\n\n* bitwise\n* branch-free bitwise\n* half-byte\n*
tableless full-byte\n* Sarwate's original algorithm\n* slicing-by-4\n*
slicing-by-8\n* slicing-by-16\n* crc32\\_combine() \"merges\" two
indepedently computed CRC32 values which is the basis for even faster
multi-threaded calculation",

"See my website <https://create.stephan-brumme.com/crc32/> for
documentation, code examples and a benchmark."

]

},

{

"title": "crc64fast crate page",

"url": "https://crates.io/crates/crc64fast",

"excerpts": [

"crc64fast` provides two fast implementations, and the most performance
one will\nbe chosen based on CPU feature at runtime. * a fast,
platform-agnostic table-based implementation, processing 16 bytes at a
time. * a SIMD-carryless-multiplication based implementation on modern
processors",

"/docs.rs/crc64fast)\n\nSIMD-accelerated CRC-64/XZ (a.k.a.
CRC-64/GO-ECMA) computation\n(similar to
[`crc32fast`](https://crates.io/crates/crc32fast))."

]

},

{

"title": "rust-crc32fast README",

"url": "https://github.com/srijs/rust-crc32fast",

"excerpts": [

"* A fast baseline implementation which processes up to 16 bytes per
iteration",

"* An optimized implementation for modern `x86` using `sse` and
`pclmulqdq` instructions",

"* An optimized implementation for `aarch64` using `crc32`
instructions",

"Calling the `Hasher::new` constructor at runtime will perform a feature
detection to select the most",

"optimal implementation for the current CPU feature set.",

"crc32fast (this crate) | 1.0.0 | baseline | 683 | 1499",

"crc32fast (this crate) | 1.0.0 | pclmulqdq | 140 | 7314",

"performance",

"-----------",

"This crate contains multiple CRC32 implementations:",

"This crate contains multiple CRC32 implementations:"

]

},

{

"title": "CRC32 Rust Crate Landscape (crc32fast/crc crates overview)",

"url": "https://crates.io/crates/crc32fast",

"excerpts": [

"This crate contains multiple CRC32 implementations:"

]

},

{

"title": "CRC32.java",

"url": "https://introcs.cs.princeton.edu/java/61data/CRC32.java.html",

"excerpts": [

"Aug 11, 2022 — java CRC32 123456789 * CRC32 (via table lookup) =
cbf43926 * CRC32 (via direct calculation) = cbf43926 * CRC32 (via Java's
library) = cbf43926 ..."

]

},

{

"title": "CRC calculation — crcmod v1.7 documentation",

"url": "https://crcmod.sourceforge.net/crcmod.html",

"excerpts": [

"... crc32_func('123456789')) '0xcbf43926L'. The CRC-32 uses a
“reversed” algorithm, used for many common CRC algorithms. Less common
is the non-reversed ..."

]

},

{

"title": "CRC-32c Algorithm checking D'oh",

"url": "https://pdl.cmu.edu/mailinglists/ips/mail/msg05120.html",

"excerpts": [

"Here is the results with a test pattern of \"123456789\". Table CRC
results: Normalized =C14960C7 Reflected =E3069283 Table CRC check:
Normalized =FFFFFFFF ..."

]

},

{

"title": "RE: iSCSI: Nailing down CRC-32C",

"url": "https://www.pdl.cmu.edu/mailinglists/ips/mail/msg04686.html",

"excerpts": [

"Sep 4, 2001 — Based on the finalization of the parameters of CRC-32C
per following parameters, I obtained a check of 0xE3069283 for the
nine-byte string of \"123456789\" (9 ..."

]

},

{

"title": "CRC32C - Arm A-profile A32/T32 Instruction Set Architecture",

"url":
"https://developer.arm.com/documentation/ddi0597/latest/Base-Instructions/CRC32C--CRC32C-",

"excerpts": [

"To align with common usage, the bit order of the values is reversed as
part of the operation, and the polynomial 0x1EDC6F41 is used for the CRC
calculation."

]

},

{

"title": "crc32.c - MIT",

"url": "https://web.mit.edu/freebsd/head/sys/libkern/crc32.c",

"excerpts": [

"... CRC lookup table was generated automagically using the * following
model parameters: * * Generator Polynomial = .................
0x1EDC6F41 * Generator ..."

]

},

{

"title": "Intel® Carry-Less Multiplication Instruction and its Usage
...",

"url":
"https://cdrdv2-public.intel.com/836172/clmul-wp-rev-2-02-2014-04-20.pdf",

"excerpts": [

"by S Gueron · 2014 · Cited by 94 — The carry-less multiplication
instruction PCLMULQDQ can speedup the computation of CRC with
polynomials other than the iSCSI polynomial, for ..."

]

},

{

"title": "rawrunprotected/crc: A fast implementation of the ECMA ...",

"url": "https://github.com/rawrunprotected/crc",

"excerpts": [

"A fast implementation of the ECMA-182 CRC64 checksum using the CLMUL
instruction set, implementing the algorithm described in"

]

},

{

"title": "awesomized/crc64fast-nvme: SIMD accelerated carryless- ...",

"url": "https://github.com/awesomized/crc64fast-nvme",

"excerpts": [

"crc64fast-nvme provides two fast implementations, and the most
performance one will be chosen based on CPU feature at runtime. a fast,
platform-agnostic table- ..."

]

},

{

"title": "awesomized/crc-fast-rust",

"url": "https://github.com/awesomized/crc-fast-rust",

"excerpts": [

"The crc crate is ~0.5GiB/s by default, so this is up to >220X faster.
This is unique, not just because of the performance, but also because I
couldn't find a ..."

]

},

{

"title": "crc - Keywords - crates.io: Rust Package Registry",

"url": "https://crates.io/keywords/crc",

"excerpts": [

"To compute CRC values by providing the length of bits, expression,
reflection, an initial value and a final xor value. It has many built-in
CRC functions."

]

},

{

"title": "awesomized/crc32fast-lib-rust",

"url": "https://github.com/awesomized/crc32fast-lib-rust",

"excerpts": [

"Fast, SIMD-accelerated CRC-32/ISO-HDLC (aka crc32 ) checksum
computation in Rust exposed as a C-compatible shared library. Results in
a dramatic performance ..."

]

},

{

"title": "Algorithm in crc - Rust",

"url": "https://docs.rs/crc/latest/crc/struct.Algorithm.html",

"excerpts": [

"This struct describes a CRC algorithm using the fields specified by the
Catalogue of parametrised CRC algorithms."

]

},

{

"title": "[PDF] Random sampling with a reservoir",

"url":
"https://www.semanticscholar.org/paper/Random-sampling-with-a-reservoir-Vitter/da01f7fcc5c7eeba75bc09a41fdd946e65210090",

"excerpts": [

"Faster methods for random sampling · J. Vitter. Computer Science,
Mathematics · 1984 ; Optimum algorithms for two random sampling problems
· J. Vitter. Computer ..."

]

},

{

"title": "Reservoir Sampling | Richard Startin's Blog",

"url": "https://richardstartin.github.io/posts/reservoir-sampling",

"excerpts": [

"This section includes three algorithms: R, X, and Z, written about in
Random Sampling with a Reservoir. Algorithm R is a computationally ...",

"Jan 17, 2020 — Algorithm R is a computationally inefficient, but widely
used, algorithm which generates as many random variables as there are
inputs.",

"Jan 17, 2020 — Algorithm Z. Algorithm Z is reported as the fastest
algorithm in Random Sampling with a Reservoir. It is analogous to
Algorithm D; skips are ..."

]

},

{

"title": "reservoir - Rust",

"url": "https://docs.rs/reservoir",

"excerpts": [

"Reservoir sampling: collect a random sample of a known maximum size
from an iterator of unknown length. Implements Jeffrey Vitter's
Algorithm R (see ...",

"Implements Jeffrey Vitter’s Algorithm R
(see\nhttps://en.wikipedia.org/wiki/Reservoir\\_sampling",

"[sample](fn.sample.html \"fn reservoir::sample\")"

]

},

{

"title": "Reservoir Sampling - GeeksforGeeks",

"url": "https://www.geeksforgeeks.org/dsa/reservoir-sampling/",

"excerpts": [

"Jul 23, 2025 — Reservoir sampling is a family of randomized algorithms
for randomly choosing k samples from a list of n items, where n is
either a very large or unknown ..."

]

},

{

"title": "Vitter 1985: Random Sampling with a Reservoir",

"url": "https://www.cs.umd.edu/~samir/498/vitter.pdf",

"excerpts": [

"The limiting restrictions on algorithms for this sampling problem are
that the\nrecords must be read sequentially and at most once. This means
that any\nalgorithm for this problem must maintain a reservoir that
contains a random\nsample of size n of the records processed so far.
This gives us the following\ngeneralization. THEOREM 1. Every
algorithm\t\t\t\t\t\t for this sampling\t\t problem is a type of
reservoir\nalgorithm.",

"Definition 1. The first step of any reservoir algorithm is to put the
first n\nrecords of the file into a “reservoir.” The rest of the records
are processed\nsequentially; records can be selected for the reservoir
only as they are processed.",

"We introduce fast algorithms for selecting a random sample of n records
without replacement from\na pool of N records, where the value of N is
unknown beforehand. The main result of the paper is\nthe design and
analysis of Algorithm Z; it does the sampling in one pass using constant
space and in\nO(n(1 + log(N/n)))\texpected time, which is optimum, up to
a constant factor. Several optimizations\nare studied that collectively
improve the speed of the naive version of the algorithm by an order
of\nmagnitude. We give an efficient Pascal-like implementation\t that
incorporates these modifications\nand that is suitable for general use.
Theoretical and empirical results indicate that Algorithm Z\noutperforms
current methods by a significant margin.",

"The framework we use in this paper to develop reservoir algorithms
faster than\nAlgorithm R revolves around the following random variate:",

"The random variable 9(n, t) is defined to be the number of\nrecords in
the file that are skipped over before the next record is chosen for
the\nreservoir, where n is the size of the sample and where t is the
number of records\nprocessed so far.",

"The CPU times (in microseconds) of optimized FORTRAN 77
implementations\n of Algorithms R, X, and Z on a VAX 11/780 computer are
roughly 16ON, 4ON,\n and 950n In (N/n) - 1250n, respectivel",

"3. OUR FRAMEWORK\t\t\t\t\t\t FOR RESERVOIR\t\t\t\tALGORITHMS"

]

},

{

"title": "Reservoir sampling - ACM TOMS (1985) / Related References",

"url": "https://dl.acm.org/doi/10.1145/3147.3165",

"excerpts": [

"Random sampling with a reservoir",

"We introduce fast algorithms for selecting a random sample of n records
without replacement from a pool of N records, where the value of N is
unknown beforehand. The main result of the paper is the design and
analysis of Algorithm Z; it does the sampling in one pass using constant
space and in O ( n (1 + log( N/n ))) expected time, which is optimum, up
to a constant factor.",

"VITTER, J.S. Optimum algorithms for two random sampling problems. In
Proceedings of the 24th Annual IEEE Symposium on Foundations of Computer
Science (Tucson, Az., Nov. 7-9), IEEE, New York, 1983 pp. 65-75.",

"We introduce fast algorithms for selecting a random sample of n records
without replacement from a pool of N records, where the value of N is
unknown ... Do not sell or share my personal information",

"Editor : John R. Rice Author : Jeffrey S. Vitter Authors Info &
Claims",

"Pages 37 - 57",

"https://doi.org/10.1145/3147.3165",

"Published : 01 March 1985",

"Publication History",

"1,273 citation 9,321 Downloads",

"Recommendations"

]

},

{

"title": "Vitter Reservoir Sampling Core Concepts",

"url": "http://www.ittc.ku.edu/~jsv/Papers/Vit84.sampling.pdf",

"excerpts": [

"Random sampling with a reservoir."

]

},

{

"title": "Reservoir Sampling Rust Crate - reservoir-sampling",

"url": "https://crates.io/crates/reservoir-sampling",

"excerpts": [

"\nreservoir-sampling\n==================\n\nCrate implementing
reservoir sampling, a method for getting random samples\nfrom a source
in a single pass. Useful in situations where size of source is\nunknown
or very large.",

"All algorithms implemented here have been taken from this article only.
(This crate supports WASM)",

"(This crate supports WASM)",

"reservoir-sampling v0.5.1\nImplementations of a variety of algorithms
for reservoir sampling in Rust. * # rng\n * # random\n * # streaming\n\n
* Readme\n * 13 Versions\n * Dependencies\n *
Dependents\n\nreservoir-sampling\nCrate implementing reservoir sampling,
a method for getting random samples\nfrom a source in a single pass.
Useful in situations where size of source is\nunknown or very large.
Read this article for more information:
https://en.wikipedia.org/wiki/Reservoir_sampling\nAll algorithms
implemented here have been taken from this article only. (This crate
supports WASM)\nQuickstart\nuse reservoir_sampling::unweighted::l; fn
main () { let mut sampled_arr = vec! [ 0usize ; 10 ]; l ( 0usize .. 100
, sampled_arr. as_mut_slice ()); println! ( \"Sampled array: {:?}\" ,
sampled_arr);\n}\nAPI Design\nFunctions take:\n * An\nIterator over
generic type\nT , with no constraints which serves as a stream of data
to sample. * Mutable array slice (\n&mut [T] ) to store sampled
data\n\nBy default, functions use\nrand::thread_rng to provide RNG. To
use your own RNG which implements\nrand::RNG , use functions
in\nreservoir_sampling::core . Future development:\nStabilize\nweighted
and implement more
algorithms.\nMetadata\npkg:cargo/reservoir-sampling@0.5.1 over 4 years
ago 2018 edition Unlicense\n7.62 KiB\nInstall\nRun the following Cargo
command in your project directory:\ncargo add reservoir-sampling\nOr add
the following line to your Cargo.toml:\nreservoir-sampling =
\"0.5.1\"\nDocumentation\ndocs.rs/reservoir-sampling/0.5.1\nRepository\ngithub.com/DesmondWillowbrook/rs-reservoir-sampling\nOwners\n
* Kartavya Vashishtha\n\nCategories\n * Algorithms\n\nReport
crate\nStats Overview\n17,992 Downloads all time\n13 Versions
published\nDownloads over the last 90 days\nDisplay as\nStacked *
Stacke",

"By default, functions use `rand::thread_rng` to provide RNG. To use
your own RNG which implements `rand::RNG`, use functions in
`reservoir_sampling::core`.",

"reservoir-sampling - crates.io: Rust Package Registry",

" * # random",

" * # streaming",

"API Design",

"Functions take:",

"An\nIterator over generic type\nT , with no constraints which serves as
a stream of data to sample.",

"Mutable array slice (\n&mut [T] ) to store sampled data",

"Future development:",

"Stabilize\nweighted and implement more algorithms."

]

},

{

"title": "Reservoir Sampling Crate - reservoir-sampling (crates.io)",

"url": "https://crates.io/crates/reservoir-sampling/dependencies",

"excerpts": [

"reservoir-sampling v0.5.1. Implementations of a variety of algorithms
for reservoir sampling in Rust. #rng · #random · #streaming.
crates.io\nThe Rust comm",

"Implementations of a variety of algorithms for reservoir sampling in
Rust.",

"\nThe Rust community’s crate registry",

"reservoir-sampling v0.5.1",

"Dependencies",

"2\n^0.2 getrandom 1 extra feature A small cross-platform library for
retrieving random data from system source",

"\n * ^0.8",

"Random number generators and other randomness functionality.",

"\n^0.2 wasm-bindgen\n",

"Easy support for interacting between JS and Rust."

]

},

{

"title": "Reservoir_sampling",

"url": "https://en.wikipedia.org/wiki/Reservoir_sampling",

"excerpts": [

"Reservoir sampling is a family of randomized algorithms for choosing a
simple random sample, without replacement, of k items from a population
of unknown size n in a single pass over the items . [simple random
sample](/wiki/Simple_random_sample \"Simple random sample\"), without
replacement, of k items from a population of unknown size n in a single
pass over the items.",

"Reservoir sampling is a family of randomized algorithms for choosing a
simple random sample, without replacement, of k items from a population
of unknown size n in a single pass over the items . The size of the
population n is not known to the algorithm and is typically too large
for all n items to fit into main memory.",

"Optimal: Algorithm L",

"\n\nThis algorithm computes three random numbers for each item that
becomes part of the reservoir, and does not spend any time on items that
do not. Its expected running time is thus
\n\n\n\nO\n(\nk\n(\n1\n+\nlog",

"Simple: Algorithm R [ edit ]"

]

},

{

"title": "Reservoir Sampling in Practice",

"url":
"https://www.numberanalytics.com/blog/reservoir-sampling-in-practice",

"excerpts": [

"Reservoir Sampling is particularly useful when dealing with large
datasets or data streams where it is impractical or impossible to store
the entire dataset in memory.",

"The algorithm allows for the selection of a representative sample of a
fixed size, $k$, from a dataset of size $n$, where $n$ is either very
large or unknown.",

"ing algorithm works by maintaining a \"reservoir\" of size $k$.",

"As the algorithm processes the data stream, it fills the reservoir with
the first $k$ elements. For each subsequent element, it generates a
random index between 1 and the current element's position. If the
generated index is less than $k$, it replaces the element at that index
in the reservoir with the current element.",

"ur Use Case\n\nThere are several variants of the Reservoir Sampling
algorithm, each with its strengths and weaknesses. The choice of variant
depends on the specific use case and requirements."

]

},

{

"title": "Reservoir Sampling in Practice (Medium)",

"url":
"https://medium.com/pythoneers/dipping-into-data-streams-the-magic-of-reservoir-sampling-762f41b78781",

"excerpts": [

"It's a nifty little trick that allows us to randomly sample elements
from a stream of data, without needing to know the size of the stream in
advance. The beauty of this algorithm is its simplicity and efficiency .
You can sample from massive datasets without breaking a sweat. The Math
Behind It",

"The core idea is to ensure that each element has an equal probability
of being included in the sample.",

"Initialization: Start by selecting the first\nk elements from the
stream and placing them in your \"reservoir.\" This is like grabbing the
first\nk pebbles you see. * Replacement: For every subsequent element
(let’s call it the\ni-th element, where\ni > k ), decide whether to
include it in the reservoir. The probability of including the\ni-th
element in the reservoir is\nk/i . If you decide to include it, randomly
replace one of the current elements in the reservoir. The
Equation\nHere’s the key equation that drives the algorithm:\nThe key
equation that drives the sampling algorithm\nLet’s dissect this a bit:\n
* k is the size of the reservoir, or how many samples you want to keep.
* i is the current element’s index in the stream. What this equation
says is that as the stream progresses, each element has a smaller chance
of being included in the reservoir. But, thanks to the way the algorithm
works, every element up to the current point has had an equal chance of
being selected. Let’s Implement This in Python\nNow, let’s put this into
action with some Python code. I love how straightforward this algorithm
is to implement.\nimport random\ndef reservoir_sampling(stream, k):\n#
Step 1: Fill the reservoir with the first k elements\nreservoir =
[]\nfor i, element in enumerate(stream):\nif i <
k:\nreservoir.append(element)\nelse:\n# Step 2: Replace elements with
gradually decreasing probability\nj = random.randint(0, i)\nif j <
k:\nreservoir[j] = element\nreturn reservoir\nstream = range(1, 1001) #
A stream of numbers from 1 to 1000\nk = 10\nsample =
reservoir_sampling(stream, k)\nprint(\"Random sample from stream:\",
sample)\nThis code does exactly what we discussed: it maintains a
reservoir of size\nk and fills it with a random sample from the stream.
Let’s visualize how this algorithm works. Imagine the following
scenario:\n * You start with an empty reservoir. * You encounter a
stream of elements, one by one. * With each new element, you either add
it to your re"

]

},

{

"title": "reservoir_sampling - Rust - Docs.rs",

"url": "https://docs.rs/reservoir-sampling",

"excerpts": [

"Provides weighted reservoir sampling, i.e. the odds of a particular
item occurring in the sampling can be influenced."

]

},

{

"title": "streaming_algorithms - Rust",

"url": "https://docs.rs/streaming_algorithms",

"excerpts": [

"HyperLogLog; Reservoir sampling. A goal of this library is to enable
composition of these algorithms; for example Top k + HyperLogLog to
enable an approximate ... streaming_\nalgorithms 0.3.",

"Crate streaming_algorithms",

"Crate streaming_algorithms\nCopy item path\nSource\nStructs §\n *
Count\nMinSketch\n * An implementation of a count-min sketch data
structure with conservative updating for increased accuracy. *
Hyper\nLogLog\n * An implementation of the HyperLogLog data structure
with bias correction . * Hyper\nLogLog\nMagnitude\n * Like\nHyperLogLog
but implements\nOrd and\nEq by using the estimate of the cardinality. *
Sample\nTotal\n * Given population and sample sizes, returns true if
this element is in the sample. Without replacement. * Sample\nUnstable\n
* Reservoir sampling . Without replacement, and the returne"

]

},

{

"title": "(PDF) Random Sampling With a Reservoir - Amanote Research",

"url":
"https://research.amanote.com/publication/dKuHAnQBKQvf0BhiQHpU/random-sampling-with-a-reservoir",

"excerpts": [

"Full Text. Open PDF. Abstract. Available in full text. Categories.
Applied Mathematics Software. Date. March 1, 1985. Authors. Jeffrey S.
Vitter. Publisher."

]

},

{

"title": "[PDF] Random Sampling - Florian Schoppmann",

"url":
"https://florian-schoppmann.net/assets/docs/2012-08-random-sampling.pdf",

"excerpts": [

"pdf. [7] Jeffrey S. Vitter. Random sampling with a reservoir. ACM
Transactions on Mathematical Software, 11. (1):37–57, 1985. DOI:
10.1145/3147.3165. [8] ..."

]

},

{

"title": "Reservoir Sampling",

"url": "https://florian.github.io/reservoir-sampling/",

"excerpts": [

"Nov 30, 2019 — The problem goes like this: Given a stream of elements,
we want to sample k random ones, without replacement and by using
uniform probabilities.",

"Summary. Reservoir sampling allows us to sample elements from a stream,
without knowing how many elements to expect. The final solution is ..."

]

},

{

"title": "Reservoir Sampling algorithm in Python",

"url": "https://github.com/vikotse/Reservoir-Sampling",

"excerpts": [

"This module is using Reservoir Sampling to randomly choose exactly K
(Sample Number) rows on input file. Sampling result's row order is the
same as input file."

]

},

{

"title": "why does reservoir sampling wikipedia say that the algorithm
doesn ...",

"url":
"https://www.reddit.com/r/algorithms/comments/1grerjm/why_does_reservoir_sampling_wikipedia_say_that/",

"excerpts": [

"Reservoir sampling is a family of randomized algorithms for choosing a
simple random sample, without replacement, of k items from a ..."

]

},

{

"title": "Reservoir Sampling - Daniel Vainsencher",

"url": "https://nirinor.ai/book/iterative_methods_part_3.html",

"excerpts": [

"The reservoir sampling algorithm randomly skips items from the stream
to balance the accuracy of the reservoir sample with the efficiency of
the algorithm.",

"This post describes how the Iterative Methods crate facilitates easy
reservoir sampling of a StreamingIterator."

]

},

{

"title": "Talk:Reservoir sampling - Wikipedia",

"url": "https://en.wikipedia.org/wiki/Talk%3AReservoir_sampling",

"excerpts": [

"I think that according to Vitter's paper, this algorithm should include
a bound such that \"t > thresh, where thresh is equal to T x n.\"
(direct reference from ..."

]

},

{

"title": "rweeks/rs-tool: CLI tool for reservoir sampling - GitHub",

"url": "https://github.com/rweeks/rs-tool",

"excerpts": [

"It uses reservoir sampling to produce a sample of its input on a
per-record or per-field basis. It prints its output to stdout in either
tabular or JSON format."

]

},

{

"title": "Reservoir Sampling: A Powerful Technique for Handling ...",

"url":
"https://algocademy.com/blog/reservoir-sampling-a-powerful-technique-for-handling-large-data-streams/",

"excerpts": [

"Reservoir Sampling is a powerful and elegant algorithm that solves the
problem of sampling from data streams of unknown or infinite size."

]

},

{

"title": "A Golang implementation of the VarOpt weighted sampling ...",

"url": "https://github.com/lightstep/varopt",

"excerpts": [

"VarOpt is a reservoir-type sampler that maintains a fixed-size sample
and provides a mechanism for merging unequal-weight samples. This
repository also includes ..."

]

},

{

"title": "[PDF] Algorithms and Data Structures for External Memory",

"url": "https://www.ittc.ku.edu/~jsv/Papers/Vit.IO_book.pdf",

"excerpts": [

"Algorithms and Data Structures for External Memory surveys the state of
the art in the design and analysis of external memory (or EM) algorithms
..."

]

},

{

"title": "(PDF) Algorithm 673: Dynamic Huffman coding - ResearchGate",

"url":
"https://www.researchgate.net/publication/220492491_Algorithm_673_Dynamic_Huffman_coding",

"excerpts": [

"PDF | We present a Pascal implementation of the one-pass algorithm for
constructing dynamic Huffman codes that is described and analyzed in a
companion."

]

},

{

"title": "Reservoir Sampling",

"url":
"https://alhardy.github.io/app-metrics-docs/getting-started/sampling/index.html",

"excerpts": [

"Reservoir sampling is a family of randomized algorithms for randomly
choosing a sample of k items from a list S containing n items."

]

},

{

"title": "7.3 Testing Goodness-of-Fit of Distribution Models",

"url":
"https://civil.colorado.edu/~balajir/CVEN5454/lectures/Ang-n-Tang-Chap7-Goodness-of-fit-PDFs-test.pdf",

"excerpts": [

"The K-S test has some advantage over the chi-square test. With the K-S
test, it is not necessary to divide the observed data into intervals;
hence, the problem ..."

]

},

{

"title": "Reservoir sampling (Algorithm R) implemented in Rust -
npryce/reservoir-rs",

"url": "https://github.com/npryce/reservoir-rs",

"excerpts": [

"Reservoir sampling (Algorithm R) implemented in Rust",

"Languages\n * Rust 100.0%",

"Run\ncargo doc to generate documentation."

]

},

{

"title": "Reservoir Sampling in Rust",

"url": "https://github.com/SamuelLarkin/reservoir_sampling.rs",

"excerpts": [

"Reservoir Sampling in Rust",

"I needed a objective to help me learn `Rust` and reservoir sampling
became my excuse to learn `Rust`. It allows perform weighted or
unweighted sampling. Constructive comments are welcome. Install",

"Reservoir Sampling in Rust. Contribute to
SamuelLarkin/reservoir_sampling.rs development by creating an account on
GitHub. Reservoir Sampling in Rust. Contribute to
SamuelLarkin/reservoir_sampling.rs development by creating an account on
GitHub."

]

},

{

"title": "alecmocatta/streaming_algorithms",

"url": "https://github.com/alecmocatta/streaming_algorithms",

"excerpts": [

"Performant implementations of various streaming algorithms, including
Count–min sketch, Top k, HyperLogLog, Reservoir sampling."

]

},

{

"title": "rsam - crates.io: Rust Package Registry",

"url": "https://crates.io/crates/rsam",

"excerpts": [

"Mar 20, 2023 — A random sampler for text-based data using reservoir
sampling algorithm. install. install cargo and rust here:
https://www.rust-lang.org/tools/ ..."

]

},

{

"title": "WEIGHTED RESERVOIR SAMPLING: RANDOMLY ...",

"url": "https://cwyman.org/papers/rtg2-chapter22-preprint.pdf",

"excerpts": [

"by C Wyman · 2021 · Cited by 4 — Weighted reservoir sampling processes
a stream of elements Ei and incrementally selects a subset weighted
proportional to a provided set of weights wi."

]

},

{

"title": "Weighted Reservoir Sampling: Randomly Sampling Streams",

"url":
"http://research.nvidia.com/labs/rtr/publication/wyman2021weighted/",

"excerpts": [

"Reservoir sampling is a family of algorithms that, given a stream of N
elements, randomly select a K-element subset in a single pass."

]

},

{

"title": "Proving Algorithm Correctness",

"url":
"https://course.ccs.neu.edu/cs5002f18-seattle/lects/cs5002_lect11_fall18_notes.pdf",

"excerpts": [

"Mathematical induction is a very useful method for proving the
correctness of recursive algorithms. Built off proof by induction.
Useful for algorithms that ..."

]

},

{

"title": "Correctness proofs",

"url":
"https://citeseerx.ist.psu.edu/document?repid=rep1&type=pdf&doi=9a4116f84c836fe545dc9b569d434a6cbae634bb",

"excerpts": [

"by J Aspnes · 2003 · Cited by 1 — A correctness proof is a formal
mathematical argument that an algorithm meets its specification, which
means that it always produces the ..."

]

},

{

"title": "Reservoir sampling algorithms and related work (ACM/TOMS
excerpt)",

"url": "https://dl.acm.org/doi/10.1145/198429.198435",

"excerpts": [

"One-pass algorithms for sampling *n* records without replacement from a
population of unknown size *n* are known as reservoir-sampling
algorithms.",

"In this article, Vitter's reservoir-sampling algorithm, algorithm Z, is
modified to give a more efficient algorithm, algorithm K. Additionally,
two new algorithms, algorithm L and algorithm M, are proposed.",

"VITTER, J.S. 1985. Random sampling with a reservoir. ACM Trans. Math.
Softw. 11, 1 (Mar. ), 37-57.",

"Reservoir-sampling algorithms of time complexity O(n(1 + log(N/n))) |
ACM Transactions on Mathematical Software",

"Recommendations"

]

},

{

"title": "Random Sampling with a Reservoir (Vitter, 1985)",

"url": "https://dl.acm.org/doi/pdf/10.1145/3147.3165",

"excerpts": [

"\n\n\nWe introduce fast algorithms for selecting a random sample of n
records without replacement from\na pool of N records, where the value
of N is unknown beforehand. The main result of the paper is\nthe design
and analysis of Algorithm Z; it does the sampling in one pass using
constant space and in\nO(n(1 + log(N/n)))\texpected time, which is
optimum, up to a constant factor.",

":\n Definition 1. The first step of any reservoir algorithm is to put
the first n\nrecords of the file into a “reservoir.",

"Algorithm R (which is is a reservoir algorithm due to Alan Waterman)
works\nas follows: When the (t + 1)st record in the file is being
processed, for t L n, the\nn candidates form a random sample of the
first t records. The (t + 1)st record\nhas a n/(t + 1) chance of being
in a random sample of size n of the first t + 1\nrecords, and so it is
made a candidate with probability n/(t + 1). The candidate\nit replaces
is chosen randomly from the n candidat",

"The reservoir might be rather large, and so\nthis process could be
expensive. The most efficient reservoir algorithms (including\nthe ones
we discuss in this paper) avoid this step by always maintaining a set
of\nn designated candidates in the reservoir, which form a true random
sample of the\nrecords processed so far."

]

},

{

"title": "Reservoir crate on crates.io",

"url": "https://crates.io/crates/reservoir",

"excerpts": [

"Reservoir sampling with Algorithm R implemented in Rust. Run",

"reservoir - crates.io: Rust Package Registry",

"reservoir = \"0.2.0\"",

"docs.rs/reservoir/0.2.0",

"Repository\n----------\n\n[github.com/npryce/reservoir-rs](https://github.com/npryce/reservoir-rs)",

"Reservoir sampling of iterators",

"0\nReservoir sampling of iterators\n * Readme\n * 2 Versions"

]

},

{

"title": "Reservoir Sampling for Streaming Data",

"url":
"https://austinrochford.com/posts/2014-11-30-reservoir-sampling.html",

"excerpts": [

"These algorithms assume that data arrive sequentially over time and/or
that the data set is too large to fit into memory for random access.",

"edia.org/wiki/Reservoir_sampling) samples \\(k\\) random items from the
stream (without replacement) in the sense that after seeing \\(n\\) data
points, the probability that any individual data point is in the sample
is \\(\\frac{k}{n}\\).",

"The reservoir algorithm is so named because at each step it updates a
“reservoir” of candidate samples.",

"\n1. Vitter, Jeffrey S. “Random sampling with a reservoir.” *ACM
Transactions on Mathematical Software (TOMS)* 11.1 (1985): 37-57."

]

},

{

"title": "A Skip-based Algorithm for Weighted Reservoir Random Sampling
with Replacement",

"url": "https://arxiv.org/html/2403.20256v1",

"excerpts": [

"In this paper, we presented the standard algorithm for weighted
reservoir sampling with replacement, which we called WRSWR, and we
designed a novel method WRSWR\\_SKIP which reduces the computational
cost of WRSWR and generalizes the RSWR\\_SKIP algorithm introduced in
[[1](https://arxiv.org/html/2403.20256v1.bib1)",

"References",

"* [1]\n\n Reservoir-based Random Sampling with Replacement from Data
Stream, B. Park, G. Ostrouchov, N. F. Samatova and A. Geist, Proceedings
of the Fourth SIAM International Conference on Data Mining, 20",

"* [2]\n\n Random Sampling with a Reservoir, J. S. Vitter, ACM
Transactions on Mathematical Software, 19",

"* [3]\n\n A general purpose unequal probability sampling plan, M. T.
Chao, Biometrika, 19",

"* [4]\n\n Weighted random sampling with a reservoir, P. S. Efraimidis
and P. G. Spirakis, Information Processing Letters, 20"

]

},

{

"title": "Reservoir Sampling and Rust Crates (UAI 2016 paper excerpts)",

"url": "https://auai.org/uai2016/proceedings/papers/293.pdf",

"excerpts": [

"The simplest reservoir sampling algorithm for unweighted data,
introduced as “Algorithm R” by Vitter [1985], is re- produced here in
Algorithm 1"

]

},

{

"title": "CS168: The Modern Algorithmic Toolbox — Lecture #13: Reservoir
Sampling",

"url": "https://web.stanford.edu/class/cs168/l/l13.pdf",

"excerpts": [

"Reservoir Sampling [Vitter ’85]",

"Given a number k, and a datastream x1 , x2 , . . . of length greater
than k:\n\n\t\t\t • Put the first k elements of the stream into a
“reservoir” R = (x1 , . . . , xk ). • For i ≥ k + 1\n\n\t\t\t\t – With
probability ki replace a random entry of R with xi . • At the end of the
stream, return the reservoir R.",

"R.\n\n\n We now show that at any time t ≥ k, the reservoir R consists
of a uniformly random\nsubset of k of the entries of x1 , . . . , xt .
To do this, let Rt denote the reservoir after the tth\ndatastream
element has been seen. It suffices to show that for all t ≥ i, Pr[xi ∈
R] = kt , and\nthe event that xi ∈ R is independent of the contents of
the reservoir at times t < i. Claim 1.1 For all t ≥ i, Pr[xi ∈ Rt ] = kt
, where Rt denotes the reservoir after time t."

]

},

{

"title": "Minimax approximation algorithm",

"url": "https://en.wikipedia.org/wiki/Minimax_approximation_algorithm",

"excerpts": [

"A minimax approximation algorithm is a method to find an approximation
of a mathematical function that minimizes maximum error. For example,
given a ..."

]

},

{

"title": "warning",

"url": "https://www.sollya.org/sollya-4.1/help.php",

"excerpts": [

"Both Sollya functions and Sollya objects are transferred from and to
the external procedure thru the C type sollya_obj_t. The difference is
that Sollya will ..."

]

},

{

"title": "3.11(i) Minimax Polynomial Approximations",

"url": "https://dlmf.nist.gov/3.11",

"excerpts": [

"A sufficient condition for p n ⁡ ( x ) to be the minimax polynomial is
that | ϵ n ⁡ ( x ) | attains its maximum at n + 2 distinct points in [ a
, b ] and ϵ n ⁡ ..."

]

},

{

"title": "musl - an implementation of the standard library for
Linux-based ...",

"url":
"https://git.etalabs.net/cgit/musl/diff/?h=v0.9.8&id=ab1772c597ba8fe0c26400256b12d7a4df23880e",

"excerpts": [

"index : musl. master, rs-1.0. musl - an implementation of the standard
library for Linux-based systems ... diff --git a/src/math/expf.c
b/src/math/expf.c index ..."

]

},

{

"title": "m - Rust",

"url": "https://docs.rs/m",

"excerpts": [

"AC free / pure Rust mathematical library (\"libm\") for no_std code.
This is a port of OpenLibm. Usage Currently, this crate only provides a
Float extension ..."

]

},

{

"title": "micromath - crates.io: Rust Package Registry",

"url": "https://crates.io/crates/micromath",

"excerpts": [

"Embedded-friendly math library featuring fast floating point
approximations (with small code size) for common arithmetic operations."

]

},

{

"title": "micromath - Rust",

"url": "https://docs.rs/micromath/",

"excerpts": [

"micromath supports approximating many arithmetic operations on f32
using bitwise operations, providing great performance and small code
size at the cost of ..."

]

},

{

"title": "sleef - Rust",

"url": "https://docs.rs/sleef",

"excerpts": [

"SLEEF stands for SIMD Library for Evaluating Elementary Functions. It
implements vectorized versions of all C99 real floating point math
functions."

]

},

{

"title": "micromath - crates.io: Rust Package Registry",

"url": "https://crates.io/crates/micromath/0.4.1",

"excerpts": [

"Oct 8, 2019 — Embedded-friendly math library featuring fast floating
point approximations (with small code size) for common arithmetic
operations."

]

},

{

"title": "sleef - crates.io: Rust Package Registry",

"url": "https://crates.io/crates/sleef/0.3.1",

"excerpts": [

"sleef-rs. Rust port of Sleef math library based on Portable SIMD
Vectors a.k.a. core::simd. Usage. Requires nightly feature portable_simd
."

]

},

{

"title": "Sollya: S Chevillard et al. - Sollya reference and remez
details",

"url": "https://www.sollya.org/sollya-weekly/sollya.pdf",

"excerpts": [

" n, range, w, quality, bounds) : (function, integer, range, function,
constant, range) → function\n remez(f, L, range, w, quality, bounds) :
(function, list,",

"Parameters:\n\n • f is the function to be approximated\n • n is the
degree of the polynomial that must approximate f\n • L is a list of
integers or a list of functions and indicates the basis for the
approximation of f\n • range is the interval where the function must be
approximated\n\n\n\n\t\t\t\t\t\t\t\t\t\t\t\t 192\n\f • w (optional) is a
weight function. Default is 1. • quality (optional) is a parameter that
controls the quality of the returned polynomial p, with respect\n\tto
the exact minimax p⋆ . Default is 1e-5. • bounds (optional) is a
parameter that allows the user to make the algorithm stop earlier,
whenever\n\ta given accuracy is reached or a given accuracy is proved
unreachable. Default is [0, +∞]. Description:\n • remez computes an
approximation of the function f with respect to the weight function w on
the\n\tinterval range. More precisely, it searches p such that ∥pw − f
∥∞ is (almost) minimal among all p\n\tof a certain form. The norm is the
infinity norm, e.g. ∥g∥∞ = max{|g(x)|, x ∈ range}.\n• If w = 1 (the
default case), it consists in searching the best polynomial
approximation of f with\n\trespect to the absolute error. If f = 1 and w
is of the form 1/g, it consists in searching the best\n\tpolynomial
approximation of g with respect to the relative error. • If n is given,
p is searched among the polynomials with degree not greater than n. If L
is given\n\tand is a list of integers, p is searched as a linear
combination of monomials X k where k belongs to\n\tL. In the case when L
is a list of integers, it may contain ellipses but cannot be
end-elliptic. If L is\n\tgiven and is a list of functions gk , p is
searched as a linear combination of the gk . In that case L\n\tcannot
contain ellipses. It is the user responsibility to check that the gk are
linearly independent\n\tover the interval range. Moreover, the functions
w · gk must be at least twice differentiable over\n\trange. If these
conditions are not fulfilled, the algorithm might fail or even silently
return a result\n\tas if it successfully found the minimax, though the
returned p is not optimal. • The polynomial is obtained by a convergent
iteration called Remez’ algorithm (and an extension\n\tof this
algorithm, due to Stiefel). The algorithm computes a sequence p1 , . . .
, pk , . . . such that\n\tek = ∥pk w − f ∥∞ converges towards the
optimal value e. The algorithm is stopped when the\n\trelative error
between ek and e is less than quality. For this reason, the returned
polynomial usually has dyadic coefficients.\nHowever, one should
not\n\trely on that property. Especially, a noticeable exception to that
statement is when we manage to\n\tdetect that f /w exactly simplifies to
a polynomial of the required degree, in which case we return\n\tit as it
is without further rounding. • The optional argument bounds is an
interval [εℓ , εu ] with the following behavior:\n\t\t– if, during the
algorithm, we manage to prove that εu is unreachable, we stop the
algorithm\n\t\t returning the last computed polynomial. – if, during the
algorithm, we obtain a polynomial with an error smaller than εℓ , we
stop the\n\t\t algorithm returning that polynomial. – otherwise we loop
until we find an optimal polynomial with the required quality, as usual.
Examples of use:\n\t [0, +∞] (compute the optimal polynomial with the
required quality)\n\t [εu ] (stops as soon as a polynomial achieving εu
is obtained or as soon as such a polynomial is\n\t proved not to exist).
[0, εu ] (finds the optimal polynomial, but provided that its error is
smaller than εu ). [εℓ , +∞] (stops as soon as a polynomial achieving εℓ
is obtained. If such a polynomial does not\n\t exist, returns the
optimal polynomial). Example 1:\n\n > p = remez(exp(x),5,[0;1]);\n >
degree(p);\n 5\n > dirtyinfnorm(p-exp(x),[0;1]);\n
1.1295698151096148707171193829266077607222634"

]

},

{

"title": "Sollya User's Manual - remez",

"url": "https://www.sollya.org/sollya-2.0/help.php?name=remez",

"excerpts": [

"computes the minimax of a function on an interval.
Usage:\n------\n\n[remez](help.php?name=remez)(f, n, range, w, quality)
: (function, integer, range, function, constant) -> f",

"range is the interval where the function must be approximated",

" a weight function. Default is 1. * quality (optional) is a parameter
that controls the quality of the returned polynomial p, with respect to
the exact minimax p\\*. Default is 1e-5",

"The polynomial is obtained by a convergent iteration called Remez'
algorithm"

]

},

{

"title": "Sollya Help and Related References",

"url": "https://sollya.org/sollya-4.0/help.php",

"excerpts": [

" [remez]() computes an approximation of the function f with respect
to\n the weight function w on the interval range. More precisely, it\n
searches p such that ||p\\*w-f|| is\n (almost) minimal among all p of a
certain f",

"The polynomial is obtained by a convergent iteration called Remez'\n
algorithm (and an extension of this algorithm, due to Stiefel",

"The algorithm computes a sequence p1, ..., pk, ...\n such that ek =
||pk\\*w-f|| converges towards\n the optimal val",

"The optional argument bounds is an interval [satisfying\\_err,
target\\_err]\n with the following behav",

"+ if, during the algorithm, we manage to prove that target\\_err is\n
unreachable, we stop the algorithm returning the last computed\n po",

"+ if, during the algorithm, we obtain a polynomial with an error
smaller\n than satisfying\\_err, we stop the algorithm returning that
polyno",

"+ otherwise we loop until we find an optimal polynomial with the
required\n quality, as us",

"\nUsage:\n------\n\n[remez]()(f, n, range, w, quality, bounds) :
(function, integer, range, function, constant, range) -> function",

"\n[remez]()(f, L, range, w, quality, bounds) : (function, list, range,
function, constant, range) -> function",

"Parameters:\n-----------\n\n* f is the function to be approximated\n* n
is the degree of the polynomial that must approximate f\n* L is a list
of integers or a list of functions and indicates the basis for the
approximation of f\n* range is the interval where the function must be
approximated\n* w (optional) is a weight function. Default is 1. *
quality (optional) is a parameter that controls the quality of the
returned polynomial p, with respect to the exact minimax p\\*. Default
is 1e-"

]

},

{

"title": "Sollya Help: Remez Minimax Polynomial Approximation",

"url": "https://www.sollya.org/sollya-8.0/help.php",

"excerpts": [

"Sollya commands like remez, taylor or rationalapprox sometimes produce
expressions that can be simplified. Constant subexpressions can be
evaluated to ... Library names:",

"Usage:\n------\n\n[remez]()(f, n, range, w, quality, bounds) :
(function, integer, range, function, constant, range) ->
function\n[remez]()(f, L, range, w, quality, bounds) : (function, list,
range, function, constant, range) -> function",

"Parameters:\n-----------\n\n* f is the function to be approximated\n* n
is the degree of the polynomial that must approximate f\n* L is a list
of integers or a list of functions and indicates the basis for the
approximation of f\n* range is the interval where the function must be
approximated\n* w (optional) is a weight function. Default is 1. *
quality (optional) is a parameter that controls the quality of the
returned polynomial p, with respect to the exact minimax p\\*. Default
is 1e-5. * bounds (optional) is a parameter that allows the user to make
the algorithm stop earlier, whenever a given accuracy is reached or a
given accuracy is proved unreachable. Default is [0, +Inf].
Description:\n------------\n\n* [remez]() computes an approximation of
the function f with respect to\n the weight function w on the interval
range. More precisely, it\n searches p such that ||p\\*w-f|| is\n
(almost) minimal among all p of a certain form. The norm is\n the
infinity norm, e.g. ||g|| = max {|g(x)|, x in range}.\n* If w=1 (the
default case), it consists in searching the best\n polynomial
approximation of f with respect to the absolute error. If f=1 and w is
of the form 1/g, it consists in\n searching the best polynomial
approximation of g with respect to the\n relative error. * If n is
given, p is searched among the polynomials with degree not\n greater
than n.\n If L is given and is a list of integers, p is searched as a
linear\n combination of monomials X^k where k belongs to L.\n In the
case when L is a list of integers, it may contain ellipses but\n cannot
be end-elliptic. If L is given and is a list of functions g\\_k, p is
searched as a\n linear combination of the g\\_k. In that case L cannot
contain ellipses. It is the user responsibility to check that the g\\_k
are linearly independent\n over the interval range. Moreover, the
functions w\\*g\\_k must be at least\n twice differentiable over range.
If these conditions are not fulfilled, the\n algorithm might fail or
even silently return a result as if it successfully\n found the minimax,
though the returned p is not optimal. * The polynomial is obtained by a
convergent iteration called Remez'\n algorithm (and an extension of this
algorithm, due to Stiefel). The algorithm computes a sequence p1, ...,
pk, ...\n such that ek = ||pk\\*w-f|| converges towards\n the optimal
value e. The algorithm is stopped when the relative error\n between ek
and e is less than quality.\n ... \nExample 1:\n----------\n\n   > p =
remez(exp(x),5,[0;1]); \n   > degree(p); \n   5 \n   >
dirtyinfnorm(p-exp(x),[0;1]);
\n   1.1295698151096148707171193829266077607222",

"For historical reasons, fpminimax and remez have different syntaxes.
Indeed, the syntax of fpminimax has been designed to be higher level and
closer to ..."

]

},

{

"title": "Musl Musl libc - expf.c (example excerpt and notes)",

"url": "https://git.musl-libc.org/cgit/musl/tree/src/math/expf.c",

"excerpts": [

"/* EXP2F_TABLE_BITS = 5 EXP2F_POLY_ORDER = 3 ULP error: 0.502 (nearest
rounding.) Relative error: 1.69 * 2^-34 in [-ln2/64, ln2/64] (before
rounding.)",

"... [-ln2/64, ln2/64] (before rounding.) Wrong count: 170635 (all
nearest rounding wrong results with fma.) Non-nearest ULP error: 1
(rounded ULP error) ...",

"` /* * Single-precision e^x function. * * Copyright (c) 2017-2018, Arm
Limited. * SPDX-License-Identifier: MIT */",

"float expf(float x) {",

"EXP2F_TABLE_BITS = 5 EXP2F_POLY_ORDER = 3 ULP error: 0.502 (nearest
rounding.) Relative error: 1.69 * 2^-34 in [-ln2/64, ln2/64] (before",

"path: root / src / math / expf.c\nblob:
f9fbf8e727db635c0ea0b5685d374895b8bbffd2 ( plain ) ( blame
)\n\n\n\n\n\ngenerated by cgit v1.2.1 ( git 2.18.0 ) at 2025-08-14
19:28:57 +0000",

"Non-nearest ULP error: 1 (rounded ULP error) */ #define N (1 <<
EXP2F_TABLE_BITS) #define InvLn2N __exp2f_data.invln2_scaled #define T
__exp2f_data.tab #define ..."

]

},

{

"title": "musl expf.c excerpt",

"url":
"https://git.musl-libc.org/cgit/musl/tree/src/math/expf.c?h=v1.1.18&id=eb03bde2f24582874cb72b56c7811bf51da0c817",

"excerpts": [

" * Domain [-0.34568, 0.34568], range ~[-4.278e-9, 4.447e-9]: *
|x*(exp(x)+1)/(exp(x)-1) - p(x)| < 2**-27.74 */",

"float expf(float x) { \tfloat_t hi, lo, c, xx, y; \tint k, sign;
\tuint32_t hx; \tGET_FLOAT_WORD(hx, x); \tsign = hx >> 31; /* sign bit
of x */ \thx &= 0x7fffffff; /* high word of |x| *",

"/* argument reduction */ \tif (hx > 0x3eb17218) { /* if |x| > 0.5 ln2
*/ \t\tif (hx > 0x3f851592) /* if |x| > 1.5 ln2 */ \t\t\tk = invln2*x +
half[sign]; \t\telse \t\t\tk = 1 - sign - sign; \t\thi = x - k*ln2hi; /*
k*ln2hi is exact here */ \t\tlo = k*ln2lo; \t\tx = hi - lo; \t} else if
(hx > 0x39000000) { /* |x| > 2**-14 */ \t\tk = 0; \t\thi = x; \t\tlo =
0; \t} else { \t\t/* raise inexact */ \t\tFORCE_EVAL(0x1p127f + x);
\t\treturn 1 + x; \t}",

"/* x is now in primary range */ \txx = x*x; \tc = x -"

]

},

{

"title": "fast-math crate documentation",

"url": "https://docs.rs/fast-math",

"excerpts": [

"This crate includes implementations of “expensive”
mathematical\nfunctions that are much faster, at the expense of
some\naccuracy. All functions have good guarantees on accuracy to
some\ndegree (both relative and absolute).",

"Fast, approximate versions of mathematical functions."

]

},

{

"title": "warning - Sollya User's Manual",

"url": "https://www.sollya.org/sollya-2.9/help.php",

"excerpts": [

"remez computes the minimax of a function on an interval. Usage:
remez(f, n, range, w, quality) : (function, integer, range, function,
constant) -> function ..."

]

},

{

"title": "Cephes double precision special functions suite",

"url": "https://www.netlib.org/cephes/doubldoc.html",

"excerpts": [

"Oct 5, 2014 — Cephes Mathematical Library. Source code archives.
Documentation for single precision library. Documentation for double
precision library."

]

},

{

"title": "Using MATLAB to find Minimax Polynomial Approximation of ...",

"url":
"https://stackoverflow.com/questions/9301380/using-matlab-to-find-minimax-polynomial-approximation-of-trigonometric-functions",

"excerpts": [

"I am trying to find the minimax polynomial approximation for sine and
cosine using the remez exchange algorithm in MATLAB. The need precision
out to 23 bits."

]

},

{

"title": "Efficient computation of the exponential function (in
Cephes)",

"url":
"https://math.stackexchange.com/questions/4382370/efficient-computation-of-the-exponential-function-in-cephes",

"excerpts": [

"Feb 14, 2022 — I'm trying to understand how computers calculate
(approximate) the exponential function. I'm reading the code of the
Cephes library, specifically this code."

]

},

{

"title": "micromath - crates.io: Rust Package Registry",

"url": "https://crates.io/crates/micromath/0.5.1",

"excerpts": [

"Embedded-friendly math library featuring fast floating point
approximations (with small code size) for common arithmetic operations,
trigonometry, ..."

]

},

{

"title": "exp.rs source code [crates/micromath/src/float/ ...",

"url":
"https://codebrowser.dev/slint/crates/micromath/src/float/exp.rs.html",

"excerpts": [

"Source code of exp.rs micromath 2.1.0 on KDAB Codebrowser."

]

},

{

"title": "musl - musl",

"url":
"https://git.musl-libc.org/cgit/musl/diff/?id=ab1772c597ba8fe0c26400256b12d7a4df23880e",

"excerpts": [

"* Domain [-0.34568, 0.34568], range ~[-4.278e-9, 4.447e-9]:. *
|x*(exp(x)+1)/(exp(x)-1) - p(x)| < 2**-27.74. */. -P1 = 1.6666625440e-1,
/* 0xaaaa8f.0p-26 ..."

]

},

{

"title": "Rounding the coefficients of a minimax polynomial",

"url":
"https://discourse.julialang.org/t/rounding-the-coefficients-of-a-minimax-polynomial/92873",

"excerpts": [

"Jan 12, 2023 — If you need the “exact” minimax polynomial, you may want
to build a Remez algorithm on top of one of these packages. My package
actually ..."

]

},

{

"title": "The eight useful polynomial approximations of `sinf(3)' - Paul
Khuong",

"url":
"https://www.pvk.ca/Blog/2012/10/07/the-eight-useful-polynomial-approximations-of-sinf-3/",

"excerpts": [

"These methods exploit real analysis results to reduce the problem to
computing minimax polynomials over very few points (one per coefficient,
..."

]

},

{

"title": "Understanding f32 Floating Point - by Carl Maxwell",

"url":
"https://medium.com/@Carl_Maxwell/understanding-f32-floating-point-9d7e3604ab97",

"excerpts": [

"There are two popular types of floating point numbers, the f32 (which
uses 32 bits of memory) and the f64 (which uses 64 bits of memory)."

]

},

{

"title": "sin.c\\math\\src",

"url": "https://git.musl-libc.org/cgit/musl/tree/src/math/sin.c",

"excerpts": [

"argument reduction routine * * Method. * Let S,C and T denote the sin,
cos and tan respectively on * [-PI/4, +PI/4]. Reduce the argument x to
y1+y2 = x-k*pi/2 ..."

]

},

{

"title": "src/math/e_expf.c - Musl - ICube forge",

"url":
"https://forge.icube.unistra.fr/icps/musl/-/blob/fc27b96c7d9b2c82679508a57ac998d773f14f08/src/math/e_expf.c",

"excerpts": [

"Ouvrir dans Web EDI . Modifiez rapidement et facilement plusieurs
fichiers de votre projet. Modifier le fichier unique Modifiez ce fichier
..."

]

},

{

"title": "fast_log - crates.io: Rust Package Registry",

"url": "https://crates.io/crates/fast_log",

"excerpts": [

"A log implementation for extreme speed, using Crossbeam/channel ,once
Batch write logs,fast log date, Appender architecture, appender per
thread."

]

},

{

"title": "r/rust on Reddit: My new crate: fast-logger - An attempt at
the fastest ...",

"url":
"https://www.reddit.com/r/rust/comments/bvbbjb/my_new_crate_fastlogger_an_attempt_at_the_fastest/",

"excerpts": [

"The goal of this crate is to be the absolute fastest logger in terms of
caller latency. That means the caller should spend as little time inside
the crate's ..."

]

},

{

"title": "fast_logger - Rust - Docs.rs",

"url": "https://docs.rs/fast-logger",

"excerpts": [

"fast_logger is a simple log-level based logger that uses a thread and
handle, with log levels controlled per-context and globally. It uses
helper functions ..."

]

},

{

"title": "sollya-1.1.pdf",

"url": "https://www.sollya.org/releases/sollya-1.1/sollya-1.1.pdf",

"excerpts": [

"by S Chevillard · 2008 · Cited by 10 — Note that fpminimax internally
computes a minimax polynomial (using the same algorithm as remez
command). ... exp(x) * log(sin(x))). Example 6: 89. Page 90. > 2^3 ..."

]

},

{

"title": "f32 - Rust",

"url": "https://rust.docs.kernel.org/core/primitive.f32.html",

"excerpts": [

"Approximate number of significant digits in base 10. This is the
maximum x such that any decimal number with x significant digits can be
converted to f32 and ..."

]

},

{

"title": "Implementing cosine in C from scratch",

"url": "https://austinhenley.com/blog/cosine.html",

"excerpts": [

"Jul 19, 2020 — The first optimization I tried was range reduction. The
bigger the input value, the less accurate this method is. Since cosine
repeats every 2pi ..."

]

},

{

"title": "Cephes Library Documentation",

"url": "https://www.netlib.org/cephes/",

"excerpts": [

"Documentation of cephes 128-bit precision special functions. file
128bit.tgz for arithmetic and math functions for 128-bit reals. size
252kB file\tieee.tgz",

"file cmath.tgz for double precision elementary functions",

"file remes.tgz for minimax rational approximation",

"file linalg.tgz for C translations of eigens, lmdif",

"file eval.tgz for mconf.h, mtherr.c, polevl.c, chbevl.c used by other
cephes functions",

"for\t32-bit floating point versions of cephes functions"

]

},

{

"title": "Fast-Math crate (Rust)",

"url": "https://crates.io/crates/fast-math",

"excerpts": [

"Fast, approximate versions of mathematical functions.",

"Logarithms: `log2`,",

"Exponentials: `exp`, `exp2`,",

"Trigonometric functions: `atan`, `atan2`."

]

},

{

"title": "sleef Rust port",

"url": "https://crates.io/crates/sleef",

"excerpts": [

"Jan 24, 2024 — Rust port of Sleef math library based on Portable SIMD
Vectors aka core::simd. Usage: Requires nightly feature
portable_simd.See more crates.io",

"sleef v0.3.2\nMath functions for SIMD vectors\n * # libm\n * # math\n *
# simd",

"Repository\ngithub.com/burrbull/sleef-rs"

]

},

{

"title": "src/math/expf.c · C23-time · undefined · GitLab",

"url":
"https://forge.icube.unistra.fr/icps/musl/-/blob/C23-time/src/math/expf.c",

"excerpts": [

"* Single-precision e^x function. ... * Copyright (c) 2017-2018, Arm
Limited. ... ULP error: 0.502 (nearest rounding.) Relative error: 1.69 *
2^-34 in [-ln2/64, ln2/ ...",

"#include <math.h>. #include <stdint.h>. #include \"libm.h\". #include
\"exp2f_data.h\". /*. EXP2F_TABLE_BITS = 5. EXP2F_POLY_ORDER = 3. ULP
error: 0.502 (nearest ..."

]

},

{

"title": "Fetched web page",

"url": "http://git.musl-libc.org/cgit/musl/tree/src/math/sinf.c",

"excerpts": [

"path: root / src / math / sinf.c\nblob:
64e39f50177ca1f3330a6dffa687c7f78841b975 ( plain ) ( blame
)\n\n\n\n\n\ngenerated by cgit v1.2.1 ( git 2.18.0 ) at 2025-08-14
19:30:57 +0000"

]

},

{

"title": "cephes.c",

"url":
"http://web.science.mq.edu.au/~mjohnson/papers/sigdiff-code/cephes.c",

"excerpts": [

"/* cephes.c * * This file contains the functions from the CEPHES
library * called by sigdiff and related programs. * * I have collected
these into a single ..."

]

},

{

"title": "FWIW, Sollya's Remez algorithm takes intermediate ...",

"url": "https://news.ycombinator.com/item?id=36508558",

"excerpts": [

"Sollya's Remez algorithm takes intermediate floating-point accuracy
into account. At the very least, one should start by such a polynomial
and then try to ..."

]

},

{

"title": "[PDF] Implementation and Synthesis of Math Library Functions -
arXiv",

"url": "https://arxiv.org/pdf/2311.01515",

"excerpts": [

"These rewrite rules include identities for core functions such as
sin(𝑥) and log(𝑥), so synthesizing a sin or log implementation using
..."

]

},

{

"title": "Math support in core · Issue #2505 · rust-lang/rfcs",

"url": "https://github.com/rust-lang/rfcs/issues/2505",

"excerpts": [

"Jul 23, 2018 — Currently the core crate doesn't provide support for
mathematical functions like sqrt or sin. To do math in a #![no_std]
program one has the following options."

]

},

{

"title": "Sollya User's Manual",

"url": "https://www.sollya.org/sollya-5.0/help.php?name=fpminimax",

"excerpts": [

"Note that fpminimax internally computes a minimax polynomial (using the
same algorithm as remez command). Thus fpminimax may encounter the same
problems as remez . In particular, it may be very slow when Haar
condition is not fulfilled. Another consequence is that currently
fpminimax has to be run with a sufficiently high working precision.",

"Note that [fpminimax](help.php?name=fpminimax) internally computes a
minimax polynomial (using\n the same algorithm as
[remez](help.php?name=remez) command). Thus
[fpminimax](help.php?name=fpminimax) may encounter\n the same problems
as [remez](help.php?name=remez). In particular, it may be very slow\n
when Haar condition is not fulf"

]

},

{

"title": "rand_pcg crate on crates.io",

"url": "https://crates.io/crates/rand_pcg",

"excerpts": [

" The PCG algorithms are not suitable for cryptographic uses, but
perform well\nin statistical tests, use little memory and are fairly
fast. See the pcg-random website"

]

},

{

"title": "bitintr - Rust",

"url": "https://gnzlbg.github.io/bitintr/",

"excerpts": [

"bitintr offers portable bit manipulation intrinsics (@github,
@crates.io). The intrinsics are named after their CPU instruction and
organized in modules ..."

]

}

],

"reasoning": "Direct excerpts show clear relevance to bit-twiddling
primitives and the opportunity for a new Rust microcrate: there is
mention of portable bit manipulation intrinsics, PDEP/PEXT, and runtime
checks for fast paths; there is explicit evidence that the existing
bitintr crate is unmaintained and relies on nightly/unstable features,
indicating a vacuum and a need for a maintained, portable fallback.
Classic bit-twiddling resource collections provide a solid foundation
for implementing standard bit tricks (the bit hacks referenced widely as
canonical techniques). Several excerpts discuss PDEP/PEXT specifically
via the has_fast_pdep crate and related docs, showing a market signal
for fast software fallbacks and runtime feature-aware paths.
Documentation of bitintr, including ISA coverage (x86 ABM/TBM/BMI/BMI2
and ARM variants) helps anchor the API surface you propose and clarifies
what would be needed for a pure-Rust, portable implementation. Combined,
these sources substantiate the problem statement: a modern,
no-std-friendly, portable Rust crate implementing PDEP/PEXT-like
primitives, with a clean, documented API and solid test vectors, would
fill a real gap and align with community interest in branchless,
high-performance bit manipulation. The proposed API sketch (BitTwiddle
trait with pdep, pext, has_zero_byte, select, plus interleave_bits
utility) directly maps to the technical signals in the excerpts and
provides a concrete path for implementation, testing, and wasm/no_std
portability.",

"confidence": "high"

},

{

"field": "bit_twiddling_primitives_opportunity.gap_analysis",

"citations": [

{

"title": "Bitintr 0.3.0 Documentation and Repository",

"url": "http://docs.rs/bitintr/latest/bitintr",

"excerpts": [

"The following ISAs are implemented:\n\n* x86 (`bitintr::x86`):\n\n +
[`ABM`](https://en.wikipedia.org/wiki/Bit_Manipulation_Instruction_Sets.28Advanced_Bit_Manipulation.29):
Advanced Bit Manipulation instructions
([`bitintr::x86::abm`](https://gnzlbg.github.io/bitintr/bitintr/x86/abm/index.html)).\n
+
[`TBM`](https://en.wikipedia.org/wiki/Bit_Manipulation_Instruction_Sets.28Trailing_Bit_Manipulation.29):
Trailing Bit Manipulation instructions
([`bitintr::x86::tbm`](https://gnzlbg.github.io/bitintr/bitintr/x86/tbm/index.html)).\n
+
[`BMI`](https://en.wikipedia.org/wiki/Bit_Manipulation_Instruction_Sets.28Bit_Manipulation_Instruction_Set_1.29):
Bit Manipulation Instruction Set 1.0
([`bitintr::x86::bmi`](https://gnzlbg.github.io/bitintr/bitintr/x86/bmi/index.html)).\n
+
[`BMI2`](https://en.wikipedia.org/wiki/Bit_Manipulation_Instruction_Sets.28Bit_Manipulation_Instruction_Set_2.29):
Bit Manipulation Instruction Set 2.0
([`bitintr::x86::bmi2`](https://gnzlbg.github.io/bitintr/bitintr/x86/bmi2/index.html)).\n*
ARM (`bitintr::arm`):\n\n +
[`ARMv5`](http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0100i/index.html):
[`bitintr::arm::v5`](https://gnzlbg.github.io/bitintr/bitintr/arm/v5/index.html).\n
+
[`ARMv6`](http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0419c/index.html):
[`bitintr::arm::v6`](https://gnzlbg.github.io/bitintr/bitintr/arm/v6/index.html).\n
+
[`ARMv7`](http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0403e.b/index.html):
[`bitintr::arm::v7`](https://gnzlbg.github.io/bitintr/bitintr/arm/v7/index.html).\n
+
[`ARMv8`](http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0487a.k_10775/index.html):
[`bitintr::arm::v8`](https://gnzlbg.github.io/bitintr/bitintr/arm/v8/index.html).",

"This `#![no_std]` library exposes *safe* and *portable* low-level bit
manipulation\ninstruction set architectures."

]

},

{

"title": "gnzlbg/bitintr: Portable Bitwise Manipulation Intrinsics",

"url": "https://github.com/gnzlbg/bitintr",

"excerpts": [

"This `#![no_std]` library exposes *safe* and *portable* low-level bit
manipulation\ninstruction set architectures."

]

},

{

"title": "bitintr 0.3.0 - Docs.rs",

"url": "http://docs.rs/bitintr/0.3.0/bitintr",

"excerpts": [

"This `#![no_std]` library exposes *safe* and *portable* low-level bit
manipulation\ninstruction set architectures."

]

},

{

"title": "has_fast_pdep crate page",

"url": "https://crates.io/crates/has_fast_pdep",

"excerpts": [

"Rationale\n---------\n\nZen, Zen+, Zen 2, and Hygon Dhyana CPUs
implement PDEP and PEXT using microcode in a way that makes them slower
than well-optimized, non-intrinsic fallbacks. In performance-critical
code, checking for BMI2 support isn't enough—you could end up hurting
performance on said CPUs where these instructions exist but are slow.
This crate helps you avoid that by detecting speed, not just support.",

"has_fast_pdep = \"0.1\""

]

},

{

"title": "is_x86_feature_detected in std",

"url":
"https://doc.rust-lang.org/std/macro.is_x86_feature_detected.html",

"excerpts": [

"A macro to test at runtime whether a CPU feature is available on
x86/x86-64 platforms. This macro is provided in the standard library and
will detect at runtime",

"A macro to test at runtime whether a CPU feature is available on
x86/x86-64 platforms. This macro is provided in the standard library and
will detect at runtime std 1.88.0\n(6b00bc388
2025-06-23)\nis_\nx86_\nfeature_\ndetected\nSections\n * Supported
arguments\n\nIn crate std\nstd\nMacro is_x86_feature_detected\nCopy item
path\n1.27.0 · Source\nmacro_rules!\nis_x86_feature_detected
{\n(\"aes\") => { ... };\n(\"pclmulqdq\") => { ... };\n(\"rdrand\") => {
... };\n(\"rdseed\") => { ... };\n(\"tsc\") => { ... };\n(\"mmx\") => {
... };\n(\"sse\") => { ... };\n(\"sse2\") => { ... };\n(\"sse3\") => {
... };\n(\"ssse3\") => { ... };\n(\"sse4.1\") => { ... };\n(\"sse4.2\")
=> { ... };\n(\"sse4a\") => { ... };\n(\"sha\") => { ... };\n(\"avx\")
=> { ... };\n(\"avx2\") => { ... };\n(\"sha512\") => { ... };\n(\"sm3\")
=> { ... };\n(\"sm4\") => { ... };\n(\"avx512f\") => { ...
};\n(\"avx512cd\") => { ... };\n(\"avx512er\") => { ...
};\n(\"avx512pf\") => { ... };\n(\"avx512bw\") => { ...
};\n(\"avx512dq\") => { ... };\n(\"avx512vl\") => { ...
};\n(\"avx512ifma\") => { ... };\n(\"avx512vbmi\") => { ...
};\n(\"avx512vpopcntdq\") => { ... };\n(\"avx512vbmi2\") => { ...
};\n(\"gfni\") => { ... };\n(\"vaes\") => { ... };\n(\"vpclmulqdq\") =>
{ ... };\n(\"avx512vnni\") => { ... };\n(\"avx512bitalg\") => { ...
};\n(\"avx512bf16\") => { ... };\n(\"avx512vp2intersect\") => { ...
};\n(\"avx512fp16\") => { ... };\n(\"avxifma\") => { ...
};\n(\"avxneconvert\") => { ... };\n(\"avxvnni\") => { ...
};\n(\"avxvnniint16\") => { ... };\n(\"avxvnniint8\") => { ...
};\n(\"amx-tile\") => { ... };\n(\"amx-int8\") => { ...
};\n(\"amx-bf16\") => { ... };\n(\"amx-fp16\") => { ...
};\n(\"amx-complex\") => { ... };\n(\"amx-avx512\") => { ...
};\n(\"amx-fp8\") => { ... };\n(\"amx-movrs\") => { ...
};\n(\"amx-tf32\") => { ... };\n(\"amx-transpose\") => { ...
};\n(\"f16c\") => { ... };\n(\"fma\") => { ... };\n(\"bmi1\") => { ...
};\n(\"bmi2\") => { ... };\n(\"lzcnt\") => { ... };\n(\"tbm\") => { ...
};\n(\"popcnt\") => { ... };\n(\"fxsr\") => { ...\n};\n(\"xsave\") => {
... };\n(\"xsaveopt\") => { ... };\n(\"xsaves\") => { ...
};\n(\"xsavec\") => { ... };\n(\"cmpxchg16b\") => { ... };\n(\"kl\") =>
{ ... };\n(\"widekl\") => { ... };\n(\"adx\") => { ... };\n(\"rtm\") =>
{ ... };\n(\"movbe\") => { ... };\n(\"movrs\") => { ... };\n(\"ermsb\")
=> { ... };\n(\"xop\") => { ... };\n(\"abm\") => { ...
};\n(\"avx512gfni\") => { ... };\n(\"avx512vaes\") => { ...
};\n(\"avx512vpclmulqdq\") => { ... };\n($t:tt,) => { ... };\n($t:tt) =>
{ ... "

]

}

],

"reasoning": "Key sources show that lower-level bit-manipulation
primitives (and targets like PDEP/PEXT) are currently supported in
various crates, but with notable maintenance and portability issues. The
description of the Bitintr crate highlights the desire to expose CPU
intrinsics via safe, portable Rust interfaces, including x86/x86_64 ISA
intrinsics and ARM, which aligns with the identified vacuum for a
modern, maintained microcrate. The Bitintr documentation also notes
no_std safety and portability concerns, which informs the need for a
compact, portable crate that works across WASM and native targets. A
separate excerpt about has_fast_pdep documents runtime-detectable
performance considerations of BMI2/PDEP/PEXT and the need to avoid slow
microcode on certain CPUs, reinforcing the value of a robust,
cross-target fallback crate. Other excerpts discuss a runtime
feature-detection mechanism (is_x86_feature_detected) and its evolution,
which is relevant to a portable crate that can select optimized paths
per CPU while providing safe fallbacks. Together, these excerpts support
the field value by outlining a concrete gap (a maintained, portable
microcrate offering pure-Rust fallbacks for advanced bit-manipulation
primitives) and point to the needed characteristics (no_std, WASM
compatibility, good docs, minimal LOC, maintainable maintenance path).",

"confidence": "medium"

},

{

"field": "bit_twiddling_primitives_opportunity.portability_plan",

"citations": [

{

"title": "gnzlbg/bitintr: Portable Bitwise Manipulation Intrinsics",

"url": "https://github.com/gnzlbg/bitintr",

"excerpts": [

"This `#![no_std]` library exposes *safe* and *portable* low-level bit
manipulation\ninstruction set architectures."

]

},

{

"title": "Bitintr 0.3.0 Documentation and Repository",

"url": "http://docs.rs/bitintr/latest/bitintr",

"excerpts": [

"This `#![no_std]` library exposes *safe* and *portable* low-level bit
manipulation\ninstruction set architectures."

]

},

{

"title": "bitintr 0.3.0 - Docs.rs",

"url": "http://docs.rs/bitintr/0.3.0/bitintr",

"excerpts": [

"This `#![no_std]` library exposes *safe* and *portable* low-level bit
manipulation\ninstruction set architectures."

]

},

{

"title": "raw-cpuid crates.io description",

"url": "https://crates.io/crates/raw-cpuid",

"excerpts": [

"A library to parse the x86 CPUID instruction, written in rust with no
external\ndependencies. The implementation closely resembles the Intel
CPUID manual\ndescription. The library works in\nno_std environments.",

"A library to parse the x86 CPUID instruction, written in rust with no
external dependencies. The implementation closely resembles the Intel
CPUID manual description. The library does only depend on libcore.",

"raw-cpuid v11.5.0"

]

},

{

"title": "stdarch/crates/std_detect/README.md at master · rust-lang ...
- GitHub",

"url":
"https://github.com/rust-lang/stdarch/blob/master/crates/std_detect/README.md",

"excerpts": [

"If you need run-time feature detection in #[no_std] environments, Rust
core library cannot help you. By design, Rust core is platform
independent, but ...",

"The private std::detect module implements run-time feature detection in
Rust's standard library. This allows detecting whether the CPU the
binary runs on ..."

]

},

{

"title": "2873-inline-asm - The Rust RFC Book",

"url": "https://rust-lang.github.io/rfcs/2873-inline-asm.html",

"excerpts": [

"Rust provides support for inline assembly via the asm! macro. It can be
used to embed handwritten assembly in the assembly output generated by
the compiler."

]

},

{

"title": "Inline assembly - Rust By Example",

"url": "https://doc.rust-lang.org/rust-by-example/unsafe/asm.html",

"excerpts": [

"Rust provides support for inline assembly via the asm! macro. It can be
used to embed handwritten assembly in the assembly output generated by
the compiler."

]

}

],

"reasoning": "The design goal for a no_std, WASM-friendly bit-twiddling
primitives crate is supported by multiple sources. A crate explicitly
advertising a no_std, portable low-level bit manipulation surface
demonstrates that such an approach is viable without requiring standard
library features, aligning with the goal of universal portability across
targets including wasm. Additional excerpts document similar no_std
portable CPUID/x86 feature parsing libraries that operate in core/no_std
environments, indicating a path to provide fallback implementations that
do not rely on the standard library or host-specific dependencies.
Documentation for no_std run-time feature-detection in a stdarch context
reinforces that CPU capability checks can be implemented in a no_std
environment, which is crucial when compiling to WASM where the host may
not expose the same CPU feature set. Inline assembly discussions, while
tangential, highlight portability considerations and the balance between
low-level optimization and broad compatibility. Collectively, these
excerpts support the field value: a crate designed from the ground up to
be no_std and WASM-friendly, with pure Rust algorithms and optional
future optimizations gated behind features, ensuring compatibility
across all Rust-supported targets including wasm32-unknown-unknown.",

"confidence": "high"

},

{

"field": "bit_twiddling_primitives_opportunity.testing_plan",

"citations": [

{

"title": "Bitintr 0.3.0 Documentation and Repository",

"url": "http://docs.rs/bitintr/latest/bitintr",

"excerpts": [

"The following ISAs are implemented:\n\n* x86 (`bitintr::x86`):\n\n +
[`ABM`](https://en.wikipedia.org/wiki/Bit_Manipulation_Instruction_Sets.28Advanced_Bit_Manipulation.29):
Advanced Bit Manipulation instructions
([`bitintr::x86::abm`](https://gnzlbg.github.io/bitintr/bitintr/x86/abm/index.html)).\n
+
[`TBM`](https://en.wikipedia.org/wiki/Bit_Manipulation_Instruction_Sets.28Trailing_Bit_Manipulation.29):
Trailing Bit Manipulation instructions
([`bitintr::x86::tbm`](https://gnzlbg.github.io/bitintr/bitintr/x86/tbm/index.html)).\n
+
[`BMI`](https://en.wikipedia.org/wiki/Bit_Manipulation_Instruction_Sets.28Bit_Manipulation_Instruction_Set_1.29):
Bit Manipulation Instruction Set 1.0
([`bitintr::x86::bmi`](https://gnzlbg.github.io/bitintr/bitintr/x86/bmi/index.html)).\n
+
[`BMI2`](https://en.wikipedia.org/wiki/Bit_Manipulation_Instruction_Sets.28Bit_Manipulation_Instruction_Set_2.29):
Bit Manipulation Instruction Set 2.0
([`bitintr::x86::bmi2`](https://gnzlbg.github.io/bitintr/bitintr/x86/bmi2/index.html)).\n*
ARM (`bitintr::arm`):\n\n +
[`ARMv5`](http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0100i/index.html):
[`bitintr::arm::v5`](https://gnzlbg.github.io/bitintr/bitintr/arm/v5/index.html).\n
+
[`ARMv6`](http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0419c/index.html):
[`bitintr::arm::v6`](https://gnzlbg.github.io/bitintr/bitintr/arm/v6/index.html).\n
+
[`ARMv7`](http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0403e.b/index.html):
[`bitintr::arm::v7`](https://gnzlbg.github.io/bitintr/bitintr/arm/v7/index.html).\n
+
[`ARMv8`](http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0487a.k_10775/index.html):
[`bitintr::arm::v8`](https://gnzlbg.github.io/bitintr/bitintr/arm/v8/index.html).",

"This `#![no_std]` library exposes *safe* and *portable* low-level bit
manipulation\ninstruction set architectures."

]

},

{

"title": "Bit Twiddling Hacks",

"url": "https://graphics.stanford.edu/~seander/bithacks.html",

"excerpts": [

"Bit Twiddling Hacks"

]

},

{

"title": "has_fast_pdep crate page",

"url": "https://crates.io/crates/has_fast_pdep",

"excerpts": [

"Rationale\n---------\n\nZen, Zen+, Zen 2, and Hygon Dhyana CPUs
implement PDEP and PEXT using microcode in a way that makes them slower
than well-optimized, non-intrinsic fallbacks. In performance-critical
code, checking for BMI2 support isn't enough—you could end up hurting
performance on said CPUs where these instructions exist but are slow.
This crate helps you avoid that by detecting speed, not just support."

]

},

{

"title": "gnzlbg/bitintr: Portable Bitwise Manipulation Intrinsics",

"url": "https://github.com/gnzlbg/bitintr",

"excerpts": [

"This `#![no_std]` library exposes *safe* and *portable* low-level bit
manipulation\ninstruction set architectures."

]

},

{

"title": "bitintr 0.3.0 - Docs.rs",

"url": "http://docs.rs/bitintr/0.3.0/bitintr",

"excerpts": [

"This `#![no_std]` library exposes *safe* and *portable* low-level bit
manipulation\ninstruction set architectures."

]

},

{

"title": "cpufeatures crate on crates.io",

"url": "https://crates.io/crates/cpufeatures",

"excerpts": [

"aarch64"

]

},

{

"title": "core::arch::x86_64 - Rust",

"url": "https://doc.rust-lang.org/core/arch/x86_64/index.html",

"excerpts": [

"Transpose the 4x4 matrix formed by 4 rows of __m128 in place. __cpuid
⚠x86 or x86-64: See __cpuid_count . __cpuid_count ⚠x86 or x86-64:
Returns the result ..."

]

},

{

"title": "is_x86_feature_detected in std",

"url":
"https://doc.rust-lang.org/std/macro.is_x86_feature_detected.html",

"excerpts": [

"A macro to test at runtime whether a CPU feature is available on
x86/x86-64 platforms. This macro is provided in the standard library and
will detect at runtime std 1.88.0\n(6b00bc388
2025-06-23)\nis_\nx86_\nfeature_\ndetected\nSections\n * Supported
arguments\n\nIn crate std\nstd\nMacro is_x86_feature_detected\nCopy item
path\n1.27.0 · Source\nmacro_rules!\nis_x86_feature_detected
{\n(\"aes\") => { ... };\n(\"pclmulqdq\") => { ... };\n(\"rdrand\") => {
... };\n(\"rdseed\") => { ... };\n(\"tsc\") => { ... };\n(\"mmx\") => {
... };\n(\"sse\") => { ... };\n(\"sse2\") => { ... };\n(\"sse3\") => {
... };\n(\"ssse3\") => { ... };\n(\"sse4.1\") => { ... };\n(\"sse4.2\")
=> { ... };\n(\"sse4a\") => { ... };\n(\"sha\") => { ... };\n(\"avx\")
=> { ... };\n(\"avx2\") => { ... };\n(\"sha512\") => { ... };\n(\"sm3\")
=> { ... };\n(\"sm4\") => { ... };\n(\"avx512f\") => { ...
};\n(\"avx512cd\") => { ... };\n(\"avx512er\") => { ...
};\n(\"avx512pf\") => { ... };\n(\"avx512bw\") => { ...
};\n(\"avx512dq\") => { ... };\n(\"avx512vl\") => { ...
};\n(\"avx512ifma\") => { ... };\n(\"avx512vbmi\") => { ...
};\n(\"avx512vpopcntdq\") => { ... };\n(\"avx512vbmi2\") => { ...
};\n(\"gfni\") => { ... };\n(\"vaes\") => { ... };\n(\"vpclmulqdq\") =>
{ ... };\n(\"avx512vnni\") => { ... };\n(\"avx512bitalg\") => { ...
};\n(\"avx512bf16\") => { ... };\n(\"avx512vp2intersect\") => { ...
};\n(\"avx512fp16\") => { ... };\n(\"avxifma\") => { ...
};\n(\"avxneconvert\") => { ... };\n(\"avxvnni\") => { ...
};\n(\"avxvnniint16\") => { ... };\n(\"avxvnniint8\") => { ...
};\n(\"amx-tile\") => { ... };\n(\"amx-int8\") => { ...
};\n(\"amx-bf16\") => { ... };\n(\"amx-fp16\") => { ...
};\n(\"amx-complex\") => { ... };\n(\"amx-avx512\") => { ...
};\n(\"amx-fp8\") => { ... };\n(\"amx-movrs\") => { ...
};\n(\"amx-tf32\") => { ... };\n(\"amx-transpose\") => { ...
};\n(\"f16c\") => { ... };\n(\"fma\") => { ... };\n(\"bmi1\") => { ...
};\n(\"bmi2\") => { ... };\n(\"lzcnt\") => { ... };\n(\"tbm\") => { ...
};\n(\"popcnt\") => { ... };\n(\"fxsr\") => { ...\n};\n(\"xsave\") => {
... };\n(\"xsaveopt\") => { ... };\n(\"xsaves\") => { ...
};\n(\"xsavec\") => { ... };\n(\"cmpxchg16b\") => { ... };\n(\"kl\") =>
{ ... };\n(\"widekl\") => { ... };\n(\"adx\") => { ... };\n(\"rtm\") =>
{ ... };\n(\"movbe\") => { ... };\n(\"movrs\") => { ... };\n(\"ermsb\")
=> { ... };\n(\"xop\") => { ... };\n(\"abm\") => { ...
};\n(\"avx512gfni\") => { ... };\n(\"avx512vaes\") => { ...
};\n(\"avx512vpclmulqdq\") => { ... };\n($t:tt,) => { ... };\n($t:tt) =>
{ ... "

]

},

{

"title": "stdarch/crates/std_detect/README.md at master · rust-lang ...
- GitHub",

"url":
"https://github.com/rust-lang/stdarch/blob/master/crates/std_detect/README.md",

"excerpts": [

"The private std::detect module implements run-time feature detection in
Rust's standard library. This allows detecting whether the CPU the
binary runs on ..."

]

}

],

"reasoning": "To establish a robust testing plan for bit-twiddling
primitives, we should anchor it in sources that discuss: (1) standard
bit-manipulation hacks and well-known deterministic properties of
bitwise operations, which inform test vector design and invariants; (2)
CPU feature detection and hardware-assisted paths (e.g., PDEP/PEXT,
BMI2) to justify cross-platform testing and the need for validated
fallbacks when hardware features are absent or slow; (3) Rust-specific
intrinsics and no_std considerations to ensure tests run in constrained
environments; (4) practical references on how to structure tests around
bit manipulations using available tooling in Rust; (5) documentation of
core CPU feature queries used to gate optimized paths; (6) guidance on
detecting and using hardware features safely in Rust. The selected
excerpts collectively provide evidence for a testing plan that includes:
test vectors derived from canonical bit-hacking references, explicit
runtime checks for BMI2/PDEP/PEXT support, and the option to compare
software fallbacks against hardware-accelerated implementations where
present. For example, using canonical bit-twiddling hacks as test
vectors helps verify core properties such as branchless min/max, bit
extraction, and bitfield operations; runtime feature detection justifies
including guard rails in tests to select the correct code paths
depending on the host CPU; no_std considerations necessitate tests that
can run in environments without the full standard library; and
documentation of std::arch x86_64 intrinsics underpins
cross-verification against native instructions. Taken together, these
excerpts support a testing plan that leverages: canonical
bit-manipulation knowledge to craft deterministic test vectors, runtime
CPU feature checks to drive conditional tests, and cross-verification
against hardware intrinsics to gain high confidence in correctness
across platforms. The plan assigns high relevance to content describing
exact bit-twiddling techniques, CPU feature detection, and no_std
considerations, with incremental relevance to software fallbacks and
Rust-specific testing tooling.",

"confidence": "high"

},

{

"field": "bit_twiddling_primitives_opportunity.proposed_api",

"citations": [

{

"title": "has_fast_pdep crate page",

"url": "https://crates.io/crates/has_fast_pdep",

"excerpts": [

"A single-function, `no-std` library that returns `true` if the current
CPU implements PDEP and PEXT with fast, non-microcoded hardware.",

"Rationale\n---------\n\nZen, Zen+, Zen 2, and Hygon Dhyana CPUs
implement PDEP and PEXT using microcode in a way that makes them slower
than well-optimized, non-intrinsic fallbacks. In performance-critical
code, checking for BMI2 support isn't enough—you could end up hurting
performance on said CPUs where these instructions exist but are slow.
This crate helps you avoid that by detecting speed, not just support.",

"Detect fast hardware support for PDEP/PEXT.",

"3 months ago"

]

},

{

"title": "Bitintr 0.3.0 Documentation and Repository",

"url": "http://docs.rs/bitintr/latest/bitintr",

"excerpts": [

"The following ISAs are implemented:\n\n* x86 (`bitintr::x86`):\n\n +
[`ABM`](https://en.wikipedia.org/wiki/Bit_Manipulation_Instruction_Sets.28Advanced_Bit_Manipulation.29):
Advanced Bit Manipulation instructions
([`bitintr::x86::abm`](https://gnzlbg.github.io/bitintr/bitintr/x86/abm/index.html)).\n
+
[`TBM`](https://en.wikipedia.org/wiki/Bit_Manipulation_Instruction_Sets.28Trailing_Bit_Manipulation.29):
Trailing Bit Manipulation instructions
([`bitintr::x86::tbm`](https://gnzlbg.github.io/bitintr/bitintr/x86/tbm/index.html)).\n
+
[`BMI`](https://en.wikipedia.org/wiki/Bit_Manipulation_Instruction_Sets.28Bit_Manipulation_Instruction_Set_1.29):
Bit Manipulation Instruction Set 1.0
([`bitintr::x86::bmi`](https://gnzlbg.github.io/bitintr/bitintr/x86/bmi/index.html)).\n
+
[`BMI2`](https://en.wikipedia.org/wiki/Bit_Manipulation_Instruction_Sets.28Bit_Manipulation_Instruction_Set_2.29):
Bit Manipulation Instruction Set 2.0
([`bitintr::x86::bmi2`](https://gnzlbg.github.io/bitintr/bitintr/x86/bmi2/index.html)).\n*
ARM (`bitintr::arm`):\n\n +
[`ARMv5`](http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0100i/index.html):
[`bitintr::arm::v5`](https://gnzlbg.github.io/bitintr/bitintr/arm/v5/index.html).\n
+
[`ARMv6`](http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0419c/index.html):
[`bitintr::arm::v6`](https://gnzlbg.github.io/bitintr/bitintr/arm/v6/index.html).\n
+
[`ARMv7`](http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0403e.b/index.html):
[`bitintr::arm::v7`](https://gnzlbg.github.io/bitintr/bitintr/arm/v7/index.html).\n
+
[`ARMv8`](http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0487a.k_10775/index.html):
[`bitintr::arm::v8`](https://gnzlbg.github.io/bitintr/bitintr/arm/v8/index.html).",

"The intrinsics are exposed via traits named after their CPU
instruction."

]

},

{

"title": "Bitintr crate - Rust crates.io",

"url": "https://crates.io/crates/bitintr",

"excerpts": [

"The intrinsics are exposed via traits named after their CPU
instruction."

]

},

{

"title": "bitintr on docs.rs",

"url": "https://docs.rs/crate/bitintr/latest",

"excerpts": [

"The intrinsics are exposed via traits named after their CPU
instruction. These\ntraits are implemented for all integer types except"

]

},

{

"title": "Bit Twiddling Hacks",

"url": "https://graphics.stanford.edu/~seander/bithacks.html",

"excerpts": [

"Bit Twiddling Hacks",

"unsigned int t = v | (v - 1); // t gets v's least significant 0 bits
set to 1\n// Next set to 1 the most significant bit to change, // set to
0 the least significant ones, and add the necessary 1 bits."

]

},

{

"title": "is_x86_feature_detected in std",

"url":
"https://doc.rust-lang.org/std/macro.is_x86_feature_detected.html",

"excerpts": [

"A macro to test at runtime whether a CPU feature is available on
x86/x86-64 platforms. This macro is provided in the standard library and
will detect at runtime std 1.88.0\n(6b00bc388
2025-06-23)\nis_\nx86_\nfeature_\ndetected\nSections\n * Supported
arguments\n\nIn crate std\nstd\nMacro is_x86_feature_detected\nCopy item
path\n1.27.0 · Source\nmacro_rules!\nis_x86_feature_detected
{\n(\"aes\") => { ... };\n(\"pclmulqdq\") => { ... };\n(\"rdrand\") => {
... };\n(\"rdseed\") => { ... };\n(\"tsc\") => { ... };\n(\"mmx\") => {
... };\n(\"sse\") => { ... };\n(\"sse2\") => { ... };\n(\"sse3\") => {
... };\n(\"ssse3\") => { ... };\n(\"sse4.1\") => { ... };\n(\"sse4.2\")
=> { ... };\n(\"sse4a\") => { ... };\n(\"sha\") => { ... };\n(\"avx\")
=> { ... };\n(\"avx2\") => { ... };\n(\"sha512\") => { ... };\n(\"sm3\")
=> { ... };\n(\"sm4\") => { ... };\n(\"avx512f\") => { ...
};\n(\"avx512cd\") => { ... };\n(\"avx512er\") => { ...
};\n(\"avx512pf\") => { ... };\n(\"avx512bw\") => { ...
};\n(\"avx512dq\") => { ... };\n(\"avx512vl\") => { ...
};\n(\"avx512ifma\") => { ... };\n(\"avx512vbmi\") => { ...
};\n(\"avx512vpopcntdq\") => { ... };\n(\"avx512vbmi2\") => { ...
};\n(\"gfni\") => { ... };\n(\"vaes\") => { ... };\n(\"vpclmulqdq\") =>
{ ... };\n(\"avx512vnni\") => { ... };\n(\"avx512bitalg\") => { ...
};\n(\"avx512bf16\") => { ... };\n(\"avx512vp2intersect\") => { ...
};\n(\"avx512fp16\") => { ... };\n(\"avxifma\") => { ...
};\n(\"avxneconvert\") => { ... };\n(\"avxvnni\") => { ...
};\n(\"avxvnniint16\") => { ... };\n(\"avxvnniint8\") => { ...
};\n(\"amx-tile\") => { ... };\n(\"amx-int8\") => { ...
};\n(\"amx-bf16\") => { ... };\n(\"amx-fp16\") => { ...
};\n(\"amx-complex\") => { ... };\n(\"amx-avx512\") => { ...
};\n(\"amx-fp8\") => { ... };\n(\"amx-movrs\") => { ...
};\n(\"amx-tf32\") => { ... };\n(\"amx-transpose\") => { ...
};\n(\"f16c\") => { ... };\n(\"fma\") => { ... };\n(\"bmi1\") => { ...
};\n(\"bmi2\") => { ... };\n(\"lzcnt\") => { ... };\n(\"tbm\") => { ...
};\n(\"popcnt\") => { ... };\n(\"fxsr\") => { ...\n};\n(\"xsave\") => {
... };\n(\"xsaveopt\") => { ... };\n(\"xsaves\") => { ...
};\n(\"xsavec\") => { ... };\n(\"cmpxchg16b\") => { ... };\n(\"kl\") =>
{ ... };\n(\"widekl\") => { ... };\n(\"adx\") => { ... };\n(\"rtm\") =>
{ ... };\n(\"movbe\") => { ... };\n(\"movrs\") => { ... };\n(\"ermsb\")
=> { ... };\n(\"xop\") => { ... };\n(\"abm\") => { ...
};\n(\"avx512gfni\") => { ... };\n(\"avx512vaes\") => { ...
};\n(\"avx512vpclmulqdq\") => { ... };\n($t:tt,) => { ... };\n($t:tt) =>
{ ... "

]

}

],

"reasoning": "The most relevant excerpts discuss concrete runtime
detection and performance considerations for PDEP/PEXT-like primitives.
These sources explain that some CPUs implement PDEP/PEXT in hardware,
while others may require slower fallbacks, and they emphasize checking
for fast hardware paths rather than merely supporting the feature. This
directly informs the feasibility and design of an API that exposes
parallel bit-deposit and parallel bit-extract operations (pdep/pext) as
trait methods on primitive integer types, guiding whether
implementations should dispatch to hardware intrinsics or software
fallbacks depending on the CPU. They also highlight that detection can
be cached and that certain CPUs may have slower microcode paths, which
justifies a design where the API can select the fast path at runtime and
cache the result for zero-cost subsequent calls. This aligns with the
proposed API in which BitTwiddle provides pdep and pext methods, and
select uses a mask to branchlessly pick between alternatives, with
interleave_bits_u32 offering a Morton-like bit-interleaving operation.
Other excerpts describe Bit Twiddling Hacks and general bit-manipulation
strategies, including classic branchless tricks and bitwise recipes for
operations such as next permutation, min/max without branches, and
various bit-decomposition techniques. These reinforce that the intended
300 LOC crate would reasonably include concise, well-scoped trait
methods (pdep, pext, has_zero_byte, select) plus a small helper like
interleave_bits_u32, supported by a lean set of helper utilities drawn
from public-domain bit-twiddling techniques. The Bitintr-related
excerpts corroborate that low-level, no_std-friendly bit intrinsics can
be exposed as traits named after CPU instructions, which dovetails with
the goal of providing a compact, ergonomic API surface. The presence of
documentation and examples in Bit Twiddling Hacks further supports the
viability of compact, example-driven API design. The
is_x86_feature_detected excerpt emphasizes the existence of a standard
macro for runtime feature detection, which is relevant for deciding
between hardware-accelerated paths and software fallbacks in the API
surface. Collectively, these excerpts support the notion that a small
Rust crate exposing a BitTwiddle trait with pdep/pext semantics, a
Morton interleave helper, and a has_zero_byte/select utility is
plausible and aligns with established bit-manipulation practices in the
Rust ecosystem.",

"confidence": "high"

},

{

"field": "bit_twiddling_primitives_opportunity.pmf_rationale",

"citations": [

{

"title": "Bitintr 0.3.0 Documentation and Repository",

"url": "http://docs.rs/bitintr/latest/bitintr",

"excerpts": [

"The following ISAs are implemented:\n\n* x86 (`bitintr::x86`):\n\n +
[`ABM`](https://en.wikipedia.org/wiki/Bit_Manipulation_Instruction_Sets.28Advanced_Bit_Manipulation.29):
Advanced Bit Manipulation instructions
([`bitintr::x86::abm`](https://gnzlbg.github.io/bitintr/bitintr/x86/abm/index.html)).\n
+
[`TBM`](https://en.wikipedia.org/wiki/Bit_Manipulation_Instruction_Sets.28Trailing_Bit_Manipulation.29):
Trailing Bit Manipulation instructions
([`bitintr::x86::tbm`](https://gnzlbg.github.io/bitintr/bitintr/x86/tbm/index.html)).\n
+
[`BMI`](https://en.wikipedia.org/wiki/Bit_Manipulation_Instruction_Sets.28Bit_Manipulation_Instruction_Set_1.29):
Bit Manipulation Instruction Set 1.0
([`bitintr::x86::bmi`](https://gnzlbg.github.io/bitintr/bitintr/x86/bmi/index.html)).\n
+
[`BMI2`](https://en.wikipedia.org/wiki/Bit_Manipulation_Instruction_Sets.28Bit_Manipulation_Instruction_Set_2.29):
Bit Manipulation Instruction Set 2.0
([`bitintr::x86::bmi2`](https://gnzlbg.github.io/bitintr/bitintr/x86/bmi2/index.html)).\n*
ARM (`bitintr::arm`):\n\n +
[`ARMv5`](http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0100i/index.html):
[`bitintr::arm::v5`](https://gnzlbg.github.io/bitintr/bitintr/arm/v5/index.html).\n
+
[`ARMv6`](http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0419c/index.html):
[`bitintr::arm::v6`](https://gnzlbg.github.io/bitintr/bitintr/arm/v6/index.html).\n
+
[`ARMv7`](http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0403e.b/index.html):
[`bitintr::arm::v7`](https://gnzlbg.github.io/bitintr/bitintr/arm/v7/index.html).\n
+
[`ARMv8`](http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0487a.k_10775/index.html):
[`bitintr::arm::v8`](https://gnzlbg.github.io/bitintr/bitintr/arm/v8/index.html).",

"This `#![no_std]` library exposes *safe* and *portable* low-level bit
manipulation\ninstruction set architectures.",

"The Minimum Supported Rust Version is 1.36.0."

]

},

{

"title": "gnzlbg/bitintr: Portable Bitwise Manipulation Intrinsics",

"url": "https://github.com/gnzlbg/bitintr",

"excerpts": [

"This `#![no_std]` library exposes *safe* and *portable* low-level bit
manipulation\ninstruction set architectures."

]

},

{

"title": "bitintr 0.3.0 - Docs.rs",

"url": "http://docs.rs/bitintr/0.3.0/bitintr",

"excerpts": [

"This `#![no_std]` library exposes *safe* and *portable* low-level bit
manipulation\ninstruction set architectures."

]

},

{

"title": "Bit Twiddling Hacks",

"url": "https://graphics.stanford.edu/~seander/bithacks.html",

"excerpts": [

"Bit Twiddling Hacks",

"\nBy Sean Eron Anderson seander@cs.stanford.edu Individually, the code
snippets here are in the public domain (unless otherwise noted) — feel
free to use them however you please. The aggregate collection and
descriptions are © 1997-2005 Sean Eron Anderson. The code and
descriptions are distributed in the hope that they will be useful,",

"The method first shifts and XORs the eight nibbles of the 32-bit value
together, leaving the result in the lowest nibble of v. Next, the binary
number 0110 ..."

]

},

{

"title": "bitintr on docs.rs",

"url": "https://docs.rs/crate/bitintr/latest",

"excerpts": [

"The intrinsics are exposed via traits named after their CPU
instruction. These\ntraits are implemented for all integer types except"

]

},

{

"title": "has_fast_pdep crate page",

"url": "https://crates.io/crates/has_fast_pdep",

"excerpts": [

"Rationale\n---------\n\nZen, Zen+, Zen 2, and Hygon Dhyana CPUs
implement PDEP and PEXT using microcode in a way that makes them slower
than well-optimized, non-intrinsic fallbacks. In performance-critical
code, checking for BMI2 support isn't enough—you could end up hurting
performance on said CPUs where these instructions exist but are slow.
This crate helps you avoid that by detecting speed, not just support.",

"You can view the documentation on docs.rs
[here](https://docs.rs/has_fast_pdep)."

]

},

{

"title": "Bit Twiddling Hacks",

"url": "https://www.cl.cam.ac.uk/~awc32/bithacks.html",

"excerpts": [

"Bit Twiddling Hacks\n===================\n"

]

}

],

"reasoning": "Key evidence shows a coherent set of high-value,
small-size bit-manipulation primitives and related utilities across
domains. The most directly relevant material points to a portable,
no_std capable bit manipulation crate and the core idea of exposing CPU
intrinsics via safe Rust abstractions. For instance, one excerpt
explicitly describes a no_std, portable bit manipulation library aligned
with CPU instruction sets, signaling a strong candidate for a compact,
high-utility Rust crate that could replace older, less-reliable crates.
Another excerpt highlights that bit intrinsics are exposed via
CPU-instruction-named traits, which directly maps to the PMF claim that
small, well-abstracted primitives around CPU instructions can be broadly
useful across domains like graphics, cryptography, and databases.
Additional excerpts discuss Bit Twiddling Hacks as a centralized
resource and mention specific bit-manipulation techniques (e.g.,
next-bit tricks, bit-permutations) that underpin compact, branchless
implementations, underscoring the potential for small libraries that
implement these well in Rust. There is also strong signal around
PDEP/PEXT (bit manipulation instructions) and CPU feature detection,
which supports the PMF assertion that branchless, architecture-aware
utilities are valuable; one excerpt explains how a crate helps avoid
slower microcode fallbacks by detecting hardware speed rather than mere
support, which is crucial for a lean, high-performance crate. The
presence of Bitintr-related material, including docs about exposing
intrinsics and safe wrappers, corroborates the opportunity for a modern,
robust replacement; the cited content shows a vacuum due to the prior
crate's failure, which reinforces the PMF claim. Supporting items also
discuss the broader applicability and cross-domain relevance (graphics,
data packing, cryptography, databases), further validating the high PMF
of such a product. ",

"confidence": "high"

}

],

"outputSchema": {

"type": "object",

"properties": {

"executive_summary": {

"type": "string",

"description": "A high-level summary of the findings, highlighting the
abundance of opportunities for creating high-impact, minimal (<300 LOC)
Rust libraries in the CPU domain."

},

"key_opportunity_areas": {

"type": "string",

"description": "An analysis of the common themes and categories where
gaps in the Rust ecosystem exist, such as the demand for `no_std` and
WASM-compatible utilities, minimal dependency alternatives to large
crates, and porting well-regarded C/C++ libraries."

},

"opportunity_summary_table": {

"type": "array",

"items": {

"type": "object",

"properties": {

"opportunity_name": {

"type": "string",

"description": "The name or category of the library opportunity."

},

"reasoning": {

"type": "string",

"description": "The rationale for why this is a good opportunity,
including gaps in the current ecosystem."

},

"pmf_probability_score": {

"type": "string",

"description": "An estimated score (e.g., 85/100) representing the
Product-Market Fit probability."

},

"ease_of_success_testing": {

"type": "string",

"description": "An estimated score (e.g., 95/100) for how easily the
library's success and correctness can be tested."

},

"relevant_artifacts_links": {

"type": "string",

"description": "A string containing links to relevant papers, source
code, or specifications."

}

},

"required": [

"opportunity_name",

"reasoning",

"pmf_probability_score",

"ease_of_success_testing",

"relevant_artifacts_links"

],

"additionalProperties": false

},

"description": "A summary table of the most promising opportunities,
directly addressing the user's request. Each item in this array
represents a single library opportunity and should be expanded into an
object in the next step with keys for 'opportunity_name', 'reasoning',
'pmf_probability_score', 'ease_of_success_testing', and
'relevant_artifacts_links'."

},

"bit_twiddling_primitives_opportunity": {

"type": "object",

"properties": {

"gap_analysis": {

"type": "string",

"description": "Analysis of the gap this crate fills compared to
existing solutions like the unmaintained `bitintr` crate."

},

"proposed_api": {

"type": "string",

"description": "A conceptual API for the microcrate, including function
signatures for PDEP/PEXT and Morton coding."

},

"portability_plan": {

"type": "string",

"description": "Plan for ensuring `no_std` and WASM compatibility by
using pure Rust software fallbacks."

},

"pmf_rationale": {

"type": "string",

"description": "Justification for high Product-Market Fit, citing use
cases in graphics, compression, and cryptography."

},

"testing_plan": {

"type": "string",

"description": "Strategy for testing correctness, including the use of
test vectors and property-based testing."

}

},

"required": [

"gap_analysis",

"proposed_api",

"portability_plan",

"pmf_rationale",

"testing_plan"

],

"additionalProperties": false

},

"minimal_rng_opportunity": {

"type": "string",

"description": "Evaluation of a minimal RNG microcrate (e.g., PCG32,
Xoshiro128++) as a tiny, dependency-free alternative to the full `rand`
ecosystem for constrained environments."

},

"ziggurat_sampler_opportunity": {

"type": "string",

"description": "Feasibility of a Ziggurat-based sampler for standard
normal and exponential distributions, offering a minimal-footprint
alternative to `rand_distr` for simulations and scientific computing."

},

"specialized_float_formatting_opportunity": {

"type": "string",

"description": "Assessment of a micro-crate for `f32`-only
shortest-roundtrip decimal conversion (e.g., using Ryu or Dragonbox),
targeting `no_std`/WASM environments where binary size is critical."

},

"stoer_wagner_min_cut_opportunity": {

"type": "string",

"description": "Details on implementing the Stoer-Wagner algorithm for
global minimum cut, a function notably absent from major Rust graph
libraries like `petgraph`."

},

"portable_simd_helpers_opportunity": {

"type": "string",

"description": "Proposal for a micro-crate providing high-impact SIMD
utilities (e.g., horizontal sums, interleaving) that are missing or
inefficient in the current `portable-simd` project."

},

"minimal_cpu_feature_detection_opportunity": {

"type": "string",

"description": "Analysis of a tiny, cross-platform, `no_std`-first CPU
feature detection crate as a minimalist alternative to `cpufeatures` or
`raw-cpuid`."

},

"fixed_point_math_opportunity": {

"type": "string",

"description": "Evaluation of a fixed-point math microcrate (e.g.,
Q15.16, Q1.31) for DSP, embedded, and FPU-less environments, serving as
a tiny alternative to the comprehensive `fixed` crate."

},

"tiny_matrix_math_opportunity": {

"type": "string",

"description": "Design for a `const`-evaluable 2x2/3x3 matrix library
with essential operations, providing a bloat-free alternative to `glam`
or `nalgebra` for 2D graphics and simple math."

},

"stable_non_cryptographic_hash_opportunity": {

"type": "string",

"description": "Assessment of a microcrate for stable, non-cryptographic
hashing (e.g., wyhash, xxHash32) for use cases like checksums,
contrasting with the non-stable output of `ahash`."

},

"fast_inverse_square_root_opportunity": {

"type": "string",

"description": "Feasibility of porting the classic 'Quake III' fast
inverse square root algorithm, a valuable utility for graphics and
physics simulations in `no_std` contexts."

},

"branchless_integer_primitives_opportunity": {

"type": "string",

"description": "Proposal for a crate providing branchless, constant-time
integer min/max/selection functions, crucial for cryptographic and
security-sensitive applications."

},

"lock_free_spsc_ring_buffer_opportunity": {

"type": "string",

"description": "Evaluation of a minimal, `no_alloc`, atomics-only
single-producer single-consumer ring buffer, rigorously tested with
`loom` for correctness."

},

"minimal_base_encoders_opportunity": {

"type": "string",

"description": "Analysis of a tiny crate for Hex (Base16) and Crockford
Base32 encoding, focusing on high throughput and an optional SIMD path."

},

"tableless_crc_opportunity": {

"type": "string",

"description": "Assessment of a tableless CRC32/CRC64 implementation,
prioritizing minimal binary footprint for embedded and WASM use cases
over the speed of table-based crates."

},

"reservoir_sampling_opportunity": {

"type": "string",

"description": "Details on a microcrate for reservoir sampling
(Algorithms R and L) for efficient random sampling from data streams
with constant memory usage."

},

"polynomial_approximation_opportunity": {

"type": "string",

"description": "Proposal for a fast `f32` math approximation library
(expf, logf, sinf) using minimax polynomials, targeting ML inference and
graphics where speed is critical."

},

"fast_integer_parser_opportunity": {

"type": "string",

"description": "Evaluation of a fast decimal `atoi` microcrate for
parsing 32/64-bit integers with SWAR or SIMD techniques, as a minimal
alternative to `lexical-core`."

},

"atomic_spin_backoff_opportunity": {

"type": "string",

"description": "Design for a tiny atomic backoff/yield crate providing
cross-platform spin strategies, serving as a fundamental primitive for
building synchronization constructs."

},

"c_cpp_porting_candidates": {

"type": "array",

"items": {

"type": "object",

"properties": {

"utility_name": {

"type": "string",

"description": "The name of the C/C++ utility or algorithm."

},

"category": {

"type": "string",

"description": "The category of the utility (e.g., PRNG, Hash, FFT)."

},

"description": {

"type": "string",

"description": "A brief description of what the utility does."

},

"source_and_license": {

"type": "string",

"description": "The original source link and its license."

},

"porting_rationale": {

"type": "string",

"description": "The reason why porting this to a tiny Rust crate is a
good opportunity."

},

"estimated_loc": {

"type": "string",

"description": "Estimated lines of code for the Rust port."

}

},

"required": [

"utility_name",

"category",

"description",

"source_and_license",

"porting_rationale",

"estimated_loc"

],

"additionalProperties": false

},

"description": "A curated list of high-impact, permissively-licensed,
single-file C/C++ CPU-centric utilities (e.g., PRNGs, hashes, FFTs) that
lack tiny, idiomatic Rust ports and represent excellent opportunities."

}

},

"required": [

"executive_summary",

"key_opportunity_areas",

"opportunity_summary_table",

"bit_twiddling_primitives_opportunity",

"minimal_rng_opportunity",

"ziggurat_sampler_opportunity",

"specialized_float_formatting_opportunity",

"stoer_wagner_min_cut_opportunity",

"portable_simd_helpers_opportunity",

"minimal_cpu_feature_detection_opportunity",

"fixed_point_math_opportunity",

"tiny_matrix_math_opportunity",

"stable_non_cryptographic_hash_opportunity",

"fast_inverse_square_root_opportunity",

"branchless_integer_primitives_opportunity",

"lock_free_spsc_ring_buffer_opportunity",

"minimal_base_encoders_opportunity",

"tableless_crc_opportunity",

"reservoir_sampling_opportunity",

"polynomial_approximation_opportunity",

"fast_integer_parser_opportunity",

"atomic_spin_backoff_opportunity",

"c_cpp_porting_candidates"

],

"additionalProperties": false

}

}
